/* tslint:disable */
/* eslint-disable */
/**
 * spire
 * spire API documentation
 *
 * The version of the OpenAPI document: 3.0
 * Contact: akkadius1@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ModelsAaAbility
 */
export interface ModelsAaAbility {
    /**
     * 
     * @type {number}
     * @memberof ModelsAaAbility
     */
    category?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAaAbility
     */
    charges?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAaAbility
     */
    classes?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAaAbility
     */
    deities?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAaAbility
     */
    drakkin_heritage?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAaAbility
     */
    enabled?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAaAbility
     */
    first_rank_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAaAbility
     */
    grant_only?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAaAbility
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsAaAbility
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsAaAbility
     */
    races?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAaAbility
     */
    reset_on_death?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAaAbility
     */
    status?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAaAbility
     */
    type?: number;
}
/**
 * 
 * @export
 * @interface ModelsAaRank
 */
export interface ModelsAaRank {
    /**
     * 
     * @type {number}
     * @memberof ModelsAaRank
     */
    cost?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAaRank
     */
    desc_sid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAaRank
     */
    expansion?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAaRank
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAaRank
     */
    level_req?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAaRank
     */
    lower_hotkey_sid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAaRank
     */
    next_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAaRank
     */
    prev_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAaRank
     */
    recast_time?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAaRank
     */
    spell?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAaRank
     */
    spell_type?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAaRank
     */
    title_sid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAaRank
     */
    upper_hotkey_sid?: number;
}
/**
 * 
 * @export
 * @interface ModelsAccount
 */
export interface ModelsAccount {
    /**
     * 
     * @type {Array<ModelsAccountFlag>}
     * @memberof ModelsAccount
     */
    account_flags?: Array<ModelsAccountFlag>;
    /**
     * 
     * @type {Array<ModelsAccountIp>}
     * @memberof ModelsAccount
     */
    account_ips?: Array<ModelsAccountIp>;
    /**
     * 
     * @type {Array<ModelsAccountReward>}
     * @memberof ModelsAccount
     */
    account_rewards?: Array<ModelsAccountReward>;
    /**
     * 
     * @type {string}
     * @memberof ModelsAccount
     */
    ban_reason?: string;
    /**
     * 
     * @type {Array<ModelsBugReport>}
     * @memberof ModelsAccount
     */
    bug_reports?: Array<ModelsBugReport>;
    /**
     * 
     * @type {string}
     * @memberof ModelsAccount
     */
    charname?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsAccount
     */
    expansion?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAccount
     */
    gmspeed?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAccount
     */
    hideme?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAccount
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAccount
     */
    karma?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsAccount
     */
    ls_id?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsAccount
     */
    lsaccount_id?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsAccount
     */
    minilogin_ip?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsAccount
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsAccount
     */
    password?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsAccount
     */
    revoked?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAccount
     */
    rulesflag?: number;
    /**
     * 
     * @type {Array<ModelsSharedbank>}
     * @memberof ModelsAccount
     */
    sharedbanks?: Array<ModelsSharedbank>;
    /**
     * 
     * @type {number}
     * @memberof ModelsAccount
     */
    sharedplat?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAccount
     */
    status?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsAccount
     */
    suspend_reason?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsAccount
     */
    suspendeduntil?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsAccount
     */
    time_creation?: number;
}
/**
 * 
 * @export
 * @interface ModelsAccountFlag
 */
export interface ModelsAccountFlag {
    /**
     * 
     * @type {number}
     * @memberof ModelsAccountFlag
     */
    p_accid?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsAccountFlag
     */
    p_flag?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsAccountFlag
     */
    p_value?: string;
}
/**
 * 
 * @export
 * @interface ModelsAccountIp
 */
export interface ModelsAccountIp {
    /**
     * 
     * @type {number}
     * @memberof ModelsAccountIp
     */
    accid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAccountIp
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsAccountIp
     */
    ip?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsAccountIp
     */
    lastused?: string;
}
/**
 * 
 * @export
 * @interface ModelsAccountReward
 */
export interface ModelsAccountReward {
    /**
     * 
     * @type {number}
     * @memberof ModelsAccountReward
     */
    account_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAccountReward
     */
    amount?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAccountReward
     */
    reward_id?: number;
}
/**
 * 
 * @export
 * @interface ModelsAdventureDetail
 */
export interface ModelsAdventureDetail {
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureDetail
     */
    adventure_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureDetail
     */
    assassinate_count?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureDetail
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureDetail
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureDetail
     */
    instance_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureDetail
     */
    status?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureDetail
     */
    time_completed?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureDetail
     */
    time_created?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureDetail
     */
    time_zoned?: number;
}
/**
 * 
 * @export
 * @interface ModelsAdventureMember
 */
export interface ModelsAdventureMember {
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureMember
     */
    charid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureMember
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface ModelsAdventureStat
 */
export interface ModelsAdventureStat {
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureStat
     */
    guk_losses?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureStat
     */
    guk_wins?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureStat
     */
    mir_losses?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureStat
     */
    mir_wins?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureStat
     */
    mmc_losses?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureStat
     */
    mmc_wins?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureStat
     */
    player_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureStat
     */
    ruj_losses?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureStat
     */
    ruj_wins?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureStat
     */
    tak_losses?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureStat
     */
    tak_wins?: number;
}
/**
 * 
 * @export
 * @interface ModelsAdventureTemplate
 */
export interface ModelsAdventureTemplate {
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureTemplate
     */
    assa_h?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureTemplate
     */
    assa_x?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureTemplate
     */
    assa_y?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureTemplate
     */
    assa_z?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureTemplate
     */
    dest_h?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureTemplate
     */
    dest_x?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureTemplate
     */
    dest_y?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureTemplate
     */
    dest_z?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureTemplate
     */
    duration?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsAdventureTemplate
     */
    graveyard_radius?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureTemplate
     */
    graveyard_x?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureTemplate
     */
    graveyard_y?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureTemplate
     */
    graveyard_z?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureTemplate
     */
    graveyard_zone_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureTemplate
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureTemplate
     */
    is_hard?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureTemplate
     */
    is_raid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureTemplate
     */
    lose_points?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureTemplate
     */
    max_level?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureTemplate
     */
    min_level?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsAdventureTemplate
     */
    text?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureTemplate
     */
    theme?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureTemplate
     */
    type?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureTemplate
     */
    type_count?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureTemplate
     */
    type_data?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureTemplate
     */
    win_points?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsAdventureTemplate
     */
    zone?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureTemplate
     */
    zone_in_object_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureTemplate
     */
    zone_in_time?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureTemplate
     */
    zone_in_x?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureTemplate
     */
    zone_in_y?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureTemplate
     */
    zone_in_zone_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureTemplate
     */
    zone_version?: number;
}
/**
 * 
 * @export
 * @interface ModelsAdventureTemplateEntry
 */
export interface ModelsAdventureTemplateEntry {
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureTemplateEntry
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureTemplateEntry
     */
    template_id?: number;
}
/**
 * 
 * @export
 * @interface ModelsAdventureTemplateEntryFlavor
 */
export interface ModelsAdventureTemplateEntryFlavor {
    /**
     * 
     * @type {number}
     * @memberof ModelsAdventureTemplateEntryFlavor
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsAdventureTemplateEntryFlavor
     */
    text?: string;
}
/**
 * 
 * @export
 * @interface ModelsAlternateCurrency
 */
export interface ModelsAlternateCurrency {
    /**
     * 
     * @type {number}
     * @memberof ModelsAlternateCurrency
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAlternateCurrency
     */
    item_id?: number;
}
/**
 * 
 * @export
 * @interface ModelsAura
 */
export interface ModelsAura {
    /**
     * 
     * @type {number}
     * @memberof ModelsAura
     */
    aura_type?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAura
     */
    cast_time?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAura
     */
    distance?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAura
     */
    duration?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAura
     */
    icon?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAura
     */
    movement?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsAura
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsAura
     */
    npc_type?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAura
     */
    spawn_type?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAura
     */
    spell_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsAura
     */
    type?: number;
}
/**
 * 
 * @export
 * @interface ModelsBlockedSpell
 */
export interface ModelsBlockedSpell {
    /**
     * 
     * @type {string}
     * @memberof ModelsBlockedSpell
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsBlockedSpell
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsBlockedSpell
     */
    message?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsBlockedSpell
     */
    spellid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsBlockedSpell
     */
    type?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsBlockedSpell
     */
    x?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsBlockedSpell
     */
    x_diff?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsBlockedSpell
     */
    y?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsBlockedSpell
     */
    y_diff?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsBlockedSpell
     */
    z?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsBlockedSpell
     */
    z_diff?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsBlockedSpell
     */
    zoneid?: number;
}
/**
 * 
 * @export
 * @interface ModelsBug
 */
export interface ModelsBug {
    /**
     * 
     * @type {string}
     * @memberof ModelsBug
     */
    bug?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsBug
     */
    date?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsBug
     */
    flag?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsBug
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsBug
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsBug
     */
    status?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsBug
     */
    target?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsBug
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsBug
     */
    ui?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsBug
     */
    x?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsBug
     */
    y?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsBug
     */
    z?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsBug
     */
    zone?: string;
}
/**
 * 
 * @export
 * @interface ModelsBugReport
 */
export interface ModelsBugReport {
    /**
     * 
     * @type {number}
     * @memberof ModelsBugReport
     */
    _can_duplicate?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsBugReport
     */
    _character_flags?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsBugReport
     */
    _crash_bug?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsBugReport
     */
    _target_info?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsBugReport
     */
    _unknown_value?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsBugReport
     */
    account_id?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsBugReport
     */
    bug_report?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsBugReport
     */
    bug_status?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsBugReport
     */
    category_id?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsBugReport
     */
    category_name?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsBugReport
     */
    character_id?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsBugReport
     */
    character_name?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsBugReport
     */
    client_version_id?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsBugReport
     */
    client_version_name?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsBugReport
     */
    heading?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsBugReport
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsBugReport
     */
    last_review?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsBugReport
     */
    last_reviewer?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsBugReport
     */
    optional_info_mask?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsBugReport
     */
    pos_x?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsBugReport
     */
    pos_y?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsBugReport
     */
    pos_z?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsBugReport
     */
    report_datetime?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsBugReport
     */
    reporter_name?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsBugReport
     */
    reporter_spoof?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsBugReport
     */
    reviewer_notes?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsBugReport
     */
    system_info?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsBugReport
     */
    target_id?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsBugReport
     */
    target_name?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsBugReport
     */
    time_played?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsBugReport
     */
    ui_path?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsBugReport
     */
    zone?: string;
}
/**
 * 
 * @export
 * @interface ModelsBuyer
 */
export interface ModelsBuyer {
    /**
     * 
     * @type {number}
     * @memberof ModelsBuyer
     */
    buyslot?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsBuyer
     */
    charid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsBuyer
     */
    itemid?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsBuyer
     */
    itemname?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsBuyer
     */
    price?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsBuyer
     */
    quantity?: number;
}
/**
 * 
 * @export
 * @interface ModelsCharCreatePointAllocation
 */
export interface ModelsCharCreatePointAllocation {
    /**
     * 
     * @type {number}
     * @memberof ModelsCharCreatePointAllocation
     */
    alloc_agi?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharCreatePointAllocation
     */
    alloc_cha?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharCreatePointAllocation
     */
    alloc_dex?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharCreatePointAllocation
     */
    alloc_int?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharCreatePointAllocation
     */
    alloc_sta?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharCreatePointAllocation
     */
    alloc_str?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharCreatePointAllocation
     */
    alloc_wis?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharCreatePointAllocation
     */
    base_agi?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharCreatePointAllocation
     */
    base_cha?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharCreatePointAllocation
     */
    base_dex?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharCreatePointAllocation
     */
    base_int?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharCreatePointAllocation
     */
    base_sta?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharCreatePointAllocation
     */
    base_str?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharCreatePointAllocation
     */
    base_wis?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharCreatePointAllocation
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface ModelsCharRecipeList
 */
export interface ModelsCharRecipeList {
    /**
     * 
     * @type {number}
     * @memberof ModelsCharRecipeList
     */
    char_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharRecipeList
     */
    madecount?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharRecipeList
     */
    recipe_id?: number;
}
/**
 * 
 * @export
 * @interface ModelsCharacterActivity
 */
export interface ModelsCharacterActivity {
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterActivity
     */
    activityid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterActivity
     */
    charid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterActivity
     */
    completed?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterActivity
     */
    donecount?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterActivity
     */
    taskid?: number;
}
/**
 * 
 * @export
 * @interface ModelsCharacterAltCurrency
 */
export interface ModelsCharacterAltCurrency {
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterAltCurrency
     */
    amount?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterAltCurrency
     */
    char_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterAltCurrency
     */
    currency_id?: number;
}
/**
 * 
 * @export
 * @interface ModelsCharacterAlternateAbility
 */
export interface ModelsCharacterAlternateAbility {
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterAlternateAbility
     */
    aa_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterAlternateAbility
     */
    aa_value?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterAlternateAbility
     */
    charges?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterAlternateAbility
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface ModelsCharacterAura
 */
export interface ModelsCharacterAura {
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterAura
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterAura
     */
    slot?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterAura
     */
    spell_id?: number;
}
/**
 * 
 * @export
 * @interface ModelsCharacterBandolier
 */
export interface ModelsCharacterBandolier {
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterBandolier
     */
    bandolier_id?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsCharacterBandolier
     */
    bandolier_name?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterBandolier
     */
    bandolier_slot?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterBandolier
     */
    icon?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterBandolier
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterBandolier
     */
    item_id?: number;
}
/**
 * 
 * @export
 * @interface ModelsCharacterBind
 */
export interface ModelsCharacterBind {
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterBind
     */
    heading?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterBind
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterBind
     */
    instance_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterBind
     */
    slot?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterBind
     */
    x?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterBind
     */
    y?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterBind
     */
    z?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterBind
     */
    zone_id?: number;
}
/**
 * 
 * @export
 * @interface ModelsCharacterBuff
 */
export interface ModelsCharacterBuff {
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterBuff
     */
    caster_level?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsCharacterBuff
     */
    caster_name?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterBuff
     */
    caston_x?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterBuff
     */
    caston_y?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterBuff
     */
    caston_z?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterBuff
     */
    character_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterBuff
     */
    counters?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterBuff
     */
    dot_rune?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterBuff
     */
    extra_di_chance?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterBuff
     */
    instrument_mod?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterBuff
     */
    magic_rune?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterBuff
     */
    melee_rune?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterBuff
     */
    numhits?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterBuff
     */
    persistent?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterBuff
     */
    slot_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterBuff
     */
    spell_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterBuff
     */
    ticsremaining?: number;
}
/**
 * 
 * @export
 * @interface ModelsCharacterCorpse
 */
export interface ModelsCharacterCorpse {
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    beard?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    beard_color?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    charid?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsCharacterCorpse
     */
    charname?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    _class?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    copper?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    deity?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    drakkin_details?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    drakkin_heritage?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    drakkin_tattoo?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    exp?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    eye_color_1?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    eye_color_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    face?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    gender?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    gold?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    guild_consent_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    hair_color?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    hair_style?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    heading?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    helm_texture?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    instance_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    is_buried?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    is_locked?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    is_rezzed?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    level?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    platinum?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    race?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    silver?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    size?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    texture?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsCharacterCorpse
     */
    time_of_death?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    was_at_graveyard?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    wc_1?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    wc_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    wc_3?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    wc_4?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    wc_5?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    wc_6?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    wc_7?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    wc_8?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    wc_9?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    x?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    y?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    z?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCorpse
     */
    zone_id?: number;
}
/**
 * 
 * @export
 * @interface ModelsCharacterCurrency
 */
export interface ModelsCharacterCurrency {
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCurrency
     */
    career_ebon_crystals?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCurrency
     */
    career_radiant_crystals?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCurrency
     */
    copper?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCurrency
     */
    copper_bank?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCurrency
     */
    copper_cursor?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCurrency
     */
    ebon_crystals?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCurrency
     */
    gold?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCurrency
     */
    gold_bank?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCurrency
     */
    gold_cursor?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCurrency
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCurrency
     */
    platinum?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCurrency
     */
    platinum_bank?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCurrency
     */
    platinum_cursor?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCurrency
     */
    radiant_crystals?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCurrency
     */
    silver?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCurrency
     */
    silver_bank?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterCurrency
     */
    silver_cursor?: number;
}
/**
 * 
 * @export
 * @interface ModelsCharacterDatum
 */
export interface ModelsCharacterDatum {
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    aa_exp?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    aa_points?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    aa_points_old?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    aa_points_spent?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    aa_points_spent_old?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    ability_number?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    ability_time_hours?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    ability_time_minutes?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    ability_time_seconds?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    ability_up?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    account_id?: number;
    /**
     * 
     * @type {Array<ModelsAdventureStat>}
     * @memberof ModelsCharacterDatum
     */
    adventure_stats?: Array<ModelsAdventureStat>;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    agi?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    air_remaining?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    anon?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    autosplit_enabled?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    beard?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    beard_color?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    birthday?: number;
    /**
     * 
     * @type {Array<ModelsBuyer>}
     * @memberof ModelsCharacterDatum
     */
    buyers?: Array<ModelsBuyer>;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    career_tribute_points?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    cha?: number;
    /**
     * 
     * @type {Array<ModelsCharRecipeList>}
     * @memberof ModelsCharacterDatum
     */
    char_recipe_lists?: Array<ModelsCharRecipeList>;
    /**
     * 
     * @type {Array<ModelsCharacterActivity>}
     * @memberof ModelsCharacterDatum
     */
    character_activities?: Array<ModelsCharacterActivity>;
    /**
     * 
     * @type {Array<ModelsCharacterAltCurrency>}
     * @memberof ModelsCharacterDatum
     */
    character_alt_currencies?: Array<ModelsCharacterAltCurrency>;
    /**
     * 
     * @type {Array<ModelsCharacterAlternateAbility>}
     * @memberof ModelsCharacterDatum
     */
    character_alternate_abilities?: Array<ModelsCharacterAlternateAbility>;
    /**
     * 
     * @type {Array<ModelsCharacterAura>}
     * @memberof ModelsCharacterDatum
     */
    character_auras?: Array<ModelsCharacterAura>;
    /**
     * 
     * @type {Array<ModelsCharacterBandolier>}
     * @memberof ModelsCharacterDatum
     */
    character_bandoliers?: Array<ModelsCharacterBandolier>;
    /**
     * 
     * @type {Array<ModelsCharacterBind>}
     * @memberof ModelsCharacterDatum
     */
    character_binds?: Array<ModelsCharacterBind>;
    /**
     * 
     * @type {Array<ModelsCharacterBuff>}
     * @memberof ModelsCharacterDatum
     */
    character_buffs?: Array<ModelsCharacterBuff>;
    /**
     * 
     * @type {Array<ModelsCharacterCorpse>}
     * @memberof ModelsCharacterDatum
     */
    character_corpses?: Array<ModelsCharacterCorpse>;
    /**
     * 
     * @type {Array<ModelsCharacterCurrency>}
     * @memberof ModelsCharacterDatum
     */
    character_currencies?: Array<ModelsCharacterCurrency>;
    /**
     * 
     * @type {Array<ModelsCharacterDiscipline>}
     * @memberof ModelsCharacterDatum
     */
    character_disciplines?: Array<ModelsCharacterDiscipline>;
    /**
     * 
     * @type {Array<ModelsCharacterEnabledtask>}
     * @memberof ModelsCharacterDatum
     */
    character_enabledtasks?: Array<ModelsCharacterEnabledtask>;
    /**
     * 
     * @type {Array<ModelsCharacterInspectMessage>}
     * @memberof ModelsCharacterDatum
     */
    character_inspect_messages?: Array<ModelsCharacterInspectMessage>;
    /**
     * 
     * @type {Array<ModelsCharacterItemRecast>}
     * @memberof ModelsCharacterDatum
     */
    character_item_recasts?: Array<ModelsCharacterItemRecast>;
    /**
     * 
     * @type {Array<ModelsCharacterLanguage>}
     * @memberof ModelsCharacterDatum
     */
    character_languages?: Array<ModelsCharacterLanguage>;
    /**
     * 
     * @type {Array<ModelsCharacterLeadershipAbility>}
     * @memberof ModelsCharacterDatum
     */
    character_leadership_abilities?: Array<ModelsCharacterLeadershipAbility>;
    /**
     * 
     * @type {Array<ModelsCharacterMaterial>}
     * @memberof ModelsCharacterDatum
     */
    character_materials?: Array<ModelsCharacterMaterial>;
    /**
     * 
     * @type {Array<ModelsCharacterMemmedSpell>}
     * @memberof ModelsCharacterDatum
     */
    character_memmed_spells?: Array<ModelsCharacterMemmedSpell>;
    /**
     * 
     * @type {Array<ModelsCharacterPetBuff>}
     * @memberof ModelsCharacterDatum
     */
    character_pet_buffs?: Array<ModelsCharacterPetBuff>;
    /**
     * 
     * @type {Array<ModelsCharacterPetInfo>}
     * @memberof ModelsCharacterDatum
     */
    character_pet_infos?: Array<ModelsCharacterPetInfo>;
    /**
     * 
     * @type {Array<ModelsCharacterPetInventory>}
     * @memberof ModelsCharacterDatum
     */
    character_pet_inventories?: Array<ModelsCharacterPetInventory>;
    /**
     * 
     * @type {Array<ModelsCharacterPotionbelt>}
     * @memberof ModelsCharacterDatum
     */
    character_potionbelts?: Array<ModelsCharacterPotionbelt>;
    /**
     * 
     * @type {Array<ModelsCharacterSkill>}
     * @memberof ModelsCharacterDatum
     */
    character_skills?: Array<ModelsCharacterSkill>;
    /**
     * 
     * @type {Array<ModelsCharacterSpell>}
     * @memberof ModelsCharacterDatum
     */
    character_spells?: Array<ModelsCharacterSpell>;
    /**
     * 
     * @type {Array<ModelsCharacterTask>}
     * @memberof ModelsCharacterDatum
     */
    character_tasks?: Array<ModelsCharacterTask>;
    /**
     * 
     * @type {Array<ModelsCharacterTribute>}
     * @memberof ModelsCharacterDatum
     */
    character_tributes?: Array<ModelsCharacterTribute>;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    _class?: number;
    /**
     * 
     * @type {Array<ModelsCompletedTask>}
     * @memberof ModelsCharacterDatum
     */
    completed_tasks?: Array<ModelsCompletedTask>;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    cur_hp?: number;
    /**
     * 
     * @type {Array<ModelsDataBucket>}
     * @memberof ModelsCharacterDatum
     */
    data_buckets?: Array<ModelsDataBucket>;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    deity?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsCharacterDatum
     */
    deleted_at?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    dex?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    drakkin_details?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    drakkin_heritage?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    drakkin_tattoo?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    e_aa_effects?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    e_expended_aa_spent?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    e_last_invsnapshot?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    e_percent_to_aa?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    endurance?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    exp?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    eye_color_1?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    eye_color_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    face?: number;
    /**
     * 
     * @type {Array<ModelsFactionValue>}
     * @memberof ModelsCharacterDatum
     */
    faction_values?: Array<ModelsFactionValue>;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    firstlogon?: number;
    /**
     * 
     * @type {Array<ModelsFriend>}
     * @memberof ModelsCharacterDatum
     */
    friends?: Array<ModelsFriend>;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    gender?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    gm?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    group_auto_consent?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    group_leadership_exp?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    group_leadership_points?: number;
    /**
     * 
     * @type {ModelsGuild}
     * @memberof ModelsCharacterDatum
     */
    guild?: ModelsGuild;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    guild_auto_consent?: number;
    /**
     * 
     * @type {Array<ModelsGuildMember>}
     * @memberof ModelsCharacterDatum
     */
    guild_members?: Array<ModelsGuildMember>;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    hair_color?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    hair_style?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    heading?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    hunger_level?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    id?: number;
    /**
     * 
     * @type {Array<ModelsInstanceListPlayer>}
     * @memberof ModelsCharacterDatum
     */
    instance_list_players?: Array<ModelsInstanceListPlayer>;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    _int?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    intoxication?: number;
    /**
     * 
     * @type {Array<ModelsInventory>}
     * @memberof ModelsCharacterDatum
     */
    inventories?: Array<ModelsInventory>;
    /**
     * 
     * @type {Array<ModelsKeyring>}
     * @memberof ModelsCharacterDatum
     */
    keyrings?: Array<ModelsKeyring>;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    last_login?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsCharacterDatum
     */
    last_name?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    ldon_points_available?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    ldon_points_guk?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    ldon_points_mir?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    ldon_points_mmc?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    ldon_points_ruj?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    ldon_points_tak?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    leadership_exp_on?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    level?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    level_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    lfg?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    lfp?: number;
    /**
     * 
     * @type {Array<ModelsMail>}
     * @memberof ModelsCharacterDatum
     */
    mail?: Array<ModelsMail>;
    /**
     * 
     * @type {string}
     * @memberof ModelsCharacterDatum
     */
    mailkey?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    mana?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsCharacterDatum
     */
    name?: string;
    /**
     * 
     * @type {Array<ModelsPlayerTitleset>}
     * @memberof ModelsCharacterDatum
     */
    player_titlesets?: Array<ModelsPlayerTitleset>;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    points?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    pvp_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    pvp_best_kill_streak?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    pvp_career_points?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    pvp_current_kill_streak?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    pvp_current_points?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    pvp_deaths?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    pvp_kills?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    pvp_status?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    pvp_type?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    pvp_worst_death_streak?: number;
    /**
     * 
     * @type {Array<ModelsQuestGlobal>}
     * @memberof ModelsCharacterDatum
     */
    quest_globals?: Array<ModelsQuestGlobal>;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    race?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    raid_auto_consent?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    raid_leadership_exp?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    raid_leadership_points?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    rest_timer?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    show_helm?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    sta?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    str?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsCharacterDatum
     */
    suffix?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    thirst_level?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    time_played?: number;
    /**
     * 
     * @type {Array<ModelsTimer>}
     * @memberof ModelsCharacterDatum
     */
    timers?: Array<ModelsTimer>;
    /**
     * 
     * @type {string}
     * @memberof ModelsCharacterDatum
     */
    title?: string;
    /**
     * 
     * @type {Array<ModelsTitle>}
     * @memberof ModelsCharacterDatum
     */
    titles?: Array<ModelsTitle>;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    toxicity?: number;
    /**
     * 
     * @type {Array<ModelsTrader>}
     * @memberof ModelsCharacterDatum
     */
    traders?: Array<ModelsTrader>;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    tribute_active?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    tribute_points?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    tribute_time_remaining?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    wis?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    x?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    xtargets?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    y?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    z?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    zone_change_count?: number;
    /**
     * 
     * @type {Array<ModelsZoneFlag>}
     * @memberof ModelsCharacterDatum
     */
    zone_flags?: Array<ModelsZoneFlag>;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    zone_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDatum
     */
    zone_instance?: number;
}
/**
 * 
 * @export
 * @interface ModelsCharacterDiscipline
 */
export interface ModelsCharacterDiscipline {
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDiscipline
     */
    disc_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDiscipline
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterDiscipline
     */
    slot_id?: number;
}
/**
 * 
 * @export
 * @interface ModelsCharacterEnabledtask
 */
export interface ModelsCharacterEnabledtask {
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterEnabledtask
     */
    charid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterEnabledtask
     */
    taskid?: number;
}
/**
 * 
 * @export
 * @interface ModelsCharacterInspectMessage
 */
export interface ModelsCharacterInspectMessage {
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterInspectMessage
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsCharacterInspectMessage
     */
    inspect_message?: string;
}
/**
 * 
 * @export
 * @interface ModelsCharacterItemRecast
 */
export interface ModelsCharacterItemRecast {
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterItemRecast
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterItemRecast
     */
    recast_type?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterItemRecast
     */
    timestamp?: number;
}
/**
 * 
 * @export
 * @interface ModelsCharacterLanguage
 */
export interface ModelsCharacterLanguage {
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterLanguage
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterLanguage
     */
    lang_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterLanguage
     */
    value?: number;
}
/**
 * 
 * @export
 * @interface ModelsCharacterLeadershipAbility
 */
export interface ModelsCharacterLeadershipAbility {
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterLeadershipAbility
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterLeadershipAbility
     */
    rank?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterLeadershipAbility
     */
    slot?: number;
}
/**
 * 
 * @export
 * @interface ModelsCharacterMaterial
 */
export interface ModelsCharacterMaterial {
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterMaterial
     */
    blue?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterMaterial
     */
    color?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterMaterial
     */
    green?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterMaterial
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterMaterial
     */
    red?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterMaterial
     */
    slot?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterMaterial
     */
    use_tint?: number;
}
/**
 * 
 * @export
 * @interface ModelsCharacterMemmedSpell
 */
export interface ModelsCharacterMemmedSpell {
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterMemmedSpell
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterMemmedSpell
     */
    slot_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterMemmedSpell
     */
    spell_id?: number;
}
/**
 * 
 * @export
 * @interface ModelsCharacterPetBuff
 */
export interface ModelsCharacterPetBuff {
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterPetBuff
     */
    caster_level?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsCharacterPetBuff
     */
    castername?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterPetBuff
     */
    char_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterPetBuff
     */
    counters?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterPetBuff
     */
    instrument_mod?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterPetBuff
     */
    numhits?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterPetBuff
     */
    pet?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterPetBuff
     */
    rune?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterPetBuff
     */
    slot?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterPetBuff
     */
    spell_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterPetBuff
     */
    ticsremaining?: number;
}
/**
 * 
 * @export
 * @interface ModelsCharacterPetInfo
 */
export interface ModelsCharacterPetInfo {
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterPetInfo
     */
    char_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterPetInfo
     */
    hp?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterPetInfo
     */
    mana?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterPetInfo
     */
    pet?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsCharacterPetInfo
     */
    petname?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterPetInfo
     */
    petpower?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterPetInfo
     */
    size?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterPetInfo
     */
    spell_id?: number;
}
/**
 * 
 * @export
 * @interface ModelsCharacterPetInventory
 */
export interface ModelsCharacterPetInventory {
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterPetInventory
     */
    char_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterPetInventory
     */
    item_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterPetInventory
     */
    pet?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterPetInventory
     */
    slot?: number;
}
/**
 * 
 * @export
 * @interface ModelsCharacterPotionbelt
 */
export interface ModelsCharacterPotionbelt {
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterPotionbelt
     */
    icon?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterPotionbelt
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterPotionbelt
     */
    item_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterPotionbelt
     */
    potion_id?: number;
}
/**
 * 
 * @export
 * @interface ModelsCharacterSkill
 */
export interface ModelsCharacterSkill {
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterSkill
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterSkill
     */
    skill_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterSkill
     */
    value?: number;
}
/**
 * 
 * @export
 * @interface ModelsCharacterSpell
 */
export interface ModelsCharacterSpell {
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterSpell
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterSpell
     */
    slot_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterSpell
     */
    spell_id?: number;
}
/**
 * 
 * @export
 * @interface ModelsCharacterTask
 */
export interface ModelsCharacterTask {
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterTask
     */
    acceptedtime?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterTask
     */
    charid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterTask
     */
    slot?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterTask
     */
    taskid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterTask
     */
    type?: number;
}
/**
 * 
 * @export
 * @interface ModelsCharacterTribute
 */
export interface ModelsCharacterTribute {
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterTribute
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterTribute
     */
    tier?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCharacterTribute
     */
    tribute?: number;
}
/**
 * 
 * @export
 * @interface ModelsCompletedTask
 */
export interface ModelsCompletedTask {
    /**
     * 
     * @type {number}
     * @memberof ModelsCompletedTask
     */
    activityid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCompletedTask
     */
    charid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCompletedTask
     */
    completedtime?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsCompletedTask
     */
    taskid?: number;
}
/**
 * 
 * @export
 * @interface ModelsContentFlag
 */
export interface ModelsContentFlag {
    /**
     * 
     * @type {number}
     * @memberof ModelsContentFlag
     */
    enabled?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsContentFlag
     */
    flag_name?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsContentFlag
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsContentFlag
     */
    notes?: string;
}
/**
 * 
 * @export
 * @interface ModelsDamageshieldtype
 */
export interface ModelsDamageshieldtype {
    /**
     * 
     * @type {number}
     * @memberof ModelsDamageshieldtype
     */
    spellid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsDamageshieldtype
     */
    type?: number;
}
/**
 * 
 * @export
 * @interface ModelsDataBucket
 */
export interface ModelsDataBucket {
    /**
     * 
     * @type {number}
     * @memberof ModelsDataBucket
     */
    expires?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsDataBucket
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsDataBucket
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsDataBucket
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface ModelsDbStr
 */
export interface ModelsDbStr {
    /**
     * 
     * @type {number}
     * @memberof ModelsDbStr
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsDbStr
     */
    type?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsDbStr
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface ModelsDiscoveredItem
 */
export interface ModelsDiscoveredItem {
    /**
     * 
     * @type {number}
     * @memberof ModelsDiscoveredItem
     */
    account_status?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsDiscoveredItem
     */
    char_name?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsDiscoveredItem
     */
    discovered_date?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsDiscoveredItem
     */
    item_id?: number;
}
/**
 * 
 * @export
 * @interface ModelsDoor
 */
export interface ModelsDoor {
    /**
     * 
     * @type {number}
     * @memberof ModelsDoor
     */
    buffer?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsDoor
     */
    client_version_mask?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsDoor
     */
    content_flags?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsDoor
     */
    content_flags_disabled?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsDoor
     */
    dest_heading?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsDoor
     */
    dest_instance?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsDoor
     */
    dest_x?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsDoor
     */
    dest_y?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsDoor
     */
    dest_z?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsDoor
     */
    dest_zone?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsDoor
     */
    disable_timer?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsDoor
     */
    door_param?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsDoor
     */
    doorid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsDoor
     */
    doorisopen?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsDoor
     */
    guild?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsDoor
     */
    heading?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsDoor
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsDoor
     */
    incline?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsDoor
     */
    invert_state?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsDoor
     */
    is_ldon_door?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsDoor
     */
    keyitem?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsDoor
     */
    lockpick?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsDoor
     */
    max_expansion?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsDoor
     */
    min_expansion?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsDoor
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsDoor
     */
    nokeyring?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsDoor
     */
    opentype?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsDoor
     */
    pos_x?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsDoor
     */
    pos_y?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsDoor
     */
    pos_z?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsDoor
     */
    size?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsDoor
     */
    triggerdoor?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsDoor
     */
    triggertype?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsDoor
     */
    version?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsDoor
     */
    zone?: string;
}
/**
 * 
 * @export
 * @interface ModelsEventlog
 */
export interface ModelsEventlog {
    /**
     * 
     * @type {number}
     * @memberof ModelsEventlog
     */
    accountid?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsEventlog
     */
    accountname?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsEventlog
     */
    charname?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsEventlog
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsEventlog
     */
    descriptiontype?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsEventlog
     */
    event_nid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsEventlog
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsEventlog
     */
    status?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsEventlog
     */
    target?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsEventlog
     */
    time?: string;
}
/**
 * 
 * @export
 * @interface ModelsFactionBaseDatum
 */
export interface ModelsFactionBaseDatum {
    /**
     * 
     * @type {number}
     * @memberof ModelsFactionBaseDatum
     */
    client_faction_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsFactionBaseDatum
     */
    max?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsFactionBaseDatum
     */
    min?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsFactionBaseDatum
     */
    unk_hero_1?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsFactionBaseDatum
     */
    unk_hero_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsFactionBaseDatum
     */
    unk_hero_3?: number;
}
/**
 * 
 * @export
 * @interface ModelsFactionList
 */
export interface ModelsFactionList {
    /**
     * 
     * @type {number}
     * @memberof ModelsFactionList
     */
    base?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsFactionList
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsFactionList
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface ModelsFactionListMod
 */
export interface ModelsFactionListMod {
    /**
     * 
     * @type {number}
     * @memberof ModelsFactionListMod
     */
    faction_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsFactionListMod
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsFactionListMod
     */
    mod?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsFactionListMod
     */
    mod_name?: string;
}
/**
 * 
 * @export
 * @interface ModelsFactionValue
 */
export interface ModelsFactionValue {
    /**
     * 
     * @type {number}
     * @memberof ModelsFactionValue
     */
    char_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsFactionValue
     */
    current_value?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsFactionValue
     */
    faction_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsFactionValue
     */
    temp?: number;
}
/**
 * 
 * @export
 * @interface ModelsFishing
 */
export interface ModelsFishing {
    /**
     * 
     * @type {number}
     * @memberof ModelsFishing
     */
    chance?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsFishing
     */
    content_flags?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsFishing
     */
    content_flags_disabled?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsFishing
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsFishing
     */
    itemid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsFishing
     */
    max_expansion?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsFishing
     */
    min_expansion?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsFishing
     */
    npc_chance?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsFishing
     */
    npc_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsFishing
     */
    skill_level?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsFishing
     */
    zoneid?: number;
}
/**
 * 
 * @export
 * @interface ModelsForage
 */
export interface ModelsForage {
    /**
     * 
     * @type {number}
     * @memberof ModelsForage
     */
    chance?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsForage
     */
    content_flags?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsForage
     */
    content_flags_disabled?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsForage
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsForage
     */
    itemid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsForage
     */
    level?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsForage
     */
    max_expansion?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsForage
     */
    min_expansion?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsForage
     */
    zoneid?: number;
}
/**
 * 
 * @export
 * @interface ModelsFriend
 */
export interface ModelsFriend {
    /**
     * 
     * @type {number}
     * @memberof ModelsFriend
     */
    charid?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsFriend
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsFriend
     */
    type?: number;
}
/**
 * 
 * @export
 * @interface ModelsGlobalLoot
 */
export interface ModelsGlobalLoot {
    /**
     * 
     * @type {string}
     * @memberof ModelsGlobalLoot
     */
    bodytype?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsGlobalLoot
     */
    _class?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsGlobalLoot
     */
    content_flags?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsGlobalLoot
     */
    content_flags_disabled?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsGlobalLoot
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsGlobalLoot
     */
    enabled?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGlobalLoot
     */
    hot_zone?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGlobalLoot
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGlobalLoot
     */
    loottable_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGlobalLoot
     */
    max_expansion?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGlobalLoot
     */
    max_level?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGlobalLoot
     */
    min_expansion?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGlobalLoot
     */
    min_level?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsGlobalLoot
     */
    race?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsGlobalLoot
     */
    raid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGlobalLoot
     */
    rare?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsGlobalLoot
     */
    zone?: string;
}
/**
 * 
 * @export
 * @interface ModelsGoallist
 */
export interface ModelsGoallist {
    /**
     * 
     * @type {number}
     * @memberof ModelsGoallist
     */
    entry?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGoallist
     */
    listid?: number;
}
/**
 * 
 * @export
 * @interface ModelsGraveyard
 */
export interface ModelsGraveyard {
    /**
     * 
     * @type {number}
     * @memberof ModelsGraveyard
     */
    heading?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGraveyard
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGraveyard
     */
    x?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGraveyard
     */
    y?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGraveyard
     */
    z?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGraveyard
     */
    zone_id?: number;
}
/**
 * 
 * @export
 * @interface ModelsGrid
 */
export interface ModelsGrid {
    /**
     * 
     * @type {Array<ModelsGridEntry>}
     * @memberof ModelsGrid
     */
    grid_entries?: Array<ModelsGridEntry>;
    /**
     * 
     * @type {number}
     * @memberof ModelsGrid
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGrid
     */
    type?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGrid
     */
    type_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGrid
     */
    zoneid?: number;
}
/**
 * 
 * @export
 * @interface ModelsGridEntry
 */
export interface ModelsGridEntry {
    /**
     * 
     * @type {number}
     * @memberof ModelsGridEntry
     */
    centerpoint?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGridEntry
     */
    gridid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGridEntry
     */
    heading?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGridEntry
     */
    number?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGridEntry
     */
    pause?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGridEntry
     */
    x?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGridEntry
     */
    y?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGridEntry
     */
    z?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGridEntry
     */
    zoneid?: number;
}
/**
 * 
 * @export
 * @interface ModelsGroundSpawn
 */
export interface ModelsGroundSpawn {
    /**
     * 
     * @type {string}
     * @memberof ModelsGroundSpawn
     */
    comment?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsGroundSpawn
     */
    content_flags?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsGroundSpawn
     */
    content_flags_disabled?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsGroundSpawn
     */
    heading?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGroundSpawn
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGroundSpawn
     */
    item?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGroundSpawn
     */
    max_allowed?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGroundSpawn
     */
    max_expansion?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGroundSpawn
     */
    max_x?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGroundSpawn
     */
    max_y?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGroundSpawn
     */
    max_z?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGroundSpawn
     */
    min_expansion?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGroundSpawn
     */
    min_x?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGroundSpawn
     */
    min_y?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsGroundSpawn
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsGroundSpawn
     */
    respawn_timer?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGroundSpawn
     */
    version?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGroundSpawn
     */
    zoneid?: number;
}
/**
 * 
 * @export
 * @interface ModelsGroupId
 */
export interface ModelsGroupId {
    /**
     * 
     * @type {number}
     * @memberof ModelsGroupId
     */
    charid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGroupId
     */
    groupid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGroupId
     */
    ismerc?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsGroupId
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface ModelsGuild
 */
export interface ModelsGuild {
    /**
     * 
     * @type {string}
     * @memberof ModelsGuild
     */
    channel?: string;
    /**
     * 
     * @type {Array<ModelsGuildBank>}
     * @memberof ModelsGuild
     */
    guild_banks?: Array<ModelsGuildBank>;
    /**
     * 
     * @type {Array<ModelsGuildMember>}
     * @memberof ModelsGuild
     */
    guild_members?: Array<ModelsGuildMember>;
    /**
     * 
     * @type {Array<ModelsGuildRank>}
     * @memberof ModelsGuild
     */
    guild_ranks?: Array<ModelsGuildRank>;
    /**
     * 
     * @type {number}
     * @memberof ModelsGuild
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGuild
     */
    leader?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGuild
     */
    minstatus?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsGuild
     */
    motd?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsGuild
     */
    motd_setter?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsGuild
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsGuild
     */
    tribute?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsGuild
     */
    url?: string;
}
/**
 * 
 * @export
 * @interface ModelsGuildBank
 */
export interface ModelsGuildBank {
    /**
     * 
     * @type {number}
     * @memberof ModelsGuildBank
     */
    area?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsGuildBank
     */
    donator?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsGuildBank
     */
    guildid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGuildBank
     */
    itemid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGuildBank
     */
    permissions?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGuildBank
     */
    qty?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGuildBank
     */
    slot?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsGuildBank
     */
    whofor?: string;
}
/**
 * 
 * @export
 * @interface ModelsGuildMember
 */
export interface ModelsGuildMember {
    /**
     * 
     * @type {number}
     * @memberof ModelsGuildMember
     */
    alt?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGuildMember
     */
    banker?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGuildMember
     */
    char_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGuildMember
     */
    guild_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGuildMember
     */
    last_tribute?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsGuildMember
     */
    public_note?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsGuildMember
     */
    rank?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGuildMember
     */
    total_tribute?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGuildMember
     */
    tribute_enable?: number;
}
/**
 * 
 * @export
 * @interface ModelsGuildRank
 */
export interface ModelsGuildRank {
    /**
     * 
     * @type {number}
     * @memberof ModelsGuildRank
     */
    can_demote?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGuildRank
     */
    can_hear?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGuildRank
     */
    can_invite?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGuildRank
     */
    can_motd?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGuildRank
     */
    can_promote?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGuildRank
     */
    can_remove?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGuildRank
     */
    can_speak?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGuildRank
     */
    can_warpeace?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGuildRank
     */
    guild_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsGuildRank
     */
    rank?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsGuildRank
     */
    title?: string;
}
/**
 * 
 * @export
 * @interface ModelsHacker
 */
export interface ModelsHacker {
    /**
     * 
     * @type {string}
     * @memberof ModelsHacker
     */
    account?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsHacker
     */
    date?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsHacker
     */
    hacked?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsHacker
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsHacker
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsHacker
     */
    zone?: string;
}
/**
 * 
 * @export
 * @interface ModelsInstanceList
 */
export interface ModelsInstanceList {
    /**
     * 
     * @type {number}
     * @memberof ModelsInstanceList
     */
    duration?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsInstanceList
     */
    id?: number;
    /**
     * 
     * @type {Array<ModelsInstanceListPlayer>}
     * @memberof ModelsInstanceList
     */
    instance_list_players?: Array<ModelsInstanceListPlayer>;
    /**
     * 
     * @type {number}
     * @memberof ModelsInstanceList
     */
    is_global?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsInstanceList
     */
    never_expires?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsInstanceList
     */
    start_time?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsInstanceList
     */
    version?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsInstanceList
     */
    zone?: number;
    /**
     * 
     * @type {Array<ModelsZone>}
     * @memberof ModelsInstanceList
     */
    zones?: Array<ModelsZone>;
}
/**
 * 
 * @export
 * @interface ModelsInstanceListPlayer
 */
export interface ModelsInstanceListPlayer {
    /**
     * 
     * @type {number}
     * @memberof ModelsInstanceListPlayer
     */
    charid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsInstanceListPlayer
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface ModelsInventory
 */
export interface ModelsInventory {
    /**
     * 
     * @type {number}
     * @memberof ModelsInventory
     */
    augslot_1?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsInventory
     */
    augslot_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsInventory
     */
    augslot_3?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsInventory
     */
    augslot_4?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsInventory
     */
    augslot_5?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsInventory
     */
    augslot_6?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsInventory
     */
    charges?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsInventory
     */
    charid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsInventory
     */
    color?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsInventory
     */
    custom_data?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsInventory
     */
    instnodrop?: number;
    /**
     * 
     * @type {ModelsItem}
     * @memberof ModelsInventory
     */
    item?: ModelsItem;
    /**
     * 
     * @type {number}
     * @memberof ModelsInventory
     */
    itemid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsInventory
     */
    ornament_hero_model?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsInventory
     */
    ornamenticon?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsInventory
     */
    ornamentidfile?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsInventory
     */
    slotid?: number;
}
/**
 * 
 * @export
 * @interface ModelsIpExemption
 */
export interface ModelsIpExemption {
    /**
     * 
     * @type {number}
     * @memberof ModelsIpExemption
     */
    exemption_amount?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsIpExemption
     */
    exemption_id?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsIpExemption
     */
    exemption_ip?: string;
}
/**
 * 
 * @export
 * @interface ModelsItem
 */
export interface ModelsItem {
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    aagi?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    ac?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    accuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    acha?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    adex?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    aint?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    artifactflag?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    asta?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    astr?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    attack?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    attuneable?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    augdistiller?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    augrestrict?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    augslot_1_type?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    augslot_1_unk_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    augslot_1_visible?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    augslot_2_type?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    augslot_2_unk_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    augslot_2_visible?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    augslot_3_type?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    augslot_3_unk_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    augslot_3_visible?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    augslot_4_type?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    augslot_4_unk_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    augslot_4_visible?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    augslot_5_type?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    augslot_5_unk_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    augslot_5_visible?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    augslot_6_type?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    augslot_6_unk_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    augslot_6_visible?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    augtype?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    avoidance?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    awis?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    backstabdmg?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    bagsize?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    bagslots?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    bagtype?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    bagwr?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    banedmgamt?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    banedmgbody?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    banedmgrace?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    banedmgraceamt?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    bardeffect?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    bardeffecttype?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    bardlevel?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    bardlevel_2?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsItem
     */
    bardname?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    bardtype?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    bardunk_1?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    bardunk_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    bardunk_3?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    bardunk_4?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    bardunk_5?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    bardunk_7?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    bardvalue?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    benefitflag?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    book?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    booktype?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    casttime?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    casttime_?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsItem
     */
    charmfile?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsItem
     */
    charmfileid?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    clairvoyance?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    classes?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    clickeffect?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    clicklevel?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    clicklevel_2?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsItem
     */
    clickname?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    clicktype?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    clickunk_5?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsItem
     */
    clickunk_6?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    clickunk_7?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    color?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsItem
     */
    combateffects?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsItem
     */
    comment?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    cr?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsItem
     */
    created?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    damage?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    damageshield?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    deity?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    delay?: number;
    /**
     * 
     * @type {Array<ModelsDiscoveredItem>}
     * @memberof ModelsItem
     */
    discovered_items?: Array<ModelsDiscoveredItem>;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    dotshielding?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    dr?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    dsmitigation?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    elemdmgamt?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    elemdmgtype?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    elitematerial?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    endur?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    enduranceregen?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    epicitem?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    evoid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    evoitem?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    evolvinglevel?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    evomax?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    expendablearrow?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    extradmgamt?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    extradmgskill?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    factionamt_1?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    factionamt_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    factionamt_3?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    factionamt_4?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    factionmod_1?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    factionmod_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    factionmod_3?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    factionmod_4?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    favor?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsItem
     */
    filename?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    focuseffect?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    focuslevel?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    focuslevel_2?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsItem
     */
    focusname?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    focustype?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    focusunk_1?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    focusunk_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    focusunk_3?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    focusunk_4?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    focusunk_5?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsItem
     */
    focusunk_6?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    focusunk_7?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    fr?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    fvnodrop?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    guildfavor?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    haste?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    healamt?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    heirloom?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    heroic_agi?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    heroic_cha?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    heroic_cr?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    heroic_dex?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    heroic_dr?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    heroic_fr?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    heroic_int?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    heroic_mr?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    heroic_pr?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    heroic_sta?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    heroic_str?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    heroic_svcorrup?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    heroic_wis?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    herosforgemodel?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    hp?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    icon?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsItem
     */
    idfile?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    itemclass?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    itemtype?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    ldonprice?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    ldonsellbackrate?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    ldonsold?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    ldontheme?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    light?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsItem
     */
    lore?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsItem
     */
    lorefile?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    loregroup?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    magic?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    mana?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    manaregen?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    material?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    maxcharges?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    minstatus?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    mr?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsItem
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    nodrop?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    nopet?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    norent?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    notransfer?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    pendingloreflag?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    placeable?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    pointtype?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    potionbelt?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    potionbeltslots?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    powersourcecapacity?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    pr?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    price?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    proceffect?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    proclevel?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    proclevel_2?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsItem
     */
    procname?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    procrate?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    proctype?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    procunk_1?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    procunk_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    procunk_3?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    procunk_4?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsItem
     */
    procunk_6?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    procunk_7?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    purity?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    questitemflag?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    races?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    range?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    recastdelay?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    recasttype?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    reclevel?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    recskill?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    regen?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    reqlevel?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    scriptfileid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    scrolleffect?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    scrolllevel?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    scrolllevel_2?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsItem
     */
    scrollname?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    scrolltype?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    scrollunk_1?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    scrollunk_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    scrollunk_3?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    scrollunk_4?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    scrollunk_5?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsItem
     */
    scrollunk_6?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    scrollunk_7?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    sellrate?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsItem
     */
    serialization?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsItem
     */
    serialized?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    shielding?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    size?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    skillmodmax?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    skillmodtype?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    skillmodvalue?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    slots?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsItem
     */
    source?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    spelldmg?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    spellshield?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    stackable?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    stacksize?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    strikethrough?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    stunresist?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    subtype?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    summonedflag?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    svcorruption?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    tradeskills?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    unk_012?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    unk_013?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    unk_014?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    unk_033?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    unk_054?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    unk_059?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    unk_060?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    unk_120?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    unk_121?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    unk_123?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    unk_124?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    unk_127?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsItem
     */
    unk_132?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsItem
     */
    unk_134?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    unk_137?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    unk_142?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    unk_147?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    unk_152?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    unk_157?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    unk_193?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    unk_214?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    unk_220?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    unk_221?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    unk_223?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    unk_224?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    unk_225?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    unk_226?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    unk_227?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    unk_228?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    unk_229?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    unk_230?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    unk_231?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    unk_232?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    unk_233?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    unk_234?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    unk_236?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    unk_237?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    unk_238?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    unk_239?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    unk_240?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    unk_241?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsItem
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsItem
     */
    verified?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    weight?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    worneffect?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    wornlevel?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    wornlevel_2?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsItem
     */
    wornname?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    worntype?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    wornunk_1?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    wornunk_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    wornunk_3?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    wornunk_4?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    wornunk_5?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsItem
     */
    wornunk_6?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsItem
     */
    wornunk_7?: number;
}
/**
 * 
 * @export
 * @interface ModelsKeyring
 */
export interface ModelsKeyring {
    /**
     * 
     * @type {number}
     * @memberof ModelsKeyring
     */
    char_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsKeyring
     */
    item_id?: number;
}
/**
 * 
 * @export
 * @interface ModelsLdonTrapEntry
 */
export interface ModelsLdonTrapEntry {
    /**
     * 
     * @type {number}
     * @memberof ModelsLdonTrapEntry
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsLdonTrapEntry
     */
    trap_id?: number;
}
/**
 * 
 * @export
 * @interface ModelsLdonTrapTemplate
 */
export interface ModelsLdonTrapTemplate {
    /**
     * 
     * @type {number}
     * @memberof ModelsLdonTrapTemplate
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsLdonTrapTemplate
     */
    locked?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsLdonTrapTemplate
     */
    skill?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsLdonTrapTemplate
     */
    spell_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsLdonTrapTemplate
     */
    type?: number;
}
/**
 * 
 * @export
 * @interface ModelsLevelExpMod
 */
export interface ModelsLevelExpMod {
    /**
     * 
     * @type {number}
     * @memberof ModelsLevelExpMod
     */
    aa_exp_mod?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsLevelExpMod
     */
    exp_mod?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsLevelExpMod
     */
    level?: number;
}
/**
 * 
 * @export
 * @interface ModelsLoginAccount
 */
export interface ModelsLoginAccount {
    /**
     * 
     * @type {string}
     * @memberof ModelsLoginAccount
     */
    account_email?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsLoginAccount
     */
    account_name?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsLoginAccount
     */
    account_password?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsLoginAccount
     */
    created_at?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsLoginAccount
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsLoginAccount
     */
    last_ip_address?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsLoginAccount
     */
    last_login_date?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsLoginAccount
     */
    source_loginserver?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsLoginAccount
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface ModelsLoginApiToken
 */
export interface ModelsLoginApiToken {
    /**
     * 
     * @type {number}
     * @memberof ModelsLoginApiToken
     */
    can_read?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsLoginApiToken
     */
    can_write?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsLoginApiToken
     */
    created_at?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsLoginApiToken
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsLoginApiToken
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsLoginApiToken
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface ModelsLoginServerAdmin
 */
export interface ModelsLoginServerAdmin {
    /**
     * 
     * @type {string}
     * @memberof ModelsLoginServerAdmin
     */
    account_name?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsLoginServerAdmin
     */
    account_password?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsLoginServerAdmin
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsLoginServerAdmin
     */
    first_name?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsLoginServerAdmin
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsLoginServerAdmin
     */
    last_name?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsLoginServerAdmin
     */
    registration_date?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsLoginServerAdmin
     */
    registration_ip_address?: string;
}
/**
 * 
 * @export
 * @interface ModelsLoginServerListType
 */
export interface ModelsLoginServerListType {
    /**
     * 
     * @type {string}
     * @memberof ModelsLoginServerListType
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsLoginServerListType
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface ModelsLoginWorldServer
 */
export interface ModelsLoginWorldServer {
    /**
     * 
     * @type {number}
     * @memberof ModelsLoginWorldServer
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsLoginWorldServer
     */
    is_server_trusted?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsLoginWorldServer
     */
    last_ip_address?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsLoginWorldServer
     */
    last_login_date?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsLoginWorldServer
     */
    login_server_admin_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsLoginWorldServer
     */
    login_server_list_type_id?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsLoginWorldServer
     */
    long_name?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsLoginWorldServer
     */
    note?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsLoginWorldServer
     */
    short_name?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsLoginWorldServer
     */
    tag_description?: string;
}
/**
 * 
 * @export
 * @interface ModelsLogsysCategory
 */
export interface ModelsLogsysCategory {
    /**
     * 
     * @type {string}
     * @memberof ModelsLogsysCategory
     */
    log_category_description?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsLogsysCategory
     */
    log_category_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsLogsysCategory
     */
    log_to_console?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsLogsysCategory
     */
    log_to_file?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsLogsysCategory
     */
    log_to_gmsay?: number;
}
/**
 * 
 * @export
 * @interface ModelsLootdrop
 */
export interface ModelsLootdrop {
    /**
     * 
     * @type {string}
     * @memberof ModelsLootdrop
     */
    content_flags?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsLootdrop
     */
    content_flags_disabled?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsLootdrop
     */
    id?: number;
    /**
     * 
     * @type {Array<ModelsLootdropEntry>}
     * @memberof ModelsLootdrop
     */
    lootdrop_entries?: Array<ModelsLootdropEntry>;
    /**
     * 
     * @type {number}
     * @memberof ModelsLootdrop
     */
    max_expansion?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsLootdrop
     */
    min_expansion?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsLootdrop
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface ModelsLootdropEntry
 */
export interface ModelsLootdropEntry {
    /**
     * 
     * @type {number}
     * @memberof ModelsLootdropEntry
     */
    chance?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsLootdropEntry
     */
    disabled_chance?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsLootdropEntry
     */
    equip_item?: number;
    /**
     * 
     * @type {ModelsItem}
     * @memberof ModelsLootdropEntry
     */
    item?: ModelsItem;
    /**
     * 
     * @type {number}
     * @memberof ModelsLootdropEntry
     */
    item_charges?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsLootdropEntry
     */
    item_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsLootdropEntry
     */
    lootdrop_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsLootdropEntry
     */
    multiplier?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsLootdropEntry
     */
    npc_max_level?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsLootdropEntry
     */
    npc_min_level?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsLootdropEntry
     */
    trivial_max_level?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsLootdropEntry
     */
    trivial_min_level?: number;
}
/**
 * 
 * @export
 * @interface ModelsLoottable
 */
export interface ModelsLoottable {
    /**
     * 
     * @type {number}
     * @memberof ModelsLoottable
     */
    avgcoin?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsLoottable
     */
    content_flags?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsLoottable
     */
    content_flags_disabled?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsLoottable
     */
    done?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsLoottable
     */
    id?: number;
    /**
     * 
     * @type {Array<ModelsLoottableEntry>}
     * @memberof ModelsLoottable
     */
    loottable_entries?: Array<ModelsLoottableEntry>;
    /**
     * 
     * @type {number}
     * @memberof ModelsLoottable
     */
    max_expansion?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsLoottable
     */
    maxcash?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsLoottable
     */
    min_expansion?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsLoottable
     */
    mincash?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsLoottable
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface ModelsLoottableEntry
 */
export interface ModelsLoottableEntry {
    /**
     * 
     * @type {number}
     * @memberof ModelsLoottableEntry
     */
    droplimit?: number;
    /**
     * 
     * @type {Array<ModelsLootdropEntry>}
     * @memberof ModelsLoottableEntry
     */
    lootdrop_entries?: Array<ModelsLootdropEntry>;
    /**
     * 
     * @type {number}
     * @memberof ModelsLoottableEntry
     */
    lootdrop_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsLoottableEntry
     */
    loottable_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsLoottableEntry
     */
    mindrop?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsLoottableEntry
     */
    multiplier?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsLoottableEntry
     */
    probability?: number;
}
/**
 * 
 * @export
 * @interface ModelsMail
 */
export interface ModelsMail {
    /**
     * 
     * @type {string}
     * @memberof ModelsMail
     */
    body?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsMail
     */
    charid?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsMail
     */
    from?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsMail
     */
    msgid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsMail
     */
    status?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsMail
     */
    subject?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsMail
     */
    timestamp?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsMail
     */
    to?: string;
}
/**
 * 
 * @export
 * @interface ModelsMerchantlist
 */
export interface ModelsMerchantlist {
    /**
     * 
     * @type {number}
     * @memberof ModelsMerchantlist
     */
    alt_currency_cost?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsMerchantlist
     */
    classes_required?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsMerchantlist
     */
    content_flags?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsMerchantlist
     */
    content_flags_disabled?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsMerchantlist
     */
    faction_required?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsMerchantlist
     */
    item?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsMerchantlist
     */
    level_required?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsMerchantlist
     */
    max_expansion?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsMerchantlist
     */
    merchantid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsMerchantlist
     */
    min_expansion?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsMerchantlist
     */
    probability?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsMerchantlist
     */
    slot?: number;
}
/**
 * 
 * @export
 * @interface ModelsNameFilter
 */
export interface ModelsNameFilter {
    /**
     * 
     * @type {number}
     * @memberof ModelsNameFilter
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsNameFilter
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface ModelsNpcEmote
 */
export interface ModelsNpcEmote {
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcEmote
     */
    emoteid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcEmote
     */
    event_?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcEmote
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsNpcEmote
     */
    text?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcEmote
     */
    type?: number;
}
/**
 * 
 * @export
 * @interface ModelsNpcFaction
 */
export interface ModelsNpcFaction {
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcFaction
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcFaction
     */
    ignore_primary_assist?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsNpcFaction
     */
    name?: string;
    /**
     * 
     * @type {Array<ModelsNpcFactionEntry>}
     * @memberof ModelsNpcFaction
     */
    npc_faction_entries?: Array<ModelsNpcFactionEntry>;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcFaction
     */
    primaryfaction?: number;
}
/**
 * 
 * @export
 * @interface ModelsNpcFactionEntry
 */
export interface ModelsNpcFactionEntry {
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcFactionEntry
     */
    faction_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcFactionEntry
     */
    npc_faction_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcFactionEntry
     */
    npc_value?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcFactionEntry
     */
    temp?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcFactionEntry
     */
    value?: number;
}
/**
 * 
 * @export
 * @interface ModelsNpcScaleGlobalBase
 */
export interface ModelsNpcScaleGlobalBase {
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcScaleGlobalBase
     */
    ac?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcScaleGlobalBase
     */
    accuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcScaleGlobalBase
     */
    agility?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcScaleGlobalBase
     */
    attack?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcScaleGlobalBase
     */
    attack_delay?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcScaleGlobalBase
     */
    charisma?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcScaleGlobalBase
     */
    cold_resist?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcScaleGlobalBase
     */
    corruption_resist?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcScaleGlobalBase
     */
    dexterity?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcScaleGlobalBase
     */
    disease_resist?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcScaleGlobalBase
     */
    fire_resist?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcScaleGlobalBase
     */
    heal_scale?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcScaleGlobalBase
     */
    hp?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcScaleGlobalBase
     */
    hp_regen_rate?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcScaleGlobalBase
     */
    intelligence?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcScaleGlobalBase
     */
    level?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcScaleGlobalBase
     */
    magic_resist?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcScaleGlobalBase
     */
    max_dmg?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcScaleGlobalBase
     */
    min_dmg?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcScaleGlobalBase
     */
    physical_resist?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcScaleGlobalBase
     */
    poison_resist?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcScaleGlobalBase
     */
    slow_mitigation?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsNpcScaleGlobalBase
     */
    special_abilities?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcScaleGlobalBase
     */
    spell_scale?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcScaleGlobalBase
     */
    stamina?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcScaleGlobalBase
     */
    strength?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcScaleGlobalBase
     */
    type?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcScaleGlobalBase
     */
    wisdom?: number;
}
/**
 * 
 * @export
 * @interface ModelsNpcSpell
 */
export interface ModelsNpcSpell {
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcSpell
     */
    attack_proc?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcSpell
     */
    defensive_proc?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcSpell
     */
    dproc_chance?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcSpell
     */
    engaged_b_other_chance?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcSpell
     */
    engaged_b_self_chance?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcSpell
     */
    engaged_d_chance?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcSpell
     */
    engaged_no_sp_recast_max?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcSpell
     */
    engaged_no_sp_recast_min?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcSpell
     */
    fail_recast?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcSpell
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcSpell
     */
    idle_b_chance?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcSpell
     */
    idle_no_sp_recast_max?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcSpell
     */
    idle_no_sp_recast_min?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsNpcSpell
     */
    name?: string;
    /**
     * 
     * @type {Array<ModelsNpcSpellsEntry>}
     * @memberof ModelsNpcSpell
     */
    npc_spells_entries?: Array<ModelsNpcSpellsEntry>;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcSpell
     */
    parent_list?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcSpell
     */
    proc_chance?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcSpell
     */
    pursue_d_chance?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcSpell
     */
    pursue_no_sp_recast_max?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcSpell
     */
    pursue_no_sp_recast_min?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcSpell
     */
    range_proc?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcSpell
     */
    rproc_chance?: number;
}
/**
 * 
 * @export
 * @interface ModelsNpcSpellsEffect
 */
export interface ModelsNpcSpellsEffect {
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcSpellsEffect
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsNpcSpellsEffect
     */
    name?: string;
    /**
     * 
     * @type {Array<ModelsNpcSpellsEffectsEntry>}
     * @memberof ModelsNpcSpellsEffect
     */
    npc_spells_effects_entries?: Array<ModelsNpcSpellsEffectsEntry>;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcSpellsEffect
     */
    parent_list?: number;
}
/**
 * 
 * @export
 * @interface ModelsNpcSpellsEffectsEntry
 */
export interface ModelsNpcSpellsEffectsEntry {
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcSpellsEffectsEntry
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcSpellsEffectsEntry
     */
    maxlevel?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcSpellsEffectsEntry
     */
    minlevel?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcSpellsEffectsEntry
     */
    npc_spells_effects_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcSpellsEffectsEntry
     */
    se_base?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcSpellsEffectsEntry
     */
    se_limit?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcSpellsEffectsEntry
     */
    se_max?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcSpellsEffectsEntry
     */
    spell_effect_id?: number;
}
/**
 * 
 * @export
 * @interface ModelsNpcSpellsEntry
 */
export interface ModelsNpcSpellsEntry {
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcSpellsEntry
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcSpellsEntry
     */
    manacost?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcSpellsEntry
     */
    max_hp?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcSpellsEntry
     */
    maxlevel?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcSpellsEntry
     */
    min_hp?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcSpellsEntry
     */
    minlevel?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcSpellsEntry
     */
    npc_spells_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcSpellsEntry
     */
    priority?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcSpellsEntry
     */
    recast_delay?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcSpellsEntry
     */
    resist_adjust?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcSpellsEntry
     */
    spellid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcSpellsEntry
     */
    type?: number;
}
/**
 * 
 * @export
 * @interface ModelsNpcType
 */
export interface ModelsNpcType {
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    _int?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    ac?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    accuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    adventure_template_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    aggroradius?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    agi?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    alt_currency_id?: number;
    /**
     * 
     * @type {ModelsAlternateCurrency}
     * @memberof ModelsNpcType
     */
    alternate_currency?: ModelsAlternateCurrency;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    always_aggro?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsNpcType
     */
    ammo_idfile?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    armortint_blue?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    armortint_green?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    armortint_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    armortint_red?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    armtexture?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    assistradius?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    atk?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    attack_count?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    attack_delay?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    attack_speed?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    avoidance?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    bodytype?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    bracertexture?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    cha?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    charm_ac?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    charm_accuracy_rating?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    charm_atk?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    charm_attack_delay?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    charm_avoidance_rating?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    charm_max_dmg?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    charm_min_dmg?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    _class?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    corrup?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    cr?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    d_melee_texture_1?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    d_melee_texture_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    dex?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    dr?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    drakkin_details?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    drakkin_heritage?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    drakkin_tattoo?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    emoteid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    exclude?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    face?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    feettexture?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    findable?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    fixed?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    flymode?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    fr?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    gender?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    handtexture?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    healscale?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    helmtexture?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    herosforgemodel?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    hp?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    hp_regen_rate?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    ignore_despawn?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    isbot?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    isquest?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsNpcType
     */
    lastname?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    legtexture?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    level?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    light?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    loottable_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    luclin_beard?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    luclin_beardcolor?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    luclin_eyecolor?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    luclin_eyecolor_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    luclin_haircolor?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    luclin_hairstyle?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    mana?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    mana_regen_rate?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    maxdmg?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    maxlevel?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    merchant_id?: number;
    /**
     * 
     * @type {Array<ModelsMerchantlist>}
     * @memberof ModelsNpcType
     */
    merchantlists?: Array<ModelsMerchantlist>;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    mindmg?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    model?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    mr?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsNpcType
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    no_target_hotkey?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    npc_aggro?: number;
    /**
     * 
     * @type {Array<ModelsNpcEmote>}
     * @memberof ModelsNpcType
     */
    npc_emotes?: Array<ModelsNpcEmote>;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    npc_faction_id?: number;
    /**
     * 
     * @type {Array<ModelsNpcFaction>}
     * @memberof ModelsNpcType
     */
    npc_factions?: Array<ModelsNpcFaction>;
    /**
     * 
     * @type {Array<ModelsNpcSpell>}
     * @memberof ModelsNpcType
     */
    npc_spells?: Array<ModelsNpcSpell>;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    npc_spells_effects_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    npc_spells_id?: number;
    /**
     * 
     * @type {ModelsNpcTypesTint}
     * @memberof ModelsNpcType
     */
    npc_types_tint?: ModelsNpcTypesTint;
    /**
     * 
     * @type {string}
     * @memberof ModelsNpcType
     */
    npcspecialattks?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    peqid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    ph_r?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    pr?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    prim_melee_type?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    private_corpse?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    qglobal?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    race?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    raid_target?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    ranged_type?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    rare_spawn?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    runspeed?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    scalerate?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    sec_melee_type?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    see_hide?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    see_improved_hide?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    see_invis?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    see_invis_undead?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    show_name?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    size?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    skip_global_loot?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    slow_mitigation?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    spawn_limit?: number;
    /**
     * 
     * @type {Array<ModelsSpawnentry>}
     * @memberof ModelsNpcType
     */
    spawnentries?: Array<ModelsSpawnentry>;
    /**
     * 
     * @type {string}
     * @memberof ModelsNpcType
     */
    special_abilities?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    spellscale?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    sta?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    str?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    stuck_behavior?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    texture?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    trackable?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    trap_template?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    underwater?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    unique_?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    unique_spawn_by_name?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    untargetable?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    version?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    walkspeed?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcType
     */
    wis?: number;
}
/**
 * 
 * @export
 * @interface ModelsNpcTypesTint
 */
export interface ModelsNpcTypesTint {
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcTypesTint
     */
    blu_1_h?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcTypesTint
     */
    blu_2_c?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcTypesTint
     */
    blu_3_a?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcTypesTint
     */
    blu_4_b?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcTypesTint
     */
    blu_5_g?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcTypesTint
     */
    blu_6_l?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcTypesTint
     */
    blu_7_f?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcTypesTint
     */
    blu_8_x?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcTypesTint
     */
    blu_9_x?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcTypesTint
     */
    grn_1_h?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcTypesTint
     */
    grn_2_c?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcTypesTint
     */
    grn_3_a?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcTypesTint
     */
    grn_4_b?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcTypesTint
     */
    grn_5_g?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcTypesTint
     */
    grn_6_l?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcTypesTint
     */
    grn_7_f?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcTypesTint
     */
    grn_8_x?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcTypesTint
     */
    grn_9_x?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcTypesTint
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcTypesTint
     */
    red_1_h?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcTypesTint
     */
    red_2_c?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcTypesTint
     */
    red_3_a?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcTypesTint
     */
    red_4_b?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcTypesTint
     */
    red_5_g?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcTypesTint
     */
    red_6_l?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcTypesTint
     */
    red_7_f?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcTypesTint
     */
    red_8_x?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsNpcTypesTint
     */
    red_9_x?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsNpcTypesTint
     */
    tint_set_name?: string;
}
/**
 * 
 * @export
 * @interface ModelsObject
 */
export interface ModelsObject {
    /**
     * 
     * @type {number}
     * @memberof ModelsObject
     */
    charges?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsObject
     */
    content_flags?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsObject
     */
    content_flags_disabled?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsObject
     */
    display_name?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsObject
     */
    heading?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsObject
     */
    icon?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsObject
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsObject
     */
    itemid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsObject
     */
    max_expansion?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsObject
     */
    min_expansion?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsObject
     */
    objectname?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsObject
     */
    size?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsObject
     */
    tilt_x?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsObject
     */
    tilt_y?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsObject
     */
    type?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsObject
     */
    unknown_08?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsObject
     */
    unknown_10?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsObject
     */
    unknown_20?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsObject
     */
    unknown_24?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsObject
     */
    unknown_60?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsObject
     */
    unknown_64?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsObject
     */
    unknown_68?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsObject
     */
    unknown_72?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsObject
     */
    unknown_76?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsObject
     */
    unknown_84?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsObject
     */
    version?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsObject
     */
    xpos?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsObject
     */
    ypos?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsObject
     */
    zoneid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsObject
     */
    zpos?: number;
}
/**
 * 
 * @export
 * @interface ModelsPerlEventExportSetting
 */
export interface ModelsPerlEventExportSetting {
    /**
     * 
     * @type {string}
     * @memberof ModelsPerlEventExportSetting
     */
    event_description?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsPerlEventExportSetting
     */
    event_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsPerlEventExportSetting
     */
    export_event?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsPerlEventExportSetting
     */
    export_item?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsPerlEventExportSetting
     */
    export_mob?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsPerlEventExportSetting
     */
    export_qglobals?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsPerlEventExportSetting
     */
    export_zone?: number;
}
/**
 * 
 * @export
 * @interface ModelsPetsEquipmentset
 */
export interface ModelsPetsEquipmentset {
    /**
     * 
     * @type {number}
     * @memberof ModelsPetsEquipmentset
     */
    nested_set?: number;
    /**
     * 
     * @type {Array<ModelsPetsEquipmentsetEntry>}
     * @memberof ModelsPetsEquipmentset
     */
    pets_equipmentset_entries?: Array<ModelsPetsEquipmentsetEntry>;
    /**
     * 
     * @type {number}
     * @memberof ModelsPetsEquipmentset
     */
    set_id?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsPetsEquipmentset
     */
    setname?: string;
}
/**
 * 
 * @export
 * @interface ModelsPetsEquipmentsetEntry
 */
export interface ModelsPetsEquipmentsetEntry {
    /**
     * 
     * @type {number}
     * @memberof ModelsPetsEquipmentsetEntry
     */
    item_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsPetsEquipmentsetEntry
     */
    set_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsPetsEquipmentsetEntry
     */
    slot?: number;
}
/**
 * 
 * @export
 * @interface ModelsPlayerTitleset
 */
export interface ModelsPlayerTitleset {
    /**
     * 
     * @type {number}
     * @memberof ModelsPlayerTitleset
     */
    char_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsPlayerTitleset
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsPlayerTitleset
     */
    title_set?: number;
}
/**
 * 
 * @export
 * @interface ModelsQuestGlobal
 */
export interface ModelsQuestGlobal {
    /**
     * 
     * @type {number}
     * @memberof ModelsQuestGlobal
     */
    charid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsQuestGlobal
     */
    expdate?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsQuestGlobal
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsQuestGlobal
     */
    npcid?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsQuestGlobal
     */
    value?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsQuestGlobal
     */
    zoneid?: number;
}
/**
 * 
 * @export
 * @interface ModelsRaidDetail
 */
export interface ModelsRaidDetail {
    /**
     * 
     * @type {number}
     * @memberof ModelsRaidDetail
     */
    locked?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsRaidDetail
     */
    loottype?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsRaidDetail
     */
    motd?: string;
    /**
     * 
     * @type {Array<ModelsRaidLeader>}
     * @memberof ModelsRaidDetail
     */
    raid_leaders?: Array<ModelsRaidLeader>;
    /**
     * 
     * @type {Array<ModelsRaidMember>}
     * @memberof ModelsRaidDetail
     */
    raid_members?: Array<ModelsRaidMember>;
    /**
     * 
     * @type {number}
     * @memberof ModelsRaidDetail
     */
    raidid?: number;
}
/**
 * 
 * @export
 * @interface ModelsRaidLeader
 */
export interface ModelsRaidLeader {
    /**
     * 
     * @type {string}
     * @memberof ModelsRaidLeader
     */
    assist?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsRaidLeader
     */
    gid?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof ModelsRaidLeader
     */
    leadershipaa?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof ModelsRaidLeader
     */
    maintank?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsRaidLeader
     */
    marknpc?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsRaidLeader
     */
    mentor_percent?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsRaidLeader
     */
    mentoree?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsRaidLeader
     */
    puller?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsRaidLeader
     */
    rid?: number;
}
/**
 * 
 * @export
 * @interface ModelsRaidMember
 */
export interface ModelsRaidMember {
    /**
     * 
     * @type {number}
     * @memberof ModelsRaidMember
     */
    _class?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsRaidMember
     */
    charid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsRaidMember
     */
    groupid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsRaidMember
     */
    isgroupleader?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsRaidMember
     */
    islooter?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsRaidMember
     */
    israidleader?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsRaidMember
     */
    level?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsRaidMember
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsRaidMember
     */
    raidid?: number;
}
/**
 * 
 * @export
 * @interface ModelsReport
 */
export interface ModelsReport {
    /**
     * 
     * @type {number}
     * @memberof ModelsReport
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsReport
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsReport
     */
    reported?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsReport
     */
    reported_text?: string;
}
/**
 * 
 * @export
 * @interface ModelsRespawnTime
 */
export interface ModelsRespawnTime {
    /**
     * 
     * @type {number}
     * @memberof ModelsRespawnTime
     */
    duration?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsRespawnTime
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsRespawnTime
     */
    instance_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsRespawnTime
     */
    start?: number;
}
/**
 * 
 * @export
 * @interface ModelsSaylink
 */
export interface ModelsSaylink {
    /**
     * 
     * @type {number}
     * @memberof ModelsSaylink
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsSaylink
     */
    phrase?: string;
}
/**
 * 
 * @export
 * @interface ModelsServerDatabaseConnection
 */
export interface ModelsServerDatabaseConnection {
    /**
     * 
     * @type {string}
     * @memberof ModelsServerDatabaseConnection
     */
    content_db_host?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsServerDatabaseConnection
     */
    content_db_name?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsServerDatabaseConnection
     */
    content_db_password?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsServerDatabaseConnection
     */
    content_db_port?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsServerDatabaseConnection
     */
    content_db_username?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsServerDatabaseConnection
     */
    created_at?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsServerDatabaseConnection
     */
    created_by?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsServerDatabaseConnection
     */
    created_from_ip?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsServerDatabaseConnection
     */
    db_host?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsServerDatabaseConnection
     */
    db_name?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsServerDatabaseConnection
     */
    db_password?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsServerDatabaseConnection
     */
    db_port?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsServerDatabaseConnection
     */
    db_username?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsServerDatabaseConnection
     */
    deleted_at?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsServerDatabaseConnection
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsServerDatabaseConnection
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsServerDatabaseConnection
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface ModelsSharedbank
 */
export interface ModelsSharedbank {
    /**
     * 
     * @type {number}
     * @memberof ModelsSharedbank
     */
    acctid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSharedbank
     */
    augslot_1?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSharedbank
     */
    augslot_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSharedbank
     */
    augslot_3?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSharedbank
     */
    augslot_4?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSharedbank
     */
    augslot_5?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSharedbank
     */
    augslot_6?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSharedbank
     */
    charges?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsSharedbank
     */
    custom_data?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsSharedbank
     */
    itemid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSharedbank
     */
    slotid?: number;
}
/**
 * 
 * @export
 * @interface ModelsSpawn2
 */
export interface ModelsSpawn2 {
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawn2
     */
    _condition?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawn2
     */
    animation?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawn2
     */
    cond_value?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsSpawn2
     */
    content_flags?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsSpawn2
     */
    content_flags_disabled?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawn2
     */
    enabled?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawn2
     */
    heading?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawn2
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawn2
     */
    max_expansion?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawn2
     */
    min_expansion?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawn2
     */
    pathgrid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawn2
     */
    respawntime?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawn2
     */
    spawngroup_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawn2
     */
    variance?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawn2
     */
    version?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawn2
     */
    x?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawn2
     */
    y?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawn2
     */
    z?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsSpawn2
     */
    zone?: string;
}
/**
 * 
 * @export
 * @interface ModelsSpawnCondition
 */
export interface ModelsSpawnCondition {
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawnCondition
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsSpawnCondition
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawnCondition
     */
    onchange?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawnCondition
     */
    value?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsSpawnCondition
     */
    zone?: string;
}
/**
 * 
 * @export
 * @interface ModelsSpawnConditionValue
 */
export interface ModelsSpawnConditionValue {
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawnConditionValue
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawnConditionValue
     */
    instance_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawnConditionValue
     */
    value?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsSpawnConditionValue
     */
    zone?: string;
}
/**
 * 
 * @export
 * @interface ModelsSpawnEvent
 */
export interface ModelsSpawnEvent {
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawnEvent
     */
    action?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawnEvent
     */
    argument?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawnEvent
     */
    cond_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawnEvent
     */
    enabled?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawnEvent
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsSpawnEvent
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawnEvent
     */
    next_day?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawnEvent
     */
    next_hour?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawnEvent
     */
    next_minute?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawnEvent
     */
    next_month?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawnEvent
     */
    next_year?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawnEvent
     */
    period?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawnEvent
     */
    strict?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsSpawnEvent
     */
    zone?: string;
}
/**
 * 
 * @export
 * @interface ModelsSpawnentry
 */
export interface ModelsSpawnentry {
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawnentry
     */
    chance?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawnentry
     */
    condition_value_filter?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawnentry
     */
    npc_id?: number;
    /**
     * 
     * @type {ModelsSpawngroup}
     * @memberof ModelsSpawnentry
     */
    spawngroup?: ModelsSpawngroup;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawnentry
     */
    spawngroup_id?: number;
}
/**
 * 
 * @export
 * @interface ModelsSpawngroup
 */
export interface ModelsSpawngroup {
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawngroup
     */
    delay?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawngroup
     */
    despawn?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawngroup
     */
    despawn_timer?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawngroup
     */
    dist?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawngroup
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawngroup
     */
    max_x?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawngroup
     */
    max_y?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawngroup
     */
    min_x?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawngroup
     */
    min_y?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawngroup
     */
    mindelay?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsSpawngroup
     */
    name?: string;
    /**
     * 
     * @type {ModelsSpawn2}
     * @memberof ModelsSpawngroup
     */
    spawn_2?: ModelsSpawn2;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawngroup
     */
    spawn_limit?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpawngroup
     */
    wp_spawns?: number;
}
/**
 * 
 * @export
 * @interface ModelsSpellBucket
 */
export interface ModelsSpellBucket {
    /**
     * 
     * @type {string}
     * @memberof ModelsSpellBucket
     */
    key?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellBucket
     */
    spellid?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsSpellBucket
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface ModelsSpellGlobal
 */
export interface ModelsSpellGlobal {
    /**
     * 
     * @type {string}
     * @memberof ModelsSpellGlobal
     */
    qglobal?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsSpellGlobal
     */
    spell_name?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellGlobal
     */
    spellid?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsSpellGlobal
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface ModelsSpellsNew
 */
export interface ModelsSpellsNew {
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    activated?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    ae_duration?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    aemaxtargets?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    allowrest?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    aoerange?: number;
    /**
     * 
     * @type {ModelsAura}
     * @memberof ModelsSpellsNew
     */
    aura?: ModelsAura;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    basediff?: number;
    /**
     * 
     * @type {Array<ModelsBlockedSpell>}
     * @memberof ModelsSpellsNew
     */
    blocked_spells?: Array<ModelsBlockedSpell>;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    bonushate?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    buffduration?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    buffdurationformula?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    can_mgb?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    cast_not_standing?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsSpellsNew
     */
    cast_on_other?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsSpellsNew
     */
    cast_on_you?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    cast_restriction?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    cast_time?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    casting_anim?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    classes_1?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    classes_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    classes_3?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    classes_4?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    classes_5?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    classes_6?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    classes_7?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    classes_8?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    classes_9?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    classes_10?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    classes_11?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    classes_12?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    classes_13?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    classes_14?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    classes_15?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    classes_16?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    component_counts_1?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    component_counts_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    component_counts_3?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    component_counts_4?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    components_1?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    components_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    components_3?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    components_4?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    cone_start_angle?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    cone_stop_angle?: number;
    /**
     * 
     * @type {Array<ModelsDamageshieldtype>}
     * @memberof ModelsSpellsNew
     */
    damageshieldtypes?: Array<ModelsDamageshieldtype>;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    deities_0?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    deities_1?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    deities_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    deities_3?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    deities_4?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    deities_5?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    deities_6?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    deities_7?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    deities_8?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    deities_9?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    deities_10?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    deities_11?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    deities_12?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    deities_13?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    deities_14?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    deities_15?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    deities_16?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    deleteable?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    descnum?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    disallow_sit?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    dot_stacking_exempt?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    effect_base_value_1?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    effect_base_value_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    effect_base_value_3?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    effect_base_value_4?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    effect_base_value_5?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    effect_base_value_6?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    effect_base_value_7?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    effect_base_value_8?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    effect_base_value_9?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    effect_base_value_10?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    effect_base_value_11?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    effect_base_value_12?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    effect_limit_value_1?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    effect_limit_value_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    effect_limit_value_3?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    effect_limit_value_4?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    effect_limit_value_5?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    effect_limit_value_6?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    effect_limit_value_7?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    effect_limit_value_8?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    effect_limit_value_9?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    effect_limit_value_10?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    effect_limit_value_11?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    effect_limit_value_12?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    effectdescnum?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    effectdescnum_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    effectid_1?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    effectid_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    effectid_3?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    effectid_4?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    effectid_5?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    effectid_6?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    effectid_7?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    effectid_8?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    effectid_9?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    effectid_10?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    effectid_11?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    effectid_12?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    endur_cost?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    endur_timer_index?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    endur_upkeep?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    environment_type?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    field_142?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    field_143?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    field_152?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    field_153?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    field_160?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    field_163?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    field_164?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    field_169?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    field_170?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    field_171?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    field_172?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    field_181?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    field_182?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    field_198?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    field_199?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    field_203?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    field_204?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    field_206?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    field_209?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    field_210?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    field_215?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    field_216?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    field_217?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    field_220?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    field_221?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    field_222?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    field_223?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    field_225?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    field_226?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    field_232?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    field_233?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    field_234?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    field_235?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    field_236?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    formula_1?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    formula_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    formula_3?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    formula_4?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    formula_5?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    formula_6?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    formula_7?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    formula_8?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    formula_9?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    formula_10?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    formula_11?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    formula_12?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    good_effect?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    hate_added?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    icon?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    in_combat?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    is_discipline?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    ldon_trap?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    light_type?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    mana?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    max_1?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    max_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    max_3?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    max_4?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    max_5?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    max_6?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    max_7?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    max_8?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    max_9?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    max_10?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    max_11?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    max_12?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    max_dist?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    max_dist_mod?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    max_resist?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    maxtargets?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    memicon?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    min_dist?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    min_dist_mod?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    min_range?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    min_resist?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsSpellsNew
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    new_icon?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    nimbuseffect?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    no_block?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    no_partial_resist?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    nodispell?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    noexpend_reagent_1?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    noexpend_reagent_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    noexpend_reagent_3?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    noexpend_reagent_4?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    not_extendable?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    npc_category?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    npc_no_los?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    npc_usefulness?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    numhits?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    numhitstype?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsSpellsNew
     */
    other_casts?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    outof_combat?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    pcnpc_only_flag?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    persistdeath?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsSpellsNew
     */
    player_1?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    pushback?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    pushup?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    pvpresistbase?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    pvpresistcalc?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    pvpresistcap?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    range?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    rank?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    recast_time?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    recourse_link?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    recovery_time?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    reflectable?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    resist_diff?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    resisttype?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    short_buff_box?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    skill?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    sneaking?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    songcap?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    spell_affect_index?: number;
    /**
     * 
     * @type {Array<ModelsSpellBucket>}
     * @memberof ModelsSpellsNew
     */
    spell_buckets?: Array<ModelsSpellBucket>;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    spell_category?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsSpellsNew
     */
    spell_fades?: string;
    /**
     * 
     * @type {Array<ModelsSpellGlobal>}
     * @memberof ModelsSpellsNew
     */
    spell_globals?: Array<ModelsSpellGlobal>;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    spellanim?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    spellgroup?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    suspendable?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    target_anim?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    targettype?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsSpellsNew
     */
    teleport_zone?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    time_of_day?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    travel_type?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    typedescnum?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    uninterruptable?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    viral_range?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    viral_targets?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    viral_timer?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsSpellsNew
     */
    you_cast?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsSpellsNew
     */
    zonetype?: number;
}
/**
 * 
 * @export
 * @interface ModelsStartingItem
 */
export interface ModelsStartingItem {
    /**
     * 
     * @type {number}
     * @memberof ModelsStartingItem
     */
    _class?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsStartingItem
     */
    content_flags?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsStartingItem
     */
    content_flags_disabled?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsStartingItem
     */
    deityid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsStartingItem
     */
    gm?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsStartingItem
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsStartingItem
     */
    item_charges?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsStartingItem
     */
    itemid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsStartingItem
     */
    max_expansion?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsStartingItem
     */
    min_expansion?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsStartingItem
     */
    race?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsStartingItem
     */
    slot?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsStartingItem
     */
    zoneid?: number;
}
/**
 * 
 * @export
 * @interface ModelsTask
 */
export interface ModelsTask {
    /**
     * 
     * @type {number}
     * @memberof ModelsTask
     */
    cashreward?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsTask
     */
    completion_emote?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsTask
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsTask
     */
    duration?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTask
     */
    duration_code?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTask
     */
    faction_reward?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTask
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTask
     */
    maxlevel?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTask
     */
    minlevel?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTask
     */
    repeatable?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsTask
     */
    reward?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsTask
     */
    rewardid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTask
     */
    rewardmethod?: number;
    /**
     * 
     * @type {Array<ModelsTaskActivity>}
     * @memberof ModelsTask
     */
    task_activities?: Array<ModelsTaskActivity>;
    /**
     * 
     * @type {Array<ModelsTaskset>}
     * @memberof ModelsTask
     */
    tasksets?: Array<ModelsTaskset>;
    /**
     * 
     * @type {string}
     * @memberof ModelsTask
     */
    title?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsTask
     */
    type?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTask
     */
    xpreward?: number;
}
/**
 * 
 * @export
 * @interface ModelsTaskActivity
 */
export interface ModelsTaskActivity {
    /**
     * 
     * @type {number}
     * @memberof ModelsTaskActivity
     */
    activityid?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTaskActivity
     */
    activitytype?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTaskActivity
     */
    delivertonpc?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsTaskActivity
     */
    description_override?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsTaskActivity
     */
    goalcount?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTaskActivity
     */
    goalid?: number;
    /**
     * 
     * @type {Array<ModelsGoallist>}
     * @memberof ModelsTaskActivity
     */
    goallists?: Array<ModelsGoallist>;
    /**
     * 
     * @type {number}
     * @memberof ModelsTaskActivity
     */
    goalmethod?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsTaskActivity
     */
    item_list?: string;
    /**
     * 
     * @type {ModelsNpcType}
     * @memberof ModelsTaskActivity
     */
    npc_type?: ModelsNpcType;
    /**
     * 
     * @type {number}
     * @memberof ModelsTaskActivity
     */
    optional?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsTaskActivity
     */
    skill_list?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsTaskActivity
     */
    spell_list?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsTaskActivity
     */
    step?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsTaskActivity
     */
    target_name?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsTaskActivity
     */
    taskid?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsTaskActivity
     */
    zones?: string;
}
/**
 * 
 * @export
 * @interface ModelsTaskset
 */
export interface ModelsTaskset {
    /**
     * 
     * @type {number}
     * @memberof ModelsTaskset
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTaskset
     */
    taskid?: number;
}
/**
 * 
 * @export
 * @interface ModelsTimer
 */
export interface ModelsTimer {
    /**
     * 
     * @type {number}
     * @memberof ModelsTimer
     */
    char_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTimer
     */
    duration?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTimer
     */
    enable?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTimer
     */
    start?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTimer
     */
    type?: number;
}
/**
 * 
 * @export
 * @interface ModelsTitle
 */
export interface ModelsTitle {
    /**
     * 
     * @type {number}
     * @memberof ModelsTitle
     */
    char_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTitle
     */
    _class?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTitle
     */
    gender?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTitle
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTitle
     */
    item_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTitle
     */
    max_aa_points?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTitle
     */
    max_skill_value?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTitle
     */
    min_aa_points?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTitle
     */
    min_skill_value?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsTitle
     */
    prefix?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsTitle
     */
    skill_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTitle
     */
    status?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsTitle
     */
    suffix?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsTitle
     */
    title_set?: number;
}
/**
 * 
 * @export
 * @interface ModelsTrader
 */
export interface ModelsTrader {
    /**
     * 
     * @type {number}
     * @memberof ModelsTrader
     */
    char_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTrader
     */
    charges?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTrader
     */
    item_cost?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTrader
     */
    item_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTrader
     */
    serialnumber?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTrader
     */
    slot_id?: number;
}
/**
 * 
 * @export
 * @interface ModelsTradeskillRecipe
 */
export interface ModelsTradeskillRecipe {
    /**
     * 
     * @type {string}
     * @memberof ModelsTradeskillRecipe
     */
    content_flags?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsTradeskillRecipe
     */
    content_flags_disabled?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsTradeskillRecipe
     */
    enabled?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTradeskillRecipe
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTradeskillRecipe
     */
    max_expansion?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTradeskillRecipe
     */
    min_expansion?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTradeskillRecipe
     */
    must_learn?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsTradeskillRecipe
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsTradeskillRecipe
     */
    nofail?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsTradeskillRecipe
     */
    notes?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsTradeskillRecipe
     */
    quest?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTradeskillRecipe
     */
    replace_container?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTradeskillRecipe
     */
    skillneeded?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTradeskillRecipe
     */
    tradeskill?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTradeskillRecipe
     */
    trivial?: number;
}
/**
 * 
 * @export
 * @interface ModelsTradeskillRecipeEntry
 */
export interface ModelsTradeskillRecipeEntry {
    /**
     * 
     * @type {number}
     * @memberof ModelsTradeskillRecipeEntry
     */
    componentcount?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTradeskillRecipeEntry
     */
    failcount?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTradeskillRecipeEntry
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTradeskillRecipeEntry
     */
    iscontainer?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTradeskillRecipeEntry
     */
    item_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTradeskillRecipeEntry
     */
    recipe_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTradeskillRecipeEntry
     */
    salvagecount?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTradeskillRecipeEntry
     */
    successcount?: number;
}
/**
 * 
 * @export
 * @interface ModelsTrap
 */
export interface ModelsTrap {
    /**
     * 
     * @type {number}
     * @memberof ModelsTrap
     */
    chance?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsTrap
     */
    content_flags?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsTrap
     */
    content_flags_disabled?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsTrap
     */
    despawn_when_triggered?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTrap
     */
    effect?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTrap
     */
    effectvalue?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTrap
     */
    effectvalue_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTrap
     */
    group?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTrap
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTrap
     */
    level?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTrap
     */
    max_expansion?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTrap
     */
    maxzdiff?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsTrap
     */
    message?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsTrap
     */
    min_expansion?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTrap
     */
    radius?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTrap
     */
    respawn_time?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTrap
     */
    respawn_var?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTrap
     */
    skill?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTrap
     */
    triggered_number?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTrap
     */
    undetectable?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTrap
     */
    version?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTrap
     */
    x?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTrap
     */
    y?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTrap
     */
    z?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsTrap
     */
    zone?: string;
}
/**
 * 
 * @export
 * @interface ModelsTribute
 */
export interface ModelsTribute {
    /**
     * 
     * @type {string}
     * @memberof ModelsTribute
     */
    descr?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsTribute
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsTribute
     */
    isguild?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsTribute
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsTribute
     */
    unknown?: number;
}
/**
 * 
 * @export
 * @interface ModelsUser
 */
export interface ModelsUser {
    /**
     * 
     * @type {string}
     * @memberof ModelsUser
     */
    avatar?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsUser
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsUser
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsUser
     */
    first_name?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsUser
     */
    full_name?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsUser
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsUser
     */
    last_name?: string;
    /**
     * 
     * @type {Array<ModelsServerDatabaseConnection>}
     * @memberof ModelsUser
     */
    owned_connections?: Array<ModelsServerDatabaseConnection>;
    /**
     * 
     * @type {string}
     * @memberof ModelsUser
     */
    provider?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsUser
     */
    updated_at?: string;
    /**
     * 
     * @type {Array<ModelsUserServerDatabaseConnection>}
     * @memberof ModelsUser
     */
    user_connections?: Array<ModelsUserServerDatabaseConnection>;
    /**
     * 
     * @type {string}
     * @memberof ModelsUser
     */
    user_name?: string;
}
/**
 * 
 * @export
 * @interface ModelsUserServerDatabaseConnection
 */
export interface ModelsUserServerDatabaseConnection {
    /**
     * 
     * @type {string}
     * @memberof ModelsUserServerDatabaseConnection
     */
    created_at?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsUserServerDatabaseConnection
     */
    created_by?: number;
    /**
     * 
     * @type {ModelsServerDatabaseConnection}
     * @memberof ModelsUserServerDatabaseConnection
     */
    database_connection?: ModelsServerDatabaseConnection;
    /**
     * 
     * @type {string}
     * @memberof ModelsUserServerDatabaseConnection
     */
    deleted_at?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsUserServerDatabaseConnection
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsUserServerDatabaseConnection
     */
    server_database_connection_id?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsUserServerDatabaseConnection
     */
    updated_at?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsUserServerDatabaseConnection
     */
    user_id?: number;
}
/**
 * 
 * @export
 * @interface ModelsZone
 */
export interface ModelsZone {
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    canbind?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    cancombat?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    canlevitate?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    castoutdoor?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsZone
     */
    content_flags?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsZone
     */
    content_flags_disabled?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    expansion?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    fast_regen_endurance?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    fast_regen_hp?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    fast_regen_mana?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsZone
     */
    file_name?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsZone
     */
    flag_needed?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    fog_blue?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    fog_blue_1?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    fog_blue_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    fog_blue_3?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    fog_blue_4?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    fog_density?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    fog_green?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    fog_green_1?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    fog_green_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    fog_green_3?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    fog_green_4?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    fog_maxclip?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    fog_maxclip_1?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    fog_maxclip_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    fog_maxclip_3?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    fog_maxclip_4?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    fog_minclip?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    fog_minclip_1?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    fog_minclip_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    fog_minclip_3?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    fog_minclip_4?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    fog_red?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    fog_red_1?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    fog_red_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    fog_red_3?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    fog_red_4?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    graveyard_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    gravity?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    hotzone?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    insttype?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsZone
     */
    long_name?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsZone
     */
    map_file_name?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    max_expansion?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    max_movement_update_range?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    maxclients?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    maxclip?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    min_expansion?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    min_level?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    min_status?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    minclip?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsZone
     */
    note?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    npc_max_aggro_dist?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    peqzone?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    rain_chance_1?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    rain_chance_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    rain_chance_3?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    rain_chance_4?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    rain_duration_1?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    rain_duration_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    rain_duration_3?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    rain_duration_4?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    ruleset?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    safe_x?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    safe_y?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    safe_z?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsZone
     */
    short_name?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    shutdowndelay?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    sky?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    skylock?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    snow_chance_1?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    snow_chance_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    snow_chance_3?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    snow_chance_4?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    snow_duration_1?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    snow_duration_2?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    snow_duration_3?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    snow_duration_4?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    suspendbuffs?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    time_type?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    timezone?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    type?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    underworld?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    version?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    walkspeed?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    zone_exp_multiplier?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    zoneidnumber?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZone
     */
    ztype?: number;
}
/**
 * 
 * @export
 * @interface ModelsZoneFlag
 */
export interface ModelsZoneFlag {
    /**
     * 
     * @type {number}
     * @memberof ModelsZoneFlag
     */
    char_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZoneFlag
     */
    zone_id?: number;
}
/**
 * 
 * @export
 * @interface ModelsZonePoint
 */
export interface ModelsZonePoint {
    /**
     * 
     * @type {number}
     * @memberof ModelsZonePoint
     */
    buffer?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZonePoint
     */
    client_version_mask?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsZonePoint
     */
    content_flags?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsZonePoint
     */
    content_flags_disabled?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsZonePoint
     */
    heading?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZonePoint
     */
    height?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZonePoint
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZonePoint
     */
    is_virtual?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZonePoint
     */
    max_expansion?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZonePoint
     */
    min_expansion?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZonePoint
     */
    number?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZonePoint
     */
    target_heading?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZonePoint
     */
    target_instance?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZonePoint
     */
    target_x?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZonePoint
     */
    target_y?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZonePoint
     */
    target_z?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZonePoint
     */
    target_zone_id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZonePoint
     */
    version?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZonePoint
     */
    width?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZonePoint
     */
    x?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZonePoint
     */
    y?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsZonePoint
     */
    z?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsZonePoint
     */
    zone?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsZonePoint
     */
    zoneinst?: number;
}

/**
 * AaAbilityApi - axios parameter creator
 * @export
 */
export const AaAbilityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates AaAbility
         * @param {ModelsAaAbility} aaAbility AaAbility
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAaAbility: async (aaAbility: ModelsAaAbility, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'aaAbility' is not null or undefined
            if (aaAbility === null || aaAbility === undefined) {
                throw new RequiredError('aaAbility','Required parameter aaAbility was null or undefined when calling createAaAbility.');
            }
            const localVarPath = `/aa_ability`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof aaAbility !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(aaAbility !== undefined ? aaAbility : {})
                : (aaAbility || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes AaAbility
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAaAbility: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteAaAbility.');
            }
            const localVarPath = `/aa_ability/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets AaAbility
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAaAbility: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getAaAbility.');
            }
            const localVarPath = `/aa_ability/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists AaAbilities
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAaAbilities: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/aa_abilities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates AaAbility
         * @param {number} id Id
         * @param {ModelsAaAbility} aaAbility AaAbility
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAaAbility: async (id: number, aaAbility: ModelsAaAbility, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateAaAbility.');
            }
            // verify required parameter 'aaAbility' is not null or undefined
            if (aaAbility === null || aaAbility === undefined) {
                throw new RequiredError('aaAbility','Required parameter aaAbility was null or undefined when calling updateAaAbility.');
            }
            const localVarPath = `/aa_ability/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof aaAbility !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(aaAbility !== undefined ? aaAbility : {})
                : (aaAbility || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AaAbilityApi - functional programming interface
 * @export
 */
export const AaAbilityApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates AaAbility
         * @param {ModelsAaAbility} aaAbility AaAbility
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAaAbility(aaAbility: ModelsAaAbility, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAaAbility>>> {
            const localVarAxiosArgs = await AaAbilityApiAxiosParamCreator(configuration).createAaAbility(aaAbility, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes AaAbility
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAaAbility(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await AaAbilityApiAxiosParamCreator(configuration).deleteAaAbility(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets AaAbility
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAaAbility(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAaAbility>>> {
            const localVarAxiosArgs = await AaAbilityApiAxiosParamCreator(configuration).getAaAbility(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists AaAbilities
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAaAbilities(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAaAbility>>> {
            const localVarAxiosArgs = await AaAbilityApiAxiosParamCreator(configuration).listAaAbilities(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates AaAbility
         * @param {number} id Id
         * @param {ModelsAaAbility} aaAbility AaAbility
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAaAbility(id: number, aaAbility: ModelsAaAbility, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAaAbility>>> {
            const localVarAxiosArgs = await AaAbilityApiAxiosParamCreator(configuration).updateAaAbility(id, aaAbility, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AaAbilityApi - factory interface
 * @export
 */
export const AaAbilityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates AaAbility
         * @param {ModelsAaAbility} aaAbility AaAbility
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAaAbility(aaAbility: ModelsAaAbility, options?: any): AxiosPromise<Array<ModelsAaAbility>> {
            return AaAbilityApiFp(configuration).createAaAbility(aaAbility, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes AaAbility
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAaAbility(id: number, options?: any): AxiosPromise<string> {
            return AaAbilityApiFp(configuration).deleteAaAbility(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets AaAbility
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAaAbility(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsAaAbility>> {
            return AaAbilityApiFp(configuration).getAaAbility(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists AaAbilities
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAaAbilities(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsAaAbility>> {
            return AaAbilityApiFp(configuration).listAaAbilities(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates AaAbility
         * @param {number} id Id
         * @param {ModelsAaAbility} aaAbility AaAbility
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAaAbility(id: number, aaAbility: ModelsAaAbility, options?: any): AxiosPromise<Array<ModelsAaAbility>> {
            return AaAbilityApiFp(configuration).updateAaAbility(id, aaAbility, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createAaAbility operation in AaAbilityApi.
 * @export
 * @interface AaAbilityApiCreateAaAbilityRequest
 */
export interface AaAbilityApiCreateAaAbilityRequest {
    /**
     * AaAbility
     * @type {ModelsAaAbility}
     * @memberof AaAbilityApiCreateAaAbility
     */
    readonly aaAbility: ModelsAaAbility
}

/**
 * Request parameters for deleteAaAbility operation in AaAbilityApi.
 * @export
 * @interface AaAbilityApiDeleteAaAbilityRequest
 */
export interface AaAbilityApiDeleteAaAbilityRequest {
    /**
     * Id
     * @type {number}
     * @memberof AaAbilityApiDeleteAaAbility
     */
    readonly id: number
}

/**
 * Request parameters for getAaAbility operation in AaAbilityApi.
 * @export
 * @interface AaAbilityApiGetAaAbilityRequest
 */
export interface AaAbilityApiGetAaAbilityRequest {
    /**
     * Id
     * @type {number}
     * @memberof AaAbilityApiGetAaAbility
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof AaAbilityApiGetAaAbility
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof AaAbilityApiGetAaAbility
     */
    readonly select?: string
}

/**
 * Request parameters for listAaAbilities operation in AaAbilityApi.
 * @export
 * @interface AaAbilityApiListAaAbilitiesRequest
 */
export interface AaAbilityApiListAaAbilitiesRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof AaAbilityApiListAaAbilities
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof AaAbilityApiListAaAbilities
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof AaAbilityApiListAaAbilities
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof AaAbilityApiListAaAbilities
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof AaAbilityApiListAaAbilities
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof AaAbilityApiListAaAbilities
     */
    readonly select?: string
}

/**
 * Request parameters for updateAaAbility operation in AaAbilityApi.
 * @export
 * @interface AaAbilityApiUpdateAaAbilityRequest
 */
export interface AaAbilityApiUpdateAaAbilityRequest {
    /**
     * Id
     * @type {number}
     * @memberof AaAbilityApiUpdateAaAbility
     */
    readonly id: number

    /**
     * AaAbility
     * @type {ModelsAaAbility}
     * @memberof AaAbilityApiUpdateAaAbility
     */
    readonly aaAbility: ModelsAaAbility
}

/**
 * AaAbilityApi - object-oriented interface
 * @export
 * @class AaAbilityApi
 * @extends {BaseAPI}
 */
export class AaAbilityApi extends BaseAPI {
    /**
     * 
     * @summary Creates AaAbility
     * @param {AaAbilityApiCreateAaAbilityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AaAbilityApi
     */
    public createAaAbility(requestParameters: AaAbilityApiCreateAaAbilityRequest, options?: any) {
        return AaAbilityApiFp(this.configuration).createAaAbility(requestParameters.aaAbility, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes AaAbility
     * @param {AaAbilityApiDeleteAaAbilityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AaAbilityApi
     */
    public deleteAaAbility(requestParameters: AaAbilityApiDeleteAaAbilityRequest, options?: any) {
        return AaAbilityApiFp(this.configuration).deleteAaAbility(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets AaAbility
     * @param {AaAbilityApiGetAaAbilityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AaAbilityApi
     */
    public getAaAbility(requestParameters: AaAbilityApiGetAaAbilityRequest, options?: any) {
        return AaAbilityApiFp(this.configuration).getAaAbility(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists AaAbilities
     * @param {AaAbilityApiListAaAbilitiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AaAbilityApi
     */
    public listAaAbilities(requestParameters: AaAbilityApiListAaAbilitiesRequest = {}, options?: any) {
        return AaAbilityApiFp(this.configuration).listAaAbilities(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates AaAbility
     * @param {AaAbilityApiUpdateAaAbilityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AaAbilityApi
     */
    public updateAaAbility(requestParameters: AaAbilityApiUpdateAaAbilityRequest, options?: any) {
        return AaAbilityApiFp(this.configuration).updateAaAbility(requestParameters.id, requestParameters.aaAbility, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AaRankApi - axios parameter creator
 * @export
 */
export const AaRankApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates AaRank
         * @param {ModelsAaRank} aaRank AaRank
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAaRank: async (aaRank: ModelsAaRank, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'aaRank' is not null or undefined
            if (aaRank === null || aaRank === undefined) {
                throw new RequiredError('aaRank','Required parameter aaRank was null or undefined when calling createAaRank.');
            }
            const localVarPath = `/aa_rank`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof aaRank !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(aaRank !== undefined ? aaRank : {})
                : (aaRank || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes AaRank
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAaRank: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteAaRank.');
            }
            const localVarPath = `/aa_rank/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets AaRank
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAaRank: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getAaRank.');
            }
            const localVarPath = `/aa_rank/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists AaRanks
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAaRanks: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/aa_ranks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates AaRank
         * @param {number} id Id
         * @param {ModelsAaRank} aaRank AaRank
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAaRank: async (id: number, aaRank: ModelsAaRank, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateAaRank.');
            }
            // verify required parameter 'aaRank' is not null or undefined
            if (aaRank === null || aaRank === undefined) {
                throw new RequiredError('aaRank','Required parameter aaRank was null or undefined when calling updateAaRank.');
            }
            const localVarPath = `/aa_rank/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof aaRank !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(aaRank !== undefined ? aaRank : {})
                : (aaRank || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AaRankApi - functional programming interface
 * @export
 */
export const AaRankApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates AaRank
         * @param {ModelsAaRank} aaRank AaRank
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAaRank(aaRank: ModelsAaRank, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAaRank>>> {
            const localVarAxiosArgs = await AaRankApiAxiosParamCreator(configuration).createAaRank(aaRank, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes AaRank
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAaRank(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await AaRankApiAxiosParamCreator(configuration).deleteAaRank(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets AaRank
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAaRank(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAaRank>>> {
            const localVarAxiosArgs = await AaRankApiAxiosParamCreator(configuration).getAaRank(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists AaRanks
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAaRanks(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAaRank>>> {
            const localVarAxiosArgs = await AaRankApiAxiosParamCreator(configuration).listAaRanks(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates AaRank
         * @param {number} id Id
         * @param {ModelsAaRank} aaRank AaRank
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAaRank(id: number, aaRank: ModelsAaRank, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAaRank>>> {
            const localVarAxiosArgs = await AaRankApiAxiosParamCreator(configuration).updateAaRank(id, aaRank, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AaRankApi - factory interface
 * @export
 */
export const AaRankApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates AaRank
         * @param {ModelsAaRank} aaRank AaRank
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAaRank(aaRank: ModelsAaRank, options?: any): AxiosPromise<Array<ModelsAaRank>> {
            return AaRankApiFp(configuration).createAaRank(aaRank, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes AaRank
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAaRank(id: number, options?: any): AxiosPromise<string> {
            return AaRankApiFp(configuration).deleteAaRank(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets AaRank
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAaRank(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsAaRank>> {
            return AaRankApiFp(configuration).getAaRank(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists AaRanks
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAaRanks(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsAaRank>> {
            return AaRankApiFp(configuration).listAaRanks(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates AaRank
         * @param {number} id Id
         * @param {ModelsAaRank} aaRank AaRank
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAaRank(id: number, aaRank: ModelsAaRank, options?: any): AxiosPromise<Array<ModelsAaRank>> {
            return AaRankApiFp(configuration).updateAaRank(id, aaRank, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createAaRank operation in AaRankApi.
 * @export
 * @interface AaRankApiCreateAaRankRequest
 */
export interface AaRankApiCreateAaRankRequest {
    /**
     * AaRank
     * @type {ModelsAaRank}
     * @memberof AaRankApiCreateAaRank
     */
    readonly aaRank: ModelsAaRank
}

/**
 * Request parameters for deleteAaRank operation in AaRankApi.
 * @export
 * @interface AaRankApiDeleteAaRankRequest
 */
export interface AaRankApiDeleteAaRankRequest {
    /**
     * Id
     * @type {number}
     * @memberof AaRankApiDeleteAaRank
     */
    readonly id: number
}

/**
 * Request parameters for getAaRank operation in AaRankApi.
 * @export
 * @interface AaRankApiGetAaRankRequest
 */
export interface AaRankApiGetAaRankRequest {
    /**
     * Id
     * @type {number}
     * @memberof AaRankApiGetAaRank
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof AaRankApiGetAaRank
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof AaRankApiGetAaRank
     */
    readonly select?: string
}

/**
 * Request parameters for listAaRanks operation in AaRankApi.
 * @export
 * @interface AaRankApiListAaRanksRequest
 */
export interface AaRankApiListAaRanksRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof AaRankApiListAaRanks
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof AaRankApiListAaRanks
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof AaRankApiListAaRanks
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof AaRankApiListAaRanks
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof AaRankApiListAaRanks
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof AaRankApiListAaRanks
     */
    readonly select?: string
}

/**
 * Request parameters for updateAaRank operation in AaRankApi.
 * @export
 * @interface AaRankApiUpdateAaRankRequest
 */
export interface AaRankApiUpdateAaRankRequest {
    /**
     * Id
     * @type {number}
     * @memberof AaRankApiUpdateAaRank
     */
    readonly id: number

    /**
     * AaRank
     * @type {ModelsAaRank}
     * @memberof AaRankApiUpdateAaRank
     */
    readonly aaRank: ModelsAaRank
}

/**
 * AaRankApi - object-oriented interface
 * @export
 * @class AaRankApi
 * @extends {BaseAPI}
 */
export class AaRankApi extends BaseAPI {
    /**
     * 
     * @summary Creates AaRank
     * @param {AaRankApiCreateAaRankRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AaRankApi
     */
    public createAaRank(requestParameters: AaRankApiCreateAaRankRequest, options?: any) {
        return AaRankApiFp(this.configuration).createAaRank(requestParameters.aaRank, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes AaRank
     * @param {AaRankApiDeleteAaRankRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AaRankApi
     */
    public deleteAaRank(requestParameters: AaRankApiDeleteAaRankRequest, options?: any) {
        return AaRankApiFp(this.configuration).deleteAaRank(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets AaRank
     * @param {AaRankApiGetAaRankRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AaRankApi
     */
    public getAaRank(requestParameters: AaRankApiGetAaRankRequest, options?: any) {
        return AaRankApiFp(this.configuration).getAaRank(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists AaRanks
     * @param {AaRankApiListAaRanksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AaRankApi
     */
    public listAaRanks(requestParameters: AaRankApiListAaRanksRequest = {}, options?: any) {
        return AaRankApiFp(this.configuration).listAaRanks(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates AaRank
     * @param {AaRankApiUpdateAaRankRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AaRankApi
     */
    public updateAaRank(requestParameters: AaRankApiUpdateAaRankRequest, options?: any) {
        return AaRankApiFp(this.configuration).updateAaRank(requestParameters.id, requestParameters.aaRank, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Account
         * @param {ModelsAccount} account Account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount: async (account: ModelsAccount, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'account' is not null or undefined
            if (account === null || account === undefined) {
                throw new RequiredError('account','Required parameter account was null or undefined when calling createAccount.');
            }
            const localVarPath = `/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof account !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(account !== undefined ? account : {})
                : (account || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes Account
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteAccount.');
            }
            const localVarPath = `/account/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Account
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;AccountFlags&lt;br&gt;AccountIps&lt;br&gt;AccountRewards&lt;br&gt;BugReports&lt;br&gt;Sharedbanks
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getAccount.');
            }
            const localVarPath = `/account/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists Accounts
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;AccountFlags&lt;br&gt;AccountIps&lt;br&gt;AccountRewards&lt;br&gt;BugReports&lt;br&gt;Sharedbanks
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates Account
         * @param {number} id Id
         * @param {ModelsAccount} account Account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount: async (id: number, account: ModelsAccount, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateAccount.');
            }
            // verify required parameter 'account' is not null or undefined
            if (account === null || account === undefined) {
                throw new RequiredError('account','Required parameter account was null or undefined when calling updateAccount.');
            }
            const localVarPath = `/account/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof account !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(account !== undefined ? account : {})
                : (account || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Account
         * @param {ModelsAccount} account Account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccount(account: ModelsAccount, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAccount>>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).createAccount(account, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes Account
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccount(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).deleteAccount(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Account
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;AccountFlags&lt;br&gt;AccountIps&lt;br&gt;AccountRewards&lt;br&gt;BugReports&lt;br&gt;Sharedbanks
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccount(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAccount>>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).getAccount(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists Accounts
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;AccountFlags&lt;br&gt;AccountIps&lt;br&gt;AccountRewards&lt;br&gt;BugReports&lt;br&gt;Sharedbanks
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAccounts(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAccount>>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).listAccounts(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates Account
         * @param {number} id Id
         * @param {ModelsAccount} account Account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccount(id: number, account: ModelsAccount, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAccount>>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).updateAccount(id, account, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates Account
         * @param {ModelsAccount} account Account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(account: ModelsAccount, options?: any): AxiosPromise<Array<ModelsAccount>> {
            return AccountApiFp(configuration).createAccount(account, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes Account
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(id: number, options?: any): AxiosPromise<string> {
            return AccountApiFp(configuration).deleteAccount(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Account
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;AccountFlags&lt;br&gt;AccountIps&lt;br&gt;AccountRewards&lt;br&gt;BugReports&lt;br&gt;Sharedbanks
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsAccount>> {
            return AccountApiFp(configuration).getAccount(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists Accounts
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;AccountFlags&lt;br&gt;AccountIps&lt;br&gt;AccountRewards&lt;br&gt;BugReports&lt;br&gt;Sharedbanks
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsAccount>> {
            return AccountApiFp(configuration).listAccounts(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates Account
         * @param {number} id Id
         * @param {ModelsAccount} account Account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount(id: number, account: ModelsAccount, options?: any): AxiosPromise<Array<ModelsAccount>> {
            return AccountApiFp(configuration).updateAccount(id, account, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createAccount operation in AccountApi.
 * @export
 * @interface AccountApiCreateAccountRequest
 */
export interface AccountApiCreateAccountRequest {
    /**
     * Account
     * @type {ModelsAccount}
     * @memberof AccountApiCreateAccount
     */
    readonly account: ModelsAccount
}

/**
 * Request parameters for deleteAccount operation in AccountApi.
 * @export
 * @interface AccountApiDeleteAccountRequest
 */
export interface AccountApiDeleteAccountRequest {
    /**
     * Id
     * @type {number}
     * @memberof AccountApiDeleteAccount
     */
    readonly id: number
}

/**
 * Request parameters for getAccount operation in AccountApi.
 * @export
 * @interface AccountApiGetAccountRequest
 */
export interface AccountApiGetAccountRequest {
    /**
     * Id
     * @type {number}
     * @memberof AccountApiGetAccount
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;AccountFlags&lt;br&gt;AccountIps&lt;br&gt;AccountRewards&lt;br&gt;BugReports&lt;br&gt;Sharedbanks
     * @type {string}
     * @memberof AccountApiGetAccount
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof AccountApiGetAccount
     */
    readonly select?: string
}

/**
 * Request parameters for listAccounts operation in AccountApi.
 * @export
 * @interface AccountApiListAccountsRequest
 */
export interface AccountApiListAccountsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;AccountFlags&lt;br&gt;AccountIps&lt;br&gt;AccountRewards&lt;br&gt;BugReports&lt;br&gt;Sharedbanks
     * @type {string}
     * @memberof AccountApiListAccounts
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof AccountApiListAccounts
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof AccountApiListAccounts
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof AccountApiListAccounts
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof AccountApiListAccounts
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof AccountApiListAccounts
     */
    readonly select?: string
}

/**
 * Request parameters for updateAccount operation in AccountApi.
 * @export
 * @interface AccountApiUpdateAccountRequest
 */
export interface AccountApiUpdateAccountRequest {
    /**
     * Id
     * @type {number}
     * @memberof AccountApiUpdateAccount
     */
    readonly id: number

    /**
     * Account
     * @type {ModelsAccount}
     * @memberof AccountApiUpdateAccount
     */
    readonly account: ModelsAccount
}

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
    /**
     * 
     * @summary Creates Account
     * @param {AccountApiCreateAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public createAccount(requestParameters: AccountApiCreateAccountRequest, options?: any) {
        return AccountApiFp(this.configuration).createAccount(requestParameters.account, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes Account
     * @param {AccountApiDeleteAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public deleteAccount(requestParameters: AccountApiDeleteAccountRequest, options?: any) {
        return AccountApiFp(this.configuration).deleteAccount(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Account
     * @param {AccountApiGetAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getAccount(requestParameters: AccountApiGetAccountRequest, options?: any) {
        return AccountApiFp(this.configuration).getAccount(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists Accounts
     * @param {AccountApiListAccountsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public listAccounts(requestParameters: AccountApiListAccountsRequest = {}, options?: any) {
        return AccountApiFp(this.configuration).listAccounts(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates Account
     * @param {AccountApiUpdateAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public updateAccount(requestParameters: AccountApiUpdateAccountRequest, options?: any) {
        return AccountApiFp(this.configuration).updateAccount(requestParameters.id, requestParameters.account, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AccountIpApi - axios parameter creator
 * @export
 */
export const AccountIpApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates AccountIp
         * @param {ModelsAccountIp} accountIp AccountIp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccountIp: async (accountIp: ModelsAccountIp, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIp' is not null or undefined
            if (accountIp === null || accountIp === undefined) {
                throw new RequiredError('accountIp','Required parameter accountIp was null or undefined when calling createAccountIp.');
            }
            const localVarPath = `/account_ip`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof accountIp !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(accountIp !== undefined ? accountIp : {})
                : (accountIp || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes AccountIp
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountIp: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteAccountIp.');
            }
            const localVarPath = `/account_ip/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets AccountIp
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountIp: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getAccountIp.');
            }
            const localVarPath = `/account_ip/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists AccountIps
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountIps: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/account_ips`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates AccountIp
         * @param {number} id Id
         * @param {ModelsAccountIp} accountIp AccountIp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountIp: async (id: number, accountIp: ModelsAccountIp, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateAccountIp.');
            }
            // verify required parameter 'accountIp' is not null or undefined
            if (accountIp === null || accountIp === undefined) {
                throw new RequiredError('accountIp','Required parameter accountIp was null or undefined when calling updateAccountIp.');
            }
            const localVarPath = `/account_ip/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof accountIp !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(accountIp !== undefined ? accountIp : {})
                : (accountIp || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountIpApi - functional programming interface
 * @export
 */
export const AccountIpApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates AccountIp
         * @param {ModelsAccountIp} accountIp AccountIp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccountIp(accountIp: ModelsAccountIp, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAccountIp>>> {
            const localVarAxiosArgs = await AccountIpApiAxiosParamCreator(configuration).createAccountIp(accountIp, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes AccountIp
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccountIp(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await AccountIpApiAxiosParamCreator(configuration).deleteAccountIp(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets AccountIp
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountIp(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAccountIp>>> {
            const localVarAxiosArgs = await AccountIpApiAxiosParamCreator(configuration).getAccountIp(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists AccountIps
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAccountIps(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAccountIp>>> {
            const localVarAxiosArgs = await AccountIpApiAxiosParamCreator(configuration).listAccountIps(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates AccountIp
         * @param {number} id Id
         * @param {ModelsAccountIp} accountIp AccountIp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccountIp(id: number, accountIp: ModelsAccountIp, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAccountIp>>> {
            const localVarAxiosArgs = await AccountIpApiAxiosParamCreator(configuration).updateAccountIp(id, accountIp, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AccountIpApi - factory interface
 * @export
 */
export const AccountIpApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates AccountIp
         * @param {ModelsAccountIp} accountIp AccountIp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccountIp(accountIp: ModelsAccountIp, options?: any): AxiosPromise<Array<ModelsAccountIp>> {
            return AccountIpApiFp(configuration).createAccountIp(accountIp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes AccountIp
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountIp(id: number, options?: any): AxiosPromise<string> {
            return AccountIpApiFp(configuration).deleteAccountIp(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets AccountIp
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountIp(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsAccountIp>> {
            return AccountIpApiFp(configuration).getAccountIp(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists AccountIps
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountIps(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsAccountIp>> {
            return AccountIpApiFp(configuration).listAccountIps(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates AccountIp
         * @param {number} id Id
         * @param {ModelsAccountIp} accountIp AccountIp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountIp(id: number, accountIp: ModelsAccountIp, options?: any): AxiosPromise<Array<ModelsAccountIp>> {
            return AccountIpApiFp(configuration).updateAccountIp(id, accountIp, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createAccountIp operation in AccountIpApi.
 * @export
 * @interface AccountIpApiCreateAccountIpRequest
 */
export interface AccountIpApiCreateAccountIpRequest {
    /**
     * AccountIp
     * @type {ModelsAccountIp}
     * @memberof AccountIpApiCreateAccountIp
     */
    readonly accountIp: ModelsAccountIp
}

/**
 * Request parameters for deleteAccountIp operation in AccountIpApi.
 * @export
 * @interface AccountIpApiDeleteAccountIpRequest
 */
export interface AccountIpApiDeleteAccountIpRequest {
    /**
     * Id
     * @type {number}
     * @memberof AccountIpApiDeleteAccountIp
     */
    readonly id: number
}

/**
 * Request parameters for getAccountIp operation in AccountIpApi.
 * @export
 * @interface AccountIpApiGetAccountIpRequest
 */
export interface AccountIpApiGetAccountIpRequest {
    /**
     * Id
     * @type {number}
     * @memberof AccountIpApiGetAccountIp
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof AccountIpApiGetAccountIp
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof AccountIpApiGetAccountIp
     */
    readonly select?: string
}

/**
 * Request parameters for listAccountIps operation in AccountIpApi.
 * @export
 * @interface AccountIpApiListAccountIpsRequest
 */
export interface AccountIpApiListAccountIpsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof AccountIpApiListAccountIps
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof AccountIpApiListAccountIps
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof AccountIpApiListAccountIps
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof AccountIpApiListAccountIps
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof AccountIpApiListAccountIps
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof AccountIpApiListAccountIps
     */
    readonly select?: string
}

/**
 * Request parameters for updateAccountIp operation in AccountIpApi.
 * @export
 * @interface AccountIpApiUpdateAccountIpRequest
 */
export interface AccountIpApiUpdateAccountIpRequest {
    /**
     * Id
     * @type {number}
     * @memberof AccountIpApiUpdateAccountIp
     */
    readonly id: number

    /**
     * AccountIp
     * @type {ModelsAccountIp}
     * @memberof AccountIpApiUpdateAccountIp
     */
    readonly accountIp: ModelsAccountIp
}

/**
 * AccountIpApi - object-oriented interface
 * @export
 * @class AccountIpApi
 * @extends {BaseAPI}
 */
export class AccountIpApi extends BaseAPI {
    /**
     * 
     * @summary Creates AccountIp
     * @param {AccountIpApiCreateAccountIpRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountIpApi
     */
    public createAccountIp(requestParameters: AccountIpApiCreateAccountIpRequest, options?: any) {
        return AccountIpApiFp(this.configuration).createAccountIp(requestParameters.accountIp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes AccountIp
     * @param {AccountIpApiDeleteAccountIpRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountIpApi
     */
    public deleteAccountIp(requestParameters: AccountIpApiDeleteAccountIpRequest, options?: any) {
        return AccountIpApiFp(this.configuration).deleteAccountIp(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets AccountIp
     * @param {AccountIpApiGetAccountIpRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountIpApi
     */
    public getAccountIp(requestParameters: AccountIpApiGetAccountIpRequest, options?: any) {
        return AccountIpApiFp(this.configuration).getAccountIp(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists AccountIps
     * @param {AccountIpApiListAccountIpsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountIpApi
     */
    public listAccountIps(requestParameters: AccountIpApiListAccountIpsRequest = {}, options?: any) {
        return AccountIpApiFp(this.configuration).listAccountIps(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates AccountIp
     * @param {AccountIpApiUpdateAccountIpRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountIpApi
     */
    public updateAccountIp(requestParameters: AccountIpApiUpdateAccountIpRequest, options?: any) {
        return AccountIpApiFp(this.configuration).updateAccountIp(requestParameters.id, requestParameters.accountIp, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AdventureDetailApi - axios parameter creator
 * @export
 */
export const AdventureDetailApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates AdventureDetail
         * @param {ModelsAdventureDetail} adventureDetail AdventureDetail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAdventureDetail: async (adventureDetail: ModelsAdventureDetail, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'adventureDetail' is not null or undefined
            if (adventureDetail === null || adventureDetail === undefined) {
                throw new RequiredError('adventureDetail','Required parameter adventureDetail was null or undefined when calling createAdventureDetail.');
            }
            const localVarPath = `/adventure_detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof adventureDetail !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(adventureDetail !== undefined ? adventureDetail : {})
                : (adventureDetail || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes AdventureDetail
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAdventureDetail: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteAdventureDetail.');
            }
            const localVarPath = `/adventure_detail/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets AdventureDetail
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdventureDetail: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getAdventureDetail.');
            }
            const localVarPath = `/adventure_detail/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists AdventureDetails
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAdventureDetails: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/adventure_details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates AdventureDetail
         * @param {number} id Id
         * @param {ModelsAdventureDetail} adventureDetail AdventureDetail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAdventureDetail: async (id: number, adventureDetail: ModelsAdventureDetail, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateAdventureDetail.');
            }
            // verify required parameter 'adventureDetail' is not null or undefined
            if (adventureDetail === null || adventureDetail === undefined) {
                throw new RequiredError('adventureDetail','Required parameter adventureDetail was null or undefined when calling updateAdventureDetail.');
            }
            const localVarPath = `/adventure_detail/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof adventureDetail !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(adventureDetail !== undefined ? adventureDetail : {})
                : (adventureDetail || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdventureDetailApi - functional programming interface
 * @export
 */
export const AdventureDetailApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates AdventureDetail
         * @param {ModelsAdventureDetail} adventureDetail AdventureDetail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAdventureDetail(adventureDetail: ModelsAdventureDetail, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAdventureDetail>>> {
            const localVarAxiosArgs = await AdventureDetailApiAxiosParamCreator(configuration).createAdventureDetail(adventureDetail, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes AdventureDetail
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAdventureDetail(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await AdventureDetailApiAxiosParamCreator(configuration).deleteAdventureDetail(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets AdventureDetail
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAdventureDetail(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAdventureDetail>>> {
            const localVarAxiosArgs = await AdventureDetailApiAxiosParamCreator(configuration).getAdventureDetail(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists AdventureDetails
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAdventureDetails(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAdventureDetail>>> {
            const localVarAxiosArgs = await AdventureDetailApiAxiosParamCreator(configuration).listAdventureDetails(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates AdventureDetail
         * @param {number} id Id
         * @param {ModelsAdventureDetail} adventureDetail AdventureDetail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAdventureDetail(id: number, adventureDetail: ModelsAdventureDetail, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAdventureDetail>>> {
            const localVarAxiosArgs = await AdventureDetailApiAxiosParamCreator(configuration).updateAdventureDetail(id, adventureDetail, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AdventureDetailApi - factory interface
 * @export
 */
export const AdventureDetailApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates AdventureDetail
         * @param {ModelsAdventureDetail} adventureDetail AdventureDetail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAdventureDetail(adventureDetail: ModelsAdventureDetail, options?: any): AxiosPromise<Array<ModelsAdventureDetail>> {
            return AdventureDetailApiFp(configuration).createAdventureDetail(adventureDetail, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes AdventureDetail
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAdventureDetail(id: number, options?: any): AxiosPromise<string> {
            return AdventureDetailApiFp(configuration).deleteAdventureDetail(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets AdventureDetail
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdventureDetail(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsAdventureDetail>> {
            return AdventureDetailApiFp(configuration).getAdventureDetail(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists AdventureDetails
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAdventureDetails(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsAdventureDetail>> {
            return AdventureDetailApiFp(configuration).listAdventureDetails(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates AdventureDetail
         * @param {number} id Id
         * @param {ModelsAdventureDetail} adventureDetail AdventureDetail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAdventureDetail(id: number, adventureDetail: ModelsAdventureDetail, options?: any): AxiosPromise<Array<ModelsAdventureDetail>> {
            return AdventureDetailApiFp(configuration).updateAdventureDetail(id, adventureDetail, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createAdventureDetail operation in AdventureDetailApi.
 * @export
 * @interface AdventureDetailApiCreateAdventureDetailRequest
 */
export interface AdventureDetailApiCreateAdventureDetailRequest {
    /**
     * AdventureDetail
     * @type {ModelsAdventureDetail}
     * @memberof AdventureDetailApiCreateAdventureDetail
     */
    readonly adventureDetail: ModelsAdventureDetail
}

/**
 * Request parameters for deleteAdventureDetail operation in AdventureDetailApi.
 * @export
 * @interface AdventureDetailApiDeleteAdventureDetailRequest
 */
export interface AdventureDetailApiDeleteAdventureDetailRequest {
    /**
     * Id
     * @type {number}
     * @memberof AdventureDetailApiDeleteAdventureDetail
     */
    readonly id: number
}

/**
 * Request parameters for getAdventureDetail operation in AdventureDetailApi.
 * @export
 * @interface AdventureDetailApiGetAdventureDetailRequest
 */
export interface AdventureDetailApiGetAdventureDetailRequest {
    /**
     * Id
     * @type {number}
     * @memberof AdventureDetailApiGetAdventureDetail
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof AdventureDetailApiGetAdventureDetail
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof AdventureDetailApiGetAdventureDetail
     */
    readonly select?: string
}

/**
 * Request parameters for listAdventureDetails operation in AdventureDetailApi.
 * @export
 * @interface AdventureDetailApiListAdventureDetailsRequest
 */
export interface AdventureDetailApiListAdventureDetailsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof AdventureDetailApiListAdventureDetails
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof AdventureDetailApiListAdventureDetails
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof AdventureDetailApiListAdventureDetails
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof AdventureDetailApiListAdventureDetails
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof AdventureDetailApiListAdventureDetails
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof AdventureDetailApiListAdventureDetails
     */
    readonly select?: string
}

/**
 * Request parameters for updateAdventureDetail operation in AdventureDetailApi.
 * @export
 * @interface AdventureDetailApiUpdateAdventureDetailRequest
 */
export interface AdventureDetailApiUpdateAdventureDetailRequest {
    /**
     * Id
     * @type {number}
     * @memberof AdventureDetailApiUpdateAdventureDetail
     */
    readonly id: number

    /**
     * AdventureDetail
     * @type {ModelsAdventureDetail}
     * @memberof AdventureDetailApiUpdateAdventureDetail
     */
    readonly adventureDetail: ModelsAdventureDetail
}

/**
 * AdventureDetailApi - object-oriented interface
 * @export
 * @class AdventureDetailApi
 * @extends {BaseAPI}
 */
export class AdventureDetailApi extends BaseAPI {
    /**
     * 
     * @summary Creates AdventureDetail
     * @param {AdventureDetailApiCreateAdventureDetailRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdventureDetailApi
     */
    public createAdventureDetail(requestParameters: AdventureDetailApiCreateAdventureDetailRequest, options?: any) {
        return AdventureDetailApiFp(this.configuration).createAdventureDetail(requestParameters.adventureDetail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes AdventureDetail
     * @param {AdventureDetailApiDeleteAdventureDetailRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdventureDetailApi
     */
    public deleteAdventureDetail(requestParameters: AdventureDetailApiDeleteAdventureDetailRequest, options?: any) {
        return AdventureDetailApiFp(this.configuration).deleteAdventureDetail(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets AdventureDetail
     * @param {AdventureDetailApiGetAdventureDetailRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdventureDetailApi
     */
    public getAdventureDetail(requestParameters: AdventureDetailApiGetAdventureDetailRequest, options?: any) {
        return AdventureDetailApiFp(this.configuration).getAdventureDetail(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists AdventureDetails
     * @param {AdventureDetailApiListAdventureDetailsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdventureDetailApi
     */
    public listAdventureDetails(requestParameters: AdventureDetailApiListAdventureDetailsRequest = {}, options?: any) {
        return AdventureDetailApiFp(this.configuration).listAdventureDetails(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates AdventureDetail
     * @param {AdventureDetailApiUpdateAdventureDetailRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdventureDetailApi
     */
    public updateAdventureDetail(requestParameters: AdventureDetailApiUpdateAdventureDetailRequest, options?: any) {
        return AdventureDetailApiFp(this.configuration).updateAdventureDetail(requestParameters.id, requestParameters.adventureDetail, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AdventureMemberApi - axios parameter creator
 * @export
 */
export const AdventureMemberApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates AdventureMember
         * @param {ModelsAdventureMember} adventureMember AdventureMember
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAdventureMember: async (adventureMember: ModelsAdventureMember, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'adventureMember' is not null or undefined
            if (adventureMember === null || adventureMember === undefined) {
                throw new RequiredError('adventureMember','Required parameter adventureMember was null or undefined when calling createAdventureMember.');
            }
            const localVarPath = `/adventure_member`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof adventureMember !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(adventureMember !== undefined ? adventureMember : {})
                : (adventureMember || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes AdventureMember
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAdventureMember: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteAdventureMember.');
            }
            const localVarPath = `/adventure_member/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets AdventureMember
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdventureMember: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getAdventureMember.');
            }
            const localVarPath = `/adventure_member/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists AdventureMembers
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAdventureMembers: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/adventure_members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates AdventureMember
         * @param {number} id Id
         * @param {ModelsAdventureMember} adventureMember AdventureMember
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAdventureMember: async (id: number, adventureMember: ModelsAdventureMember, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateAdventureMember.');
            }
            // verify required parameter 'adventureMember' is not null or undefined
            if (adventureMember === null || adventureMember === undefined) {
                throw new RequiredError('adventureMember','Required parameter adventureMember was null or undefined when calling updateAdventureMember.');
            }
            const localVarPath = `/adventure_member/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof adventureMember !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(adventureMember !== undefined ? adventureMember : {})
                : (adventureMember || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdventureMemberApi - functional programming interface
 * @export
 */
export const AdventureMemberApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates AdventureMember
         * @param {ModelsAdventureMember} adventureMember AdventureMember
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAdventureMember(adventureMember: ModelsAdventureMember, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAdventureMember>>> {
            const localVarAxiosArgs = await AdventureMemberApiAxiosParamCreator(configuration).createAdventureMember(adventureMember, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes AdventureMember
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAdventureMember(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await AdventureMemberApiAxiosParamCreator(configuration).deleteAdventureMember(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets AdventureMember
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAdventureMember(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAdventureMember>>> {
            const localVarAxiosArgs = await AdventureMemberApiAxiosParamCreator(configuration).getAdventureMember(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists AdventureMembers
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAdventureMembers(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAdventureMember>>> {
            const localVarAxiosArgs = await AdventureMemberApiAxiosParamCreator(configuration).listAdventureMembers(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates AdventureMember
         * @param {number} id Id
         * @param {ModelsAdventureMember} adventureMember AdventureMember
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAdventureMember(id: number, adventureMember: ModelsAdventureMember, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAdventureMember>>> {
            const localVarAxiosArgs = await AdventureMemberApiAxiosParamCreator(configuration).updateAdventureMember(id, adventureMember, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AdventureMemberApi - factory interface
 * @export
 */
export const AdventureMemberApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates AdventureMember
         * @param {ModelsAdventureMember} adventureMember AdventureMember
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAdventureMember(adventureMember: ModelsAdventureMember, options?: any): AxiosPromise<Array<ModelsAdventureMember>> {
            return AdventureMemberApiFp(configuration).createAdventureMember(adventureMember, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes AdventureMember
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAdventureMember(id: number, options?: any): AxiosPromise<string> {
            return AdventureMemberApiFp(configuration).deleteAdventureMember(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets AdventureMember
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdventureMember(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsAdventureMember>> {
            return AdventureMemberApiFp(configuration).getAdventureMember(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists AdventureMembers
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAdventureMembers(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsAdventureMember>> {
            return AdventureMemberApiFp(configuration).listAdventureMembers(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates AdventureMember
         * @param {number} id Id
         * @param {ModelsAdventureMember} adventureMember AdventureMember
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAdventureMember(id: number, adventureMember: ModelsAdventureMember, options?: any): AxiosPromise<Array<ModelsAdventureMember>> {
            return AdventureMemberApiFp(configuration).updateAdventureMember(id, adventureMember, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createAdventureMember operation in AdventureMemberApi.
 * @export
 * @interface AdventureMemberApiCreateAdventureMemberRequest
 */
export interface AdventureMemberApiCreateAdventureMemberRequest {
    /**
     * AdventureMember
     * @type {ModelsAdventureMember}
     * @memberof AdventureMemberApiCreateAdventureMember
     */
    readonly adventureMember: ModelsAdventureMember
}

/**
 * Request parameters for deleteAdventureMember operation in AdventureMemberApi.
 * @export
 * @interface AdventureMemberApiDeleteAdventureMemberRequest
 */
export interface AdventureMemberApiDeleteAdventureMemberRequest {
    /**
     * Id
     * @type {number}
     * @memberof AdventureMemberApiDeleteAdventureMember
     */
    readonly id: number
}

/**
 * Request parameters for getAdventureMember operation in AdventureMemberApi.
 * @export
 * @interface AdventureMemberApiGetAdventureMemberRequest
 */
export interface AdventureMemberApiGetAdventureMemberRequest {
    /**
     * Id
     * @type {number}
     * @memberof AdventureMemberApiGetAdventureMember
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof AdventureMemberApiGetAdventureMember
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof AdventureMemberApiGetAdventureMember
     */
    readonly select?: string
}

/**
 * Request parameters for listAdventureMembers operation in AdventureMemberApi.
 * @export
 * @interface AdventureMemberApiListAdventureMembersRequest
 */
export interface AdventureMemberApiListAdventureMembersRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof AdventureMemberApiListAdventureMembers
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof AdventureMemberApiListAdventureMembers
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof AdventureMemberApiListAdventureMembers
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof AdventureMemberApiListAdventureMembers
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof AdventureMemberApiListAdventureMembers
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof AdventureMemberApiListAdventureMembers
     */
    readonly select?: string
}

/**
 * Request parameters for updateAdventureMember operation in AdventureMemberApi.
 * @export
 * @interface AdventureMemberApiUpdateAdventureMemberRequest
 */
export interface AdventureMemberApiUpdateAdventureMemberRequest {
    /**
     * Id
     * @type {number}
     * @memberof AdventureMemberApiUpdateAdventureMember
     */
    readonly id: number

    /**
     * AdventureMember
     * @type {ModelsAdventureMember}
     * @memberof AdventureMemberApiUpdateAdventureMember
     */
    readonly adventureMember: ModelsAdventureMember
}

/**
 * AdventureMemberApi - object-oriented interface
 * @export
 * @class AdventureMemberApi
 * @extends {BaseAPI}
 */
export class AdventureMemberApi extends BaseAPI {
    /**
     * 
     * @summary Creates AdventureMember
     * @param {AdventureMemberApiCreateAdventureMemberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdventureMemberApi
     */
    public createAdventureMember(requestParameters: AdventureMemberApiCreateAdventureMemberRequest, options?: any) {
        return AdventureMemberApiFp(this.configuration).createAdventureMember(requestParameters.adventureMember, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes AdventureMember
     * @param {AdventureMemberApiDeleteAdventureMemberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdventureMemberApi
     */
    public deleteAdventureMember(requestParameters: AdventureMemberApiDeleteAdventureMemberRequest, options?: any) {
        return AdventureMemberApiFp(this.configuration).deleteAdventureMember(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets AdventureMember
     * @param {AdventureMemberApiGetAdventureMemberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdventureMemberApi
     */
    public getAdventureMember(requestParameters: AdventureMemberApiGetAdventureMemberRequest, options?: any) {
        return AdventureMemberApiFp(this.configuration).getAdventureMember(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists AdventureMembers
     * @param {AdventureMemberApiListAdventureMembersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdventureMemberApi
     */
    public listAdventureMembers(requestParameters: AdventureMemberApiListAdventureMembersRequest = {}, options?: any) {
        return AdventureMemberApiFp(this.configuration).listAdventureMembers(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates AdventureMember
     * @param {AdventureMemberApiUpdateAdventureMemberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdventureMemberApi
     */
    public updateAdventureMember(requestParameters: AdventureMemberApiUpdateAdventureMemberRequest, options?: any) {
        return AdventureMemberApiFp(this.configuration).updateAdventureMember(requestParameters.id, requestParameters.adventureMember, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AdventureTemplateApi - axios parameter creator
 * @export
 */
export const AdventureTemplateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates AdventureTemplate
         * @param {ModelsAdventureTemplate} adventureTemplate AdventureTemplate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAdventureTemplate: async (adventureTemplate: ModelsAdventureTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'adventureTemplate' is not null or undefined
            if (adventureTemplate === null || adventureTemplate === undefined) {
                throw new RequiredError('adventureTemplate','Required parameter adventureTemplate was null or undefined when calling createAdventureTemplate.');
            }
            const localVarPath = `/adventure_template`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof adventureTemplate !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(adventureTemplate !== undefined ? adventureTemplate : {})
                : (adventureTemplate || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes AdventureTemplate
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAdventureTemplate: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteAdventureTemplate.');
            }
            const localVarPath = `/adventure_template/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets AdventureTemplate
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdventureTemplate: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getAdventureTemplate.');
            }
            const localVarPath = `/adventure_template/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists AdventureTemplates
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAdventureTemplates: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/adventure_templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates AdventureTemplate
         * @param {number} id Id
         * @param {ModelsAdventureTemplate} adventureTemplate AdventureTemplate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAdventureTemplate: async (id: number, adventureTemplate: ModelsAdventureTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateAdventureTemplate.');
            }
            // verify required parameter 'adventureTemplate' is not null or undefined
            if (adventureTemplate === null || adventureTemplate === undefined) {
                throw new RequiredError('adventureTemplate','Required parameter adventureTemplate was null or undefined when calling updateAdventureTemplate.');
            }
            const localVarPath = `/adventure_template/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof adventureTemplate !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(adventureTemplate !== undefined ? adventureTemplate : {})
                : (adventureTemplate || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdventureTemplateApi - functional programming interface
 * @export
 */
export const AdventureTemplateApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates AdventureTemplate
         * @param {ModelsAdventureTemplate} adventureTemplate AdventureTemplate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAdventureTemplate(adventureTemplate: ModelsAdventureTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAdventureTemplate>>> {
            const localVarAxiosArgs = await AdventureTemplateApiAxiosParamCreator(configuration).createAdventureTemplate(adventureTemplate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes AdventureTemplate
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAdventureTemplate(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await AdventureTemplateApiAxiosParamCreator(configuration).deleteAdventureTemplate(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets AdventureTemplate
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAdventureTemplate(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAdventureTemplate>>> {
            const localVarAxiosArgs = await AdventureTemplateApiAxiosParamCreator(configuration).getAdventureTemplate(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists AdventureTemplates
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAdventureTemplates(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAdventureTemplate>>> {
            const localVarAxiosArgs = await AdventureTemplateApiAxiosParamCreator(configuration).listAdventureTemplates(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates AdventureTemplate
         * @param {number} id Id
         * @param {ModelsAdventureTemplate} adventureTemplate AdventureTemplate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAdventureTemplate(id: number, adventureTemplate: ModelsAdventureTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAdventureTemplate>>> {
            const localVarAxiosArgs = await AdventureTemplateApiAxiosParamCreator(configuration).updateAdventureTemplate(id, adventureTemplate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AdventureTemplateApi - factory interface
 * @export
 */
export const AdventureTemplateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates AdventureTemplate
         * @param {ModelsAdventureTemplate} adventureTemplate AdventureTemplate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAdventureTemplate(adventureTemplate: ModelsAdventureTemplate, options?: any): AxiosPromise<Array<ModelsAdventureTemplate>> {
            return AdventureTemplateApiFp(configuration).createAdventureTemplate(adventureTemplate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes AdventureTemplate
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAdventureTemplate(id: number, options?: any): AxiosPromise<string> {
            return AdventureTemplateApiFp(configuration).deleteAdventureTemplate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets AdventureTemplate
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdventureTemplate(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsAdventureTemplate>> {
            return AdventureTemplateApiFp(configuration).getAdventureTemplate(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists AdventureTemplates
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAdventureTemplates(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsAdventureTemplate>> {
            return AdventureTemplateApiFp(configuration).listAdventureTemplates(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates AdventureTemplate
         * @param {number} id Id
         * @param {ModelsAdventureTemplate} adventureTemplate AdventureTemplate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAdventureTemplate(id: number, adventureTemplate: ModelsAdventureTemplate, options?: any): AxiosPromise<Array<ModelsAdventureTemplate>> {
            return AdventureTemplateApiFp(configuration).updateAdventureTemplate(id, adventureTemplate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createAdventureTemplate operation in AdventureTemplateApi.
 * @export
 * @interface AdventureTemplateApiCreateAdventureTemplateRequest
 */
export interface AdventureTemplateApiCreateAdventureTemplateRequest {
    /**
     * AdventureTemplate
     * @type {ModelsAdventureTemplate}
     * @memberof AdventureTemplateApiCreateAdventureTemplate
     */
    readonly adventureTemplate: ModelsAdventureTemplate
}

/**
 * Request parameters for deleteAdventureTemplate operation in AdventureTemplateApi.
 * @export
 * @interface AdventureTemplateApiDeleteAdventureTemplateRequest
 */
export interface AdventureTemplateApiDeleteAdventureTemplateRequest {
    /**
     * Id
     * @type {number}
     * @memberof AdventureTemplateApiDeleteAdventureTemplate
     */
    readonly id: number
}

/**
 * Request parameters for getAdventureTemplate operation in AdventureTemplateApi.
 * @export
 * @interface AdventureTemplateApiGetAdventureTemplateRequest
 */
export interface AdventureTemplateApiGetAdventureTemplateRequest {
    /**
     * Id
     * @type {number}
     * @memberof AdventureTemplateApiGetAdventureTemplate
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof AdventureTemplateApiGetAdventureTemplate
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof AdventureTemplateApiGetAdventureTemplate
     */
    readonly select?: string
}

/**
 * Request parameters for listAdventureTemplates operation in AdventureTemplateApi.
 * @export
 * @interface AdventureTemplateApiListAdventureTemplatesRequest
 */
export interface AdventureTemplateApiListAdventureTemplatesRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof AdventureTemplateApiListAdventureTemplates
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof AdventureTemplateApiListAdventureTemplates
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof AdventureTemplateApiListAdventureTemplates
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof AdventureTemplateApiListAdventureTemplates
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof AdventureTemplateApiListAdventureTemplates
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof AdventureTemplateApiListAdventureTemplates
     */
    readonly select?: string
}

/**
 * Request parameters for updateAdventureTemplate operation in AdventureTemplateApi.
 * @export
 * @interface AdventureTemplateApiUpdateAdventureTemplateRequest
 */
export interface AdventureTemplateApiUpdateAdventureTemplateRequest {
    /**
     * Id
     * @type {number}
     * @memberof AdventureTemplateApiUpdateAdventureTemplate
     */
    readonly id: number

    /**
     * AdventureTemplate
     * @type {ModelsAdventureTemplate}
     * @memberof AdventureTemplateApiUpdateAdventureTemplate
     */
    readonly adventureTemplate: ModelsAdventureTemplate
}

/**
 * AdventureTemplateApi - object-oriented interface
 * @export
 * @class AdventureTemplateApi
 * @extends {BaseAPI}
 */
export class AdventureTemplateApi extends BaseAPI {
    /**
     * 
     * @summary Creates AdventureTemplate
     * @param {AdventureTemplateApiCreateAdventureTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdventureTemplateApi
     */
    public createAdventureTemplate(requestParameters: AdventureTemplateApiCreateAdventureTemplateRequest, options?: any) {
        return AdventureTemplateApiFp(this.configuration).createAdventureTemplate(requestParameters.adventureTemplate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes AdventureTemplate
     * @param {AdventureTemplateApiDeleteAdventureTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdventureTemplateApi
     */
    public deleteAdventureTemplate(requestParameters: AdventureTemplateApiDeleteAdventureTemplateRequest, options?: any) {
        return AdventureTemplateApiFp(this.configuration).deleteAdventureTemplate(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets AdventureTemplate
     * @param {AdventureTemplateApiGetAdventureTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdventureTemplateApi
     */
    public getAdventureTemplate(requestParameters: AdventureTemplateApiGetAdventureTemplateRequest, options?: any) {
        return AdventureTemplateApiFp(this.configuration).getAdventureTemplate(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists AdventureTemplates
     * @param {AdventureTemplateApiListAdventureTemplatesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdventureTemplateApi
     */
    public listAdventureTemplates(requestParameters: AdventureTemplateApiListAdventureTemplatesRequest = {}, options?: any) {
        return AdventureTemplateApiFp(this.configuration).listAdventureTemplates(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates AdventureTemplate
     * @param {AdventureTemplateApiUpdateAdventureTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdventureTemplateApi
     */
    public updateAdventureTemplate(requestParameters: AdventureTemplateApiUpdateAdventureTemplateRequest, options?: any) {
        return AdventureTemplateApiFp(this.configuration).updateAdventureTemplate(requestParameters.id, requestParameters.adventureTemplate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AdventureTemplateEntryApi - axios parameter creator
 * @export
 */
export const AdventureTemplateEntryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates AdventureTemplateEntry
         * @param {ModelsAdventureTemplateEntry} adventureTemplateEntry AdventureTemplateEntry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAdventureTemplateEntry: async (adventureTemplateEntry: ModelsAdventureTemplateEntry, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'adventureTemplateEntry' is not null or undefined
            if (adventureTemplateEntry === null || adventureTemplateEntry === undefined) {
                throw new RequiredError('adventureTemplateEntry','Required parameter adventureTemplateEntry was null or undefined when calling createAdventureTemplateEntry.');
            }
            const localVarPath = `/adventure_template_entry`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof adventureTemplateEntry !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(adventureTemplateEntry !== undefined ? adventureTemplateEntry : {})
                : (adventureTemplateEntry || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes AdventureTemplateEntry
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAdventureTemplateEntry: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteAdventureTemplateEntry.');
            }
            const localVarPath = `/adventure_template_entry/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets AdventureTemplateEntry
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdventureTemplateEntry: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getAdventureTemplateEntry.');
            }
            const localVarPath = `/adventure_template_entry/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists AdventureTemplateEntries
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAdventureTemplateEntries: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/adventure_template_entries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates AdventureTemplateEntry
         * @param {number} id Id
         * @param {ModelsAdventureTemplateEntry} adventureTemplateEntry AdventureTemplateEntry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAdventureTemplateEntry: async (id: number, adventureTemplateEntry: ModelsAdventureTemplateEntry, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateAdventureTemplateEntry.');
            }
            // verify required parameter 'adventureTemplateEntry' is not null or undefined
            if (adventureTemplateEntry === null || adventureTemplateEntry === undefined) {
                throw new RequiredError('adventureTemplateEntry','Required parameter adventureTemplateEntry was null or undefined when calling updateAdventureTemplateEntry.');
            }
            const localVarPath = `/adventure_template_entry/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof adventureTemplateEntry !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(adventureTemplateEntry !== undefined ? adventureTemplateEntry : {})
                : (adventureTemplateEntry || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdventureTemplateEntryApi - functional programming interface
 * @export
 */
export const AdventureTemplateEntryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates AdventureTemplateEntry
         * @param {ModelsAdventureTemplateEntry} adventureTemplateEntry AdventureTemplateEntry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAdventureTemplateEntry(adventureTemplateEntry: ModelsAdventureTemplateEntry, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAdventureTemplateEntry>>> {
            const localVarAxiosArgs = await AdventureTemplateEntryApiAxiosParamCreator(configuration).createAdventureTemplateEntry(adventureTemplateEntry, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes AdventureTemplateEntry
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAdventureTemplateEntry(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await AdventureTemplateEntryApiAxiosParamCreator(configuration).deleteAdventureTemplateEntry(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets AdventureTemplateEntry
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAdventureTemplateEntry(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAdventureTemplateEntry>>> {
            const localVarAxiosArgs = await AdventureTemplateEntryApiAxiosParamCreator(configuration).getAdventureTemplateEntry(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists AdventureTemplateEntries
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAdventureTemplateEntries(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAdventureTemplateEntry>>> {
            const localVarAxiosArgs = await AdventureTemplateEntryApiAxiosParamCreator(configuration).listAdventureTemplateEntries(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates AdventureTemplateEntry
         * @param {number} id Id
         * @param {ModelsAdventureTemplateEntry} adventureTemplateEntry AdventureTemplateEntry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAdventureTemplateEntry(id: number, adventureTemplateEntry: ModelsAdventureTemplateEntry, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAdventureTemplateEntry>>> {
            const localVarAxiosArgs = await AdventureTemplateEntryApiAxiosParamCreator(configuration).updateAdventureTemplateEntry(id, adventureTemplateEntry, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AdventureTemplateEntryApi - factory interface
 * @export
 */
export const AdventureTemplateEntryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates AdventureTemplateEntry
         * @param {ModelsAdventureTemplateEntry} adventureTemplateEntry AdventureTemplateEntry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAdventureTemplateEntry(adventureTemplateEntry: ModelsAdventureTemplateEntry, options?: any): AxiosPromise<Array<ModelsAdventureTemplateEntry>> {
            return AdventureTemplateEntryApiFp(configuration).createAdventureTemplateEntry(adventureTemplateEntry, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes AdventureTemplateEntry
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAdventureTemplateEntry(id: number, options?: any): AxiosPromise<string> {
            return AdventureTemplateEntryApiFp(configuration).deleteAdventureTemplateEntry(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets AdventureTemplateEntry
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdventureTemplateEntry(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsAdventureTemplateEntry>> {
            return AdventureTemplateEntryApiFp(configuration).getAdventureTemplateEntry(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists AdventureTemplateEntries
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAdventureTemplateEntries(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsAdventureTemplateEntry>> {
            return AdventureTemplateEntryApiFp(configuration).listAdventureTemplateEntries(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates AdventureTemplateEntry
         * @param {number} id Id
         * @param {ModelsAdventureTemplateEntry} adventureTemplateEntry AdventureTemplateEntry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAdventureTemplateEntry(id: number, adventureTemplateEntry: ModelsAdventureTemplateEntry, options?: any): AxiosPromise<Array<ModelsAdventureTemplateEntry>> {
            return AdventureTemplateEntryApiFp(configuration).updateAdventureTemplateEntry(id, adventureTemplateEntry, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createAdventureTemplateEntry operation in AdventureTemplateEntryApi.
 * @export
 * @interface AdventureTemplateEntryApiCreateAdventureTemplateEntryRequest
 */
export interface AdventureTemplateEntryApiCreateAdventureTemplateEntryRequest {
    /**
     * AdventureTemplateEntry
     * @type {ModelsAdventureTemplateEntry}
     * @memberof AdventureTemplateEntryApiCreateAdventureTemplateEntry
     */
    readonly adventureTemplateEntry: ModelsAdventureTemplateEntry
}

/**
 * Request parameters for deleteAdventureTemplateEntry operation in AdventureTemplateEntryApi.
 * @export
 * @interface AdventureTemplateEntryApiDeleteAdventureTemplateEntryRequest
 */
export interface AdventureTemplateEntryApiDeleteAdventureTemplateEntryRequest {
    /**
     * Id
     * @type {number}
     * @memberof AdventureTemplateEntryApiDeleteAdventureTemplateEntry
     */
    readonly id: number
}

/**
 * Request parameters for getAdventureTemplateEntry operation in AdventureTemplateEntryApi.
 * @export
 * @interface AdventureTemplateEntryApiGetAdventureTemplateEntryRequest
 */
export interface AdventureTemplateEntryApiGetAdventureTemplateEntryRequest {
    /**
     * Id
     * @type {number}
     * @memberof AdventureTemplateEntryApiGetAdventureTemplateEntry
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof AdventureTemplateEntryApiGetAdventureTemplateEntry
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof AdventureTemplateEntryApiGetAdventureTemplateEntry
     */
    readonly select?: string
}

/**
 * Request parameters for listAdventureTemplateEntries operation in AdventureTemplateEntryApi.
 * @export
 * @interface AdventureTemplateEntryApiListAdventureTemplateEntriesRequest
 */
export interface AdventureTemplateEntryApiListAdventureTemplateEntriesRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof AdventureTemplateEntryApiListAdventureTemplateEntries
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof AdventureTemplateEntryApiListAdventureTemplateEntries
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof AdventureTemplateEntryApiListAdventureTemplateEntries
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof AdventureTemplateEntryApiListAdventureTemplateEntries
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof AdventureTemplateEntryApiListAdventureTemplateEntries
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof AdventureTemplateEntryApiListAdventureTemplateEntries
     */
    readonly select?: string
}

/**
 * Request parameters for updateAdventureTemplateEntry operation in AdventureTemplateEntryApi.
 * @export
 * @interface AdventureTemplateEntryApiUpdateAdventureTemplateEntryRequest
 */
export interface AdventureTemplateEntryApiUpdateAdventureTemplateEntryRequest {
    /**
     * Id
     * @type {number}
     * @memberof AdventureTemplateEntryApiUpdateAdventureTemplateEntry
     */
    readonly id: number

    /**
     * AdventureTemplateEntry
     * @type {ModelsAdventureTemplateEntry}
     * @memberof AdventureTemplateEntryApiUpdateAdventureTemplateEntry
     */
    readonly adventureTemplateEntry: ModelsAdventureTemplateEntry
}

/**
 * AdventureTemplateEntryApi - object-oriented interface
 * @export
 * @class AdventureTemplateEntryApi
 * @extends {BaseAPI}
 */
export class AdventureTemplateEntryApi extends BaseAPI {
    /**
     * 
     * @summary Creates AdventureTemplateEntry
     * @param {AdventureTemplateEntryApiCreateAdventureTemplateEntryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdventureTemplateEntryApi
     */
    public createAdventureTemplateEntry(requestParameters: AdventureTemplateEntryApiCreateAdventureTemplateEntryRequest, options?: any) {
        return AdventureTemplateEntryApiFp(this.configuration).createAdventureTemplateEntry(requestParameters.adventureTemplateEntry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes AdventureTemplateEntry
     * @param {AdventureTemplateEntryApiDeleteAdventureTemplateEntryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdventureTemplateEntryApi
     */
    public deleteAdventureTemplateEntry(requestParameters: AdventureTemplateEntryApiDeleteAdventureTemplateEntryRequest, options?: any) {
        return AdventureTemplateEntryApiFp(this.configuration).deleteAdventureTemplateEntry(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets AdventureTemplateEntry
     * @param {AdventureTemplateEntryApiGetAdventureTemplateEntryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdventureTemplateEntryApi
     */
    public getAdventureTemplateEntry(requestParameters: AdventureTemplateEntryApiGetAdventureTemplateEntryRequest, options?: any) {
        return AdventureTemplateEntryApiFp(this.configuration).getAdventureTemplateEntry(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists AdventureTemplateEntries
     * @param {AdventureTemplateEntryApiListAdventureTemplateEntriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdventureTemplateEntryApi
     */
    public listAdventureTemplateEntries(requestParameters: AdventureTemplateEntryApiListAdventureTemplateEntriesRequest = {}, options?: any) {
        return AdventureTemplateEntryApiFp(this.configuration).listAdventureTemplateEntries(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates AdventureTemplateEntry
     * @param {AdventureTemplateEntryApiUpdateAdventureTemplateEntryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdventureTemplateEntryApi
     */
    public updateAdventureTemplateEntry(requestParameters: AdventureTemplateEntryApiUpdateAdventureTemplateEntryRequest, options?: any) {
        return AdventureTemplateEntryApiFp(this.configuration).updateAdventureTemplateEntry(requestParameters.id, requestParameters.adventureTemplateEntry, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AdventureTemplateEntryFlavorApi - axios parameter creator
 * @export
 */
export const AdventureTemplateEntryFlavorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates AdventureTemplateEntryFlavor
         * @param {ModelsAdventureTemplateEntryFlavor} adventureTemplateEntryFlavor AdventureTemplateEntryFlavor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAdventureTemplateEntryFlavor: async (adventureTemplateEntryFlavor: ModelsAdventureTemplateEntryFlavor, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'adventureTemplateEntryFlavor' is not null or undefined
            if (adventureTemplateEntryFlavor === null || adventureTemplateEntryFlavor === undefined) {
                throw new RequiredError('adventureTemplateEntryFlavor','Required parameter adventureTemplateEntryFlavor was null or undefined when calling createAdventureTemplateEntryFlavor.');
            }
            const localVarPath = `/adventure_template_entry_flavor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof adventureTemplateEntryFlavor !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(adventureTemplateEntryFlavor !== undefined ? adventureTemplateEntryFlavor : {})
                : (adventureTemplateEntryFlavor || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes AdventureTemplateEntryFlavor
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAdventureTemplateEntryFlavor: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteAdventureTemplateEntryFlavor.');
            }
            const localVarPath = `/adventure_template_entry_flavor/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets AdventureTemplateEntryFlavor
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdventureTemplateEntryFlavor: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getAdventureTemplateEntryFlavor.');
            }
            const localVarPath = `/adventure_template_entry_flavor/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists AdventureTemplateEntryFlavors
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAdventureTemplateEntryFlavors: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/adventure_template_entry_flavors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates AdventureTemplateEntryFlavor
         * @param {number} id Id
         * @param {ModelsAdventureTemplateEntryFlavor} adventureTemplateEntryFlavor AdventureTemplateEntryFlavor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAdventureTemplateEntryFlavor: async (id: number, adventureTemplateEntryFlavor: ModelsAdventureTemplateEntryFlavor, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateAdventureTemplateEntryFlavor.');
            }
            // verify required parameter 'adventureTemplateEntryFlavor' is not null or undefined
            if (adventureTemplateEntryFlavor === null || adventureTemplateEntryFlavor === undefined) {
                throw new RequiredError('adventureTemplateEntryFlavor','Required parameter adventureTemplateEntryFlavor was null or undefined when calling updateAdventureTemplateEntryFlavor.');
            }
            const localVarPath = `/adventure_template_entry_flavor/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof adventureTemplateEntryFlavor !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(adventureTemplateEntryFlavor !== undefined ? adventureTemplateEntryFlavor : {})
                : (adventureTemplateEntryFlavor || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdventureTemplateEntryFlavorApi - functional programming interface
 * @export
 */
export const AdventureTemplateEntryFlavorApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates AdventureTemplateEntryFlavor
         * @param {ModelsAdventureTemplateEntryFlavor} adventureTemplateEntryFlavor AdventureTemplateEntryFlavor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAdventureTemplateEntryFlavor(adventureTemplateEntryFlavor: ModelsAdventureTemplateEntryFlavor, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAdventureTemplateEntryFlavor>>> {
            const localVarAxiosArgs = await AdventureTemplateEntryFlavorApiAxiosParamCreator(configuration).createAdventureTemplateEntryFlavor(adventureTemplateEntryFlavor, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes AdventureTemplateEntryFlavor
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAdventureTemplateEntryFlavor(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await AdventureTemplateEntryFlavorApiAxiosParamCreator(configuration).deleteAdventureTemplateEntryFlavor(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets AdventureTemplateEntryFlavor
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAdventureTemplateEntryFlavor(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAdventureTemplateEntryFlavor>>> {
            const localVarAxiosArgs = await AdventureTemplateEntryFlavorApiAxiosParamCreator(configuration).getAdventureTemplateEntryFlavor(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists AdventureTemplateEntryFlavors
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAdventureTemplateEntryFlavors(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAdventureTemplateEntryFlavor>>> {
            const localVarAxiosArgs = await AdventureTemplateEntryFlavorApiAxiosParamCreator(configuration).listAdventureTemplateEntryFlavors(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates AdventureTemplateEntryFlavor
         * @param {number} id Id
         * @param {ModelsAdventureTemplateEntryFlavor} adventureTemplateEntryFlavor AdventureTemplateEntryFlavor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAdventureTemplateEntryFlavor(id: number, adventureTemplateEntryFlavor: ModelsAdventureTemplateEntryFlavor, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAdventureTemplateEntryFlavor>>> {
            const localVarAxiosArgs = await AdventureTemplateEntryFlavorApiAxiosParamCreator(configuration).updateAdventureTemplateEntryFlavor(id, adventureTemplateEntryFlavor, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AdventureTemplateEntryFlavorApi - factory interface
 * @export
 */
export const AdventureTemplateEntryFlavorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates AdventureTemplateEntryFlavor
         * @param {ModelsAdventureTemplateEntryFlavor} adventureTemplateEntryFlavor AdventureTemplateEntryFlavor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAdventureTemplateEntryFlavor(adventureTemplateEntryFlavor: ModelsAdventureTemplateEntryFlavor, options?: any): AxiosPromise<Array<ModelsAdventureTemplateEntryFlavor>> {
            return AdventureTemplateEntryFlavorApiFp(configuration).createAdventureTemplateEntryFlavor(adventureTemplateEntryFlavor, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes AdventureTemplateEntryFlavor
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAdventureTemplateEntryFlavor(id: number, options?: any): AxiosPromise<string> {
            return AdventureTemplateEntryFlavorApiFp(configuration).deleteAdventureTemplateEntryFlavor(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets AdventureTemplateEntryFlavor
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdventureTemplateEntryFlavor(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsAdventureTemplateEntryFlavor>> {
            return AdventureTemplateEntryFlavorApiFp(configuration).getAdventureTemplateEntryFlavor(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists AdventureTemplateEntryFlavors
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAdventureTemplateEntryFlavors(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsAdventureTemplateEntryFlavor>> {
            return AdventureTemplateEntryFlavorApiFp(configuration).listAdventureTemplateEntryFlavors(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates AdventureTemplateEntryFlavor
         * @param {number} id Id
         * @param {ModelsAdventureTemplateEntryFlavor} adventureTemplateEntryFlavor AdventureTemplateEntryFlavor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAdventureTemplateEntryFlavor(id: number, adventureTemplateEntryFlavor: ModelsAdventureTemplateEntryFlavor, options?: any): AxiosPromise<Array<ModelsAdventureTemplateEntryFlavor>> {
            return AdventureTemplateEntryFlavorApiFp(configuration).updateAdventureTemplateEntryFlavor(id, adventureTemplateEntryFlavor, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createAdventureTemplateEntryFlavor operation in AdventureTemplateEntryFlavorApi.
 * @export
 * @interface AdventureTemplateEntryFlavorApiCreateAdventureTemplateEntryFlavorRequest
 */
export interface AdventureTemplateEntryFlavorApiCreateAdventureTemplateEntryFlavorRequest {
    /**
     * AdventureTemplateEntryFlavor
     * @type {ModelsAdventureTemplateEntryFlavor}
     * @memberof AdventureTemplateEntryFlavorApiCreateAdventureTemplateEntryFlavor
     */
    readonly adventureTemplateEntryFlavor: ModelsAdventureTemplateEntryFlavor
}

/**
 * Request parameters for deleteAdventureTemplateEntryFlavor operation in AdventureTemplateEntryFlavorApi.
 * @export
 * @interface AdventureTemplateEntryFlavorApiDeleteAdventureTemplateEntryFlavorRequest
 */
export interface AdventureTemplateEntryFlavorApiDeleteAdventureTemplateEntryFlavorRequest {
    /**
     * Id
     * @type {number}
     * @memberof AdventureTemplateEntryFlavorApiDeleteAdventureTemplateEntryFlavor
     */
    readonly id: number
}

/**
 * Request parameters for getAdventureTemplateEntryFlavor operation in AdventureTemplateEntryFlavorApi.
 * @export
 * @interface AdventureTemplateEntryFlavorApiGetAdventureTemplateEntryFlavorRequest
 */
export interface AdventureTemplateEntryFlavorApiGetAdventureTemplateEntryFlavorRequest {
    /**
     * Id
     * @type {number}
     * @memberof AdventureTemplateEntryFlavorApiGetAdventureTemplateEntryFlavor
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof AdventureTemplateEntryFlavorApiGetAdventureTemplateEntryFlavor
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof AdventureTemplateEntryFlavorApiGetAdventureTemplateEntryFlavor
     */
    readonly select?: string
}

/**
 * Request parameters for listAdventureTemplateEntryFlavors operation in AdventureTemplateEntryFlavorApi.
 * @export
 * @interface AdventureTemplateEntryFlavorApiListAdventureTemplateEntryFlavorsRequest
 */
export interface AdventureTemplateEntryFlavorApiListAdventureTemplateEntryFlavorsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof AdventureTemplateEntryFlavorApiListAdventureTemplateEntryFlavors
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof AdventureTemplateEntryFlavorApiListAdventureTemplateEntryFlavors
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof AdventureTemplateEntryFlavorApiListAdventureTemplateEntryFlavors
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof AdventureTemplateEntryFlavorApiListAdventureTemplateEntryFlavors
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof AdventureTemplateEntryFlavorApiListAdventureTemplateEntryFlavors
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof AdventureTemplateEntryFlavorApiListAdventureTemplateEntryFlavors
     */
    readonly select?: string
}

/**
 * Request parameters for updateAdventureTemplateEntryFlavor operation in AdventureTemplateEntryFlavorApi.
 * @export
 * @interface AdventureTemplateEntryFlavorApiUpdateAdventureTemplateEntryFlavorRequest
 */
export interface AdventureTemplateEntryFlavorApiUpdateAdventureTemplateEntryFlavorRequest {
    /**
     * Id
     * @type {number}
     * @memberof AdventureTemplateEntryFlavorApiUpdateAdventureTemplateEntryFlavor
     */
    readonly id: number

    /**
     * AdventureTemplateEntryFlavor
     * @type {ModelsAdventureTemplateEntryFlavor}
     * @memberof AdventureTemplateEntryFlavorApiUpdateAdventureTemplateEntryFlavor
     */
    readonly adventureTemplateEntryFlavor: ModelsAdventureTemplateEntryFlavor
}

/**
 * AdventureTemplateEntryFlavorApi - object-oriented interface
 * @export
 * @class AdventureTemplateEntryFlavorApi
 * @extends {BaseAPI}
 */
export class AdventureTemplateEntryFlavorApi extends BaseAPI {
    /**
     * 
     * @summary Creates AdventureTemplateEntryFlavor
     * @param {AdventureTemplateEntryFlavorApiCreateAdventureTemplateEntryFlavorRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdventureTemplateEntryFlavorApi
     */
    public createAdventureTemplateEntryFlavor(requestParameters: AdventureTemplateEntryFlavorApiCreateAdventureTemplateEntryFlavorRequest, options?: any) {
        return AdventureTemplateEntryFlavorApiFp(this.configuration).createAdventureTemplateEntryFlavor(requestParameters.adventureTemplateEntryFlavor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes AdventureTemplateEntryFlavor
     * @param {AdventureTemplateEntryFlavorApiDeleteAdventureTemplateEntryFlavorRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdventureTemplateEntryFlavorApi
     */
    public deleteAdventureTemplateEntryFlavor(requestParameters: AdventureTemplateEntryFlavorApiDeleteAdventureTemplateEntryFlavorRequest, options?: any) {
        return AdventureTemplateEntryFlavorApiFp(this.configuration).deleteAdventureTemplateEntryFlavor(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets AdventureTemplateEntryFlavor
     * @param {AdventureTemplateEntryFlavorApiGetAdventureTemplateEntryFlavorRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdventureTemplateEntryFlavorApi
     */
    public getAdventureTemplateEntryFlavor(requestParameters: AdventureTemplateEntryFlavorApiGetAdventureTemplateEntryFlavorRequest, options?: any) {
        return AdventureTemplateEntryFlavorApiFp(this.configuration).getAdventureTemplateEntryFlavor(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists AdventureTemplateEntryFlavors
     * @param {AdventureTemplateEntryFlavorApiListAdventureTemplateEntryFlavorsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdventureTemplateEntryFlavorApi
     */
    public listAdventureTemplateEntryFlavors(requestParameters: AdventureTemplateEntryFlavorApiListAdventureTemplateEntryFlavorsRequest = {}, options?: any) {
        return AdventureTemplateEntryFlavorApiFp(this.configuration).listAdventureTemplateEntryFlavors(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates AdventureTemplateEntryFlavor
     * @param {AdventureTemplateEntryFlavorApiUpdateAdventureTemplateEntryFlavorRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdventureTemplateEntryFlavorApi
     */
    public updateAdventureTemplateEntryFlavor(requestParameters: AdventureTemplateEntryFlavorApiUpdateAdventureTemplateEntryFlavorRequest, options?: any) {
        return AdventureTemplateEntryFlavorApiFp(this.configuration).updateAdventureTemplateEntryFlavor(requestParameters.id, requestParameters.adventureTemplateEntryFlavor, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AlternateCurrencyApi - axios parameter creator
 * @export
 */
export const AlternateCurrencyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates AlternateCurrency
         * @param {ModelsAlternateCurrency} alternateCurrency AlternateCurrency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlternateCurrency: async (alternateCurrency: ModelsAlternateCurrency, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'alternateCurrency' is not null or undefined
            if (alternateCurrency === null || alternateCurrency === undefined) {
                throw new RequiredError('alternateCurrency','Required parameter alternateCurrency was null or undefined when calling createAlternateCurrency.');
            }
            const localVarPath = `/alternate_currency`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof alternateCurrency !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(alternateCurrency !== undefined ? alternateCurrency : {})
                : (alternateCurrency || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes AlternateCurrency
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlternateCurrency: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteAlternateCurrency.');
            }
            const localVarPath = `/alternate_currency/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets AlternateCurrency
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlternateCurrency: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getAlternateCurrency.');
            }
            const localVarPath = `/alternate_currency/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists AlternateCurrencies
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlternateCurrencies: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/alternate_currencies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates AlternateCurrency
         * @param {number} id Id
         * @param {ModelsAlternateCurrency} alternateCurrency AlternateCurrency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlternateCurrency: async (id: number, alternateCurrency: ModelsAlternateCurrency, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateAlternateCurrency.');
            }
            // verify required parameter 'alternateCurrency' is not null or undefined
            if (alternateCurrency === null || alternateCurrency === undefined) {
                throw new RequiredError('alternateCurrency','Required parameter alternateCurrency was null or undefined when calling updateAlternateCurrency.');
            }
            const localVarPath = `/alternate_currency/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof alternateCurrency !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(alternateCurrency !== undefined ? alternateCurrency : {})
                : (alternateCurrency || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlternateCurrencyApi - functional programming interface
 * @export
 */
export const AlternateCurrencyApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates AlternateCurrency
         * @param {ModelsAlternateCurrency} alternateCurrency AlternateCurrency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAlternateCurrency(alternateCurrency: ModelsAlternateCurrency, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAlternateCurrency>>> {
            const localVarAxiosArgs = await AlternateCurrencyApiAxiosParamCreator(configuration).createAlternateCurrency(alternateCurrency, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes AlternateCurrency
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAlternateCurrency(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await AlternateCurrencyApiAxiosParamCreator(configuration).deleteAlternateCurrency(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets AlternateCurrency
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlternateCurrency(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAlternateCurrency>>> {
            const localVarAxiosArgs = await AlternateCurrencyApiAxiosParamCreator(configuration).getAlternateCurrency(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists AlternateCurrencies
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAlternateCurrencies(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAlternateCurrency>>> {
            const localVarAxiosArgs = await AlternateCurrencyApiAxiosParamCreator(configuration).listAlternateCurrencies(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates AlternateCurrency
         * @param {number} id Id
         * @param {ModelsAlternateCurrency} alternateCurrency AlternateCurrency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAlternateCurrency(id: number, alternateCurrency: ModelsAlternateCurrency, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAlternateCurrency>>> {
            const localVarAxiosArgs = await AlternateCurrencyApiAxiosParamCreator(configuration).updateAlternateCurrency(id, alternateCurrency, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AlternateCurrencyApi - factory interface
 * @export
 */
export const AlternateCurrencyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates AlternateCurrency
         * @param {ModelsAlternateCurrency} alternateCurrency AlternateCurrency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlternateCurrency(alternateCurrency: ModelsAlternateCurrency, options?: any): AxiosPromise<Array<ModelsAlternateCurrency>> {
            return AlternateCurrencyApiFp(configuration).createAlternateCurrency(alternateCurrency, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes AlternateCurrency
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlternateCurrency(id: number, options?: any): AxiosPromise<string> {
            return AlternateCurrencyApiFp(configuration).deleteAlternateCurrency(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets AlternateCurrency
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlternateCurrency(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsAlternateCurrency>> {
            return AlternateCurrencyApiFp(configuration).getAlternateCurrency(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists AlternateCurrencies
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlternateCurrencies(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsAlternateCurrency>> {
            return AlternateCurrencyApiFp(configuration).listAlternateCurrencies(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates AlternateCurrency
         * @param {number} id Id
         * @param {ModelsAlternateCurrency} alternateCurrency AlternateCurrency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlternateCurrency(id: number, alternateCurrency: ModelsAlternateCurrency, options?: any): AxiosPromise<Array<ModelsAlternateCurrency>> {
            return AlternateCurrencyApiFp(configuration).updateAlternateCurrency(id, alternateCurrency, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createAlternateCurrency operation in AlternateCurrencyApi.
 * @export
 * @interface AlternateCurrencyApiCreateAlternateCurrencyRequest
 */
export interface AlternateCurrencyApiCreateAlternateCurrencyRequest {
    /**
     * AlternateCurrency
     * @type {ModelsAlternateCurrency}
     * @memberof AlternateCurrencyApiCreateAlternateCurrency
     */
    readonly alternateCurrency: ModelsAlternateCurrency
}

/**
 * Request parameters for deleteAlternateCurrency operation in AlternateCurrencyApi.
 * @export
 * @interface AlternateCurrencyApiDeleteAlternateCurrencyRequest
 */
export interface AlternateCurrencyApiDeleteAlternateCurrencyRequest {
    /**
     * Id
     * @type {number}
     * @memberof AlternateCurrencyApiDeleteAlternateCurrency
     */
    readonly id: number
}

/**
 * Request parameters for getAlternateCurrency operation in AlternateCurrencyApi.
 * @export
 * @interface AlternateCurrencyApiGetAlternateCurrencyRequest
 */
export interface AlternateCurrencyApiGetAlternateCurrencyRequest {
    /**
     * Id
     * @type {number}
     * @memberof AlternateCurrencyApiGetAlternateCurrency
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof AlternateCurrencyApiGetAlternateCurrency
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof AlternateCurrencyApiGetAlternateCurrency
     */
    readonly select?: string
}

/**
 * Request parameters for listAlternateCurrencies operation in AlternateCurrencyApi.
 * @export
 * @interface AlternateCurrencyApiListAlternateCurrenciesRequest
 */
export interface AlternateCurrencyApiListAlternateCurrenciesRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof AlternateCurrencyApiListAlternateCurrencies
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof AlternateCurrencyApiListAlternateCurrencies
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof AlternateCurrencyApiListAlternateCurrencies
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof AlternateCurrencyApiListAlternateCurrencies
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof AlternateCurrencyApiListAlternateCurrencies
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof AlternateCurrencyApiListAlternateCurrencies
     */
    readonly select?: string
}

/**
 * Request parameters for updateAlternateCurrency operation in AlternateCurrencyApi.
 * @export
 * @interface AlternateCurrencyApiUpdateAlternateCurrencyRequest
 */
export interface AlternateCurrencyApiUpdateAlternateCurrencyRequest {
    /**
     * Id
     * @type {number}
     * @memberof AlternateCurrencyApiUpdateAlternateCurrency
     */
    readonly id: number

    /**
     * AlternateCurrency
     * @type {ModelsAlternateCurrency}
     * @memberof AlternateCurrencyApiUpdateAlternateCurrency
     */
    readonly alternateCurrency: ModelsAlternateCurrency
}

/**
 * AlternateCurrencyApi - object-oriented interface
 * @export
 * @class AlternateCurrencyApi
 * @extends {BaseAPI}
 */
export class AlternateCurrencyApi extends BaseAPI {
    /**
     * 
     * @summary Creates AlternateCurrency
     * @param {AlternateCurrencyApiCreateAlternateCurrencyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlternateCurrencyApi
     */
    public createAlternateCurrency(requestParameters: AlternateCurrencyApiCreateAlternateCurrencyRequest, options?: any) {
        return AlternateCurrencyApiFp(this.configuration).createAlternateCurrency(requestParameters.alternateCurrency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes AlternateCurrency
     * @param {AlternateCurrencyApiDeleteAlternateCurrencyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlternateCurrencyApi
     */
    public deleteAlternateCurrency(requestParameters: AlternateCurrencyApiDeleteAlternateCurrencyRequest, options?: any) {
        return AlternateCurrencyApiFp(this.configuration).deleteAlternateCurrency(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets AlternateCurrency
     * @param {AlternateCurrencyApiGetAlternateCurrencyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlternateCurrencyApi
     */
    public getAlternateCurrency(requestParameters: AlternateCurrencyApiGetAlternateCurrencyRequest, options?: any) {
        return AlternateCurrencyApiFp(this.configuration).getAlternateCurrency(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists AlternateCurrencies
     * @param {AlternateCurrencyApiListAlternateCurrenciesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlternateCurrencyApi
     */
    public listAlternateCurrencies(requestParameters: AlternateCurrencyApiListAlternateCurrenciesRequest = {}, options?: any) {
        return AlternateCurrencyApiFp(this.configuration).listAlternateCurrencies(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates AlternateCurrency
     * @param {AlternateCurrencyApiUpdateAlternateCurrencyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlternateCurrencyApi
     */
    public updateAlternateCurrency(requestParameters: AlternateCurrencyApiUpdateAlternateCurrencyRequest, options?: any) {
        return AlternateCurrencyApiFp(this.configuration).updateAlternateCurrency(requestParameters.id, requestParameters.alternateCurrency, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuraApi - axios parameter creator
 * @export
 */
export const AuraApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Aura
         * @param {ModelsAura} aura Aura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAura: async (aura: ModelsAura, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'aura' is not null or undefined
            if (aura === null || aura === undefined) {
                throw new RequiredError('aura','Required parameter aura was null or undefined when calling createAura.');
            }
            const localVarPath = `/aura`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof aura !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(aura !== undefined ? aura : {})
                : (aura || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes Aura
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAura: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteAura.');
            }
            const localVarPath = `/aura/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Aura
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAura: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getAura.');
            }
            const localVarPath = `/aura/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists Auras
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAuras: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/auras`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates Aura
         * @param {number} id Id
         * @param {ModelsAura} aura Aura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAura: async (id: number, aura: ModelsAura, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateAura.');
            }
            // verify required parameter 'aura' is not null or undefined
            if (aura === null || aura === undefined) {
                throw new RequiredError('aura','Required parameter aura was null or undefined when calling updateAura.');
            }
            const localVarPath = `/aura/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof aura !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(aura !== undefined ? aura : {})
                : (aura || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuraApi - functional programming interface
 * @export
 */
export const AuraApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Aura
         * @param {ModelsAura} aura Aura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAura(aura: ModelsAura, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAura>>> {
            const localVarAxiosArgs = await AuraApiAxiosParamCreator(configuration).createAura(aura, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes Aura
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAura(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await AuraApiAxiosParamCreator(configuration).deleteAura(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Aura
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAura(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAura>>> {
            const localVarAxiosArgs = await AuraApiAxiosParamCreator(configuration).getAura(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists Auras
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAuras(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAura>>> {
            const localVarAxiosArgs = await AuraApiAxiosParamCreator(configuration).listAuras(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates Aura
         * @param {number} id Id
         * @param {ModelsAura} aura Aura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAura(id: number, aura: ModelsAura, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsAura>>> {
            const localVarAxiosArgs = await AuraApiAxiosParamCreator(configuration).updateAura(id, aura, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AuraApi - factory interface
 * @export
 */
export const AuraApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates Aura
         * @param {ModelsAura} aura Aura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAura(aura: ModelsAura, options?: any): AxiosPromise<Array<ModelsAura>> {
            return AuraApiFp(configuration).createAura(aura, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes Aura
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAura(id: number, options?: any): AxiosPromise<string> {
            return AuraApiFp(configuration).deleteAura(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Aura
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAura(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsAura>> {
            return AuraApiFp(configuration).getAura(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists Auras
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAuras(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsAura>> {
            return AuraApiFp(configuration).listAuras(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates Aura
         * @param {number} id Id
         * @param {ModelsAura} aura Aura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAura(id: number, aura: ModelsAura, options?: any): AxiosPromise<Array<ModelsAura>> {
            return AuraApiFp(configuration).updateAura(id, aura, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createAura operation in AuraApi.
 * @export
 * @interface AuraApiCreateAuraRequest
 */
export interface AuraApiCreateAuraRequest {
    /**
     * Aura
     * @type {ModelsAura}
     * @memberof AuraApiCreateAura
     */
    readonly aura: ModelsAura
}

/**
 * Request parameters for deleteAura operation in AuraApi.
 * @export
 * @interface AuraApiDeleteAuraRequest
 */
export interface AuraApiDeleteAuraRequest {
    /**
     * Id
     * @type {number}
     * @memberof AuraApiDeleteAura
     */
    readonly id: number
}

/**
 * Request parameters for getAura operation in AuraApi.
 * @export
 * @interface AuraApiGetAuraRequest
 */
export interface AuraApiGetAuraRequest {
    /**
     * Id
     * @type {number}
     * @memberof AuraApiGetAura
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof AuraApiGetAura
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof AuraApiGetAura
     */
    readonly select?: string
}

/**
 * Request parameters for listAuras operation in AuraApi.
 * @export
 * @interface AuraApiListAurasRequest
 */
export interface AuraApiListAurasRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof AuraApiListAuras
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof AuraApiListAuras
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof AuraApiListAuras
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof AuraApiListAuras
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof AuraApiListAuras
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof AuraApiListAuras
     */
    readonly select?: string
}

/**
 * Request parameters for updateAura operation in AuraApi.
 * @export
 * @interface AuraApiUpdateAuraRequest
 */
export interface AuraApiUpdateAuraRequest {
    /**
     * Id
     * @type {number}
     * @memberof AuraApiUpdateAura
     */
    readonly id: number

    /**
     * Aura
     * @type {ModelsAura}
     * @memberof AuraApiUpdateAura
     */
    readonly aura: ModelsAura
}

/**
 * AuraApi - object-oriented interface
 * @export
 * @class AuraApi
 * @extends {BaseAPI}
 */
export class AuraApi extends BaseAPI {
    /**
     * 
     * @summary Creates Aura
     * @param {AuraApiCreateAuraRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuraApi
     */
    public createAura(requestParameters: AuraApiCreateAuraRequest, options?: any) {
        return AuraApiFp(this.configuration).createAura(requestParameters.aura, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes Aura
     * @param {AuraApiDeleteAuraRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuraApi
     */
    public deleteAura(requestParameters: AuraApiDeleteAuraRequest, options?: any) {
        return AuraApiFp(this.configuration).deleteAura(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Aura
     * @param {AuraApiGetAuraRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuraApi
     */
    public getAura(requestParameters: AuraApiGetAuraRequest, options?: any) {
        return AuraApiFp(this.configuration).getAura(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists Auras
     * @param {AuraApiListAurasRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuraApi
     */
    public listAuras(requestParameters: AuraApiListAurasRequest = {}, options?: any) {
        return AuraApiFp(this.configuration).listAuras(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates Aura
     * @param {AuraApiUpdateAuraRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuraApi
     */
    public updateAura(requestParameters: AuraApiUpdateAuraRequest, options?: any) {
        return AuraApiFp(this.configuration).updateAura(requestParameters.id, requestParameters.aura, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BlockedSpellApi - axios parameter creator
 * @export
 */
export const BlockedSpellApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates BlockedSpell
         * @param {ModelsBlockedSpell} blockedSpell BlockedSpell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBlockedSpell: async (blockedSpell: ModelsBlockedSpell, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'blockedSpell' is not null or undefined
            if (blockedSpell === null || blockedSpell === undefined) {
                throw new RequiredError('blockedSpell','Required parameter blockedSpell was null or undefined when calling createBlockedSpell.');
            }
            const localVarPath = `/blocked_spell`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof blockedSpell !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(blockedSpell !== undefined ? blockedSpell : {})
                : (blockedSpell || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes BlockedSpell
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlockedSpell: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteBlockedSpell.');
            }
            const localVarPath = `/blocked_spell/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets BlockedSpell
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockedSpell: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getBlockedSpell.');
            }
            const localVarPath = `/blocked_spell/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists BlockedSpells
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBlockedSpells: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/blocked_spells`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates BlockedSpell
         * @param {number} id Id
         * @param {ModelsBlockedSpell} blockedSpell BlockedSpell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBlockedSpell: async (id: number, blockedSpell: ModelsBlockedSpell, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateBlockedSpell.');
            }
            // verify required parameter 'blockedSpell' is not null or undefined
            if (blockedSpell === null || blockedSpell === undefined) {
                throw new RequiredError('blockedSpell','Required parameter blockedSpell was null or undefined when calling updateBlockedSpell.');
            }
            const localVarPath = `/blocked_spell/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof blockedSpell !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(blockedSpell !== undefined ? blockedSpell : {})
                : (blockedSpell || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlockedSpellApi - functional programming interface
 * @export
 */
export const BlockedSpellApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates BlockedSpell
         * @param {ModelsBlockedSpell} blockedSpell BlockedSpell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBlockedSpell(blockedSpell: ModelsBlockedSpell, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsBlockedSpell>>> {
            const localVarAxiosArgs = await BlockedSpellApiAxiosParamCreator(configuration).createBlockedSpell(blockedSpell, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes BlockedSpell
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBlockedSpell(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await BlockedSpellApiAxiosParamCreator(configuration).deleteBlockedSpell(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets BlockedSpell
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockedSpell(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsBlockedSpell>>> {
            const localVarAxiosArgs = await BlockedSpellApiAxiosParamCreator(configuration).getBlockedSpell(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists BlockedSpells
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBlockedSpells(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsBlockedSpell>>> {
            const localVarAxiosArgs = await BlockedSpellApiAxiosParamCreator(configuration).listBlockedSpells(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates BlockedSpell
         * @param {number} id Id
         * @param {ModelsBlockedSpell} blockedSpell BlockedSpell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBlockedSpell(id: number, blockedSpell: ModelsBlockedSpell, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsBlockedSpell>>> {
            const localVarAxiosArgs = await BlockedSpellApiAxiosParamCreator(configuration).updateBlockedSpell(id, blockedSpell, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * BlockedSpellApi - factory interface
 * @export
 */
export const BlockedSpellApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates BlockedSpell
         * @param {ModelsBlockedSpell} blockedSpell BlockedSpell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBlockedSpell(blockedSpell: ModelsBlockedSpell, options?: any): AxiosPromise<Array<ModelsBlockedSpell>> {
            return BlockedSpellApiFp(configuration).createBlockedSpell(blockedSpell, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes BlockedSpell
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlockedSpell(id: number, options?: any): AxiosPromise<string> {
            return BlockedSpellApiFp(configuration).deleteBlockedSpell(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets BlockedSpell
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockedSpell(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsBlockedSpell>> {
            return BlockedSpellApiFp(configuration).getBlockedSpell(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists BlockedSpells
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBlockedSpells(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsBlockedSpell>> {
            return BlockedSpellApiFp(configuration).listBlockedSpells(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates BlockedSpell
         * @param {number} id Id
         * @param {ModelsBlockedSpell} blockedSpell BlockedSpell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBlockedSpell(id: number, blockedSpell: ModelsBlockedSpell, options?: any): AxiosPromise<Array<ModelsBlockedSpell>> {
            return BlockedSpellApiFp(configuration).updateBlockedSpell(id, blockedSpell, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createBlockedSpell operation in BlockedSpellApi.
 * @export
 * @interface BlockedSpellApiCreateBlockedSpellRequest
 */
export interface BlockedSpellApiCreateBlockedSpellRequest {
    /**
     * BlockedSpell
     * @type {ModelsBlockedSpell}
     * @memberof BlockedSpellApiCreateBlockedSpell
     */
    readonly blockedSpell: ModelsBlockedSpell
}

/**
 * Request parameters for deleteBlockedSpell operation in BlockedSpellApi.
 * @export
 * @interface BlockedSpellApiDeleteBlockedSpellRequest
 */
export interface BlockedSpellApiDeleteBlockedSpellRequest {
    /**
     * Id
     * @type {number}
     * @memberof BlockedSpellApiDeleteBlockedSpell
     */
    readonly id: number
}

/**
 * Request parameters for getBlockedSpell operation in BlockedSpellApi.
 * @export
 * @interface BlockedSpellApiGetBlockedSpellRequest
 */
export interface BlockedSpellApiGetBlockedSpellRequest {
    /**
     * Id
     * @type {number}
     * @memberof BlockedSpellApiGetBlockedSpell
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof BlockedSpellApiGetBlockedSpell
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof BlockedSpellApiGetBlockedSpell
     */
    readonly select?: string
}

/**
 * Request parameters for listBlockedSpells operation in BlockedSpellApi.
 * @export
 * @interface BlockedSpellApiListBlockedSpellsRequest
 */
export interface BlockedSpellApiListBlockedSpellsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof BlockedSpellApiListBlockedSpells
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof BlockedSpellApiListBlockedSpells
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof BlockedSpellApiListBlockedSpells
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof BlockedSpellApiListBlockedSpells
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof BlockedSpellApiListBlockedSpells
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof BlockedSpellApiListBlockedSpells
     */
    readonly select?: string
}

/**
 * Request parameters for updateBlockedSpell operation in BlockedSpellApi.
 * @export
 * @interface BlockedSpellApiUpdateBlockedSpellRequest
 */
export interface BlockedSpellApiUpdateBlockedSpellRequest {
    /**
     * Id
     * @type {number}
     * @memberof BlockedSpellApiUpdateBlockedSpell
     */
    readonly id: number

    /**
     * BlockedSpell
     * @type {ModelsBlockedSpell}
     * @memberof BlockedSpellApiUpdateBlockedSpell
     */
    readonly blockedSpell: ModelsBlockedSpell
}

/**
 * BlockedSpellApi - object-oriented interface
 * @export
 * @class BlockedSpellApi
 * @extends {BaseAPI}
 */
export class BlockedSpellApi extends BaseAPI {
    /**
     * 
     * @summary Creates BlockedSpell
     * @param {BlockedSpellApiCreateBlockedSpellRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockedSpellApi
     */
    public createBlockedSpell(requestParameters: BlockedSpellApiCreateBlockedSpellRequest, options?: any) {
        return BlockedSpellApiFp(this.configuration).createBlockedSpell(requestParameters.blockedSpell, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes BlockedSpell
     * @param {BlockedSpellApiDeleteBlockedSpellRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockedSpellApi
     */
    public deleteBlockedSpell(requestParameters: BlockedSpellApiDeleteBlockedSpellRequest, options?: any) {
        return BlockedSpellApiFp(this.configuration).deleteBlockedSpell(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets BlockedSpell
     * @param {BlockedSpellApiGetBlockedSpellRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockedSpellApi
     */
    public getBlockedSpell(requestParameters: BlockedSpellApiGetBlockedSpellRequest, options?: any) {
        return BlockedSpellApiFp(this.configuration).getBlockedSpell(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists BlockedSpells
     * @param {BlockedSpellApiListBlockedSpellsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockedSpellApi
     */
    public listBlockedSpells(requestParameters: BlockedSpellApiListBlockedSpellsRequest = {}, options?: any) {
        return BlockedSpellApiFp(this.configuration).listBlockedSpells(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates BlockedSpell
     * @param {BlockedSpellApiUpdateBlockedSpellRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockedSpellApi
     */
    public updateBlockedSpell(requestParameters: BlockedSpellApiUpdateBlockedSpellRequest, options?: any) {
        return BlockedSpellApiFp(this.configuration).updateBlockedSpell(requestParameters.id, requestParameters.blockedSpell, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BugApi - axios parameter creator
 * @export
 */
export const BugApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Bug
         * @param {ModelsBug} bug Bug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBug: async (bug: ModelsBug, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bug' is not null or undefined
            if (bug === null || bug === undefined) {
                throw new RequiredError('bug','Required parameter bug was null or undefined when calling createBug.');
            }
            const localVarPath = `/bug`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof bug !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(bug !== undefined ? bug : {})
                : (bug || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes Bug
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBug: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteBug.');
            }
            const localVarPath = `/bug/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Bug
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBug: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getBug.');
            }
            const localVarPath = `/bug/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists Bugs
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBugs: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/bugs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates Bug
         * @param {number} id Id
         * @param {ModelsBug} bug Bug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBug: async (id: number, bug: ModelsBug, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateBug.');
            }
            // verify required parameter 'bug' is not null or undefined
            if (bug === null || bug === undefined) {
                throw new RequiredError('bug','Required parameter bug was null or undefined when calling updateBug.');
            }
            const localVarPath = `/bug/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof bug !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(bug !== undefined ? bug : {})
                : (bug || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BugApi - functional programming interface
 * @export
 */
export const BugApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Bug
         * @param {ModelsBug} bug Bug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBug(bug: ModelsBug, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsBug>>> {
            const localVarAxiosArgs = await BugApiAxiosParamCreator(configuration).createBug(bug, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes Bug
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBug(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await BugApiAxiosParamCreator(configuration).deleteBug(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Bug
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBug(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsBug>>> {
            const localVarAxiosArgs = await BugApiAxiosParamCreator(configuration).getBug(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists Bugs
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBugs(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsBug>>> {
            const localVarAxiosArgs = await BugApiAxiosParamCreator(configuration).listBugs(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates Bug
         * @param {number} id Id
         * @param {ModelsBug} bug Bug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBug(id: number, bug: ModelsBug, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsBug>>> {
            const localVarAxiosArgs = await BugApiAxiosParamCreator(configuration).updateBug(id, bug, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * BugApi - factory interface
 * @export
 */
export const BugApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates Bug
         * @param {ModelsBug} bug Bug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBug(bug: ModelsBug, options?: any): AxiosPromise<Array<ModelsBug>> {
            return BugApiFp(configuration).createBug(bug, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes Bug
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBug(id: number, options?: any): AxiosPromise<string> {
            return BugApiFp(configuration).deleteBug(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Bug
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBug(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsBug>> {
            return BugApiFp(configuration).getBug(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists Bugs
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBugs(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsBug>> {
            return BugApiFp(configuration).listBugs(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates Bug
         * @param {number} id Id
         * @param {ModelsBug} bug Bug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBug(id: number, bug: ModelsBug, options?: any): AxiosPromise<Array<ModelsBug>> {
            return BugApiFp(configuration).updateBug(id, bug, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createBug operation in BugApi.
 * @export
 * @interface BugApiCreateBugRequest
 */
export interface BugApiCreateBugRequest {
    /**
     * Bug
     * @type {ModelsBug}
     * @memberof BugApiCreateBug
     */
    readonly bug: ModelsBug
}

/**
 * Request parameters for deleteBug operation in BugApi.
 * @export
 * @interface BugApiDeleteBugRequest
 */
export interface BugApiDeleteBugRequest {
    /**
     * Id
     * @type {number}
     * @memberof BugApiDeleteBug
     */
    readonly id: number
}

/**
 * Request parameters for getBug operation in BugApi.
 * @export
 * @interface BugApiGetBugRequest
 */
export interface BugApiGetBugRequest {
    /**
     * Id
     * @type {number}
     * @memberof BugApiGetBug
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof BugApiGetBug
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof BugApiGetBug
     */
    readonly select?: string
}

/**
 * Request parameters for listBugs operation in BugApi.
 * @export
 * @interface BugApiListBugsRequest
 */
export interface BugApiListBugsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof BugApiListBugs
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof BugApiListBugs
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof BugApiListBugs
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof BugApiListBugs
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof BugApiListBugs
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof BugApiListBugs
     */
    readonly select?: string
}

/**
 * Request parameters for updateBug operation in BugApi.
 * @export
 * @interface BugApiUpdateBugRequest
 */
export interface BugApiUpdateBugRequest {
    /**
     * Id
     * @type {number}
     * @memberof BugApiUpdateBug
     */
    readonly id: number

    /**
     * Bug
     * @type {ModelsBug}
     * @memberof BugApiUpdateBug
     */
    readonly bug: ModelsBug
}

/**
 * BugApi - object-oriented interface
 * @export
 * @class BugApi
 * @extends {BaseAPI}
 */
export class BugApi extends BaseAPI {
    /**
     * 
     * @summary Creates Bug
     * @param {BugApiCreateBugRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BugApi
     */
    public createBug(requestParameters: BugApiCreateBugRequest, options?: any) {
        return BugApiFp(this.configuration).createBug(requestParameters.bug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes Bug
     * @param {BugApiDeleteBugRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BugApi
     */
    public deleteBug(requestParameters: BugApiDeleteBugRequest, options?: any) {
        return BugApiFp(this.configuration).deleteBug(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Bug
     * @param {BugApiGetBugRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BugApi
     */
    public getBug(requestParameters: BugApiGetBugRequest, options?: any) {
        return BugApiFp(this.configuration).getBug(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists Bugs
     * @param {BugApiListBugsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BugApi
     */
    public listBugs(requestParameters: BugApiListBugsRequest = {}, options?: any) {
        return BugApiFp(this.configuration).listBugs(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates Bug
     * @param {BugApiUpdateBugRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BugApi
     */
    public updateBug(requestParameters: BugApiUpdateBugRequest, options?: any) {
        return BugApiFp(this.configuration).updateBug(requestParameters.id, requestParameters.bug, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BugReportApi - axios parameter creator
 * @export
 */
export const BugReportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates BugReport
         * @param {ModelsBugReport} bugReport BugReport
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBugReport: async (bugReport: ModelsBugReport, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bugReport' is not null or undefined
            if (bugReport === null || bugReport === undefined) {
                throw new RequiredError('bugReport','Required parameter bugReport was null or undefined when calling createBugReport.');
            }
            const localVarPath = `/bug_report`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof bugReport !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(bugReport !== undefined ? bugReport : {})
                : (bugReport || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes BugReport
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBugReport: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteBugReport.');
            }
            const localVarPath = `/bug_report/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets BugReport
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBugReport: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getBugReport.');
            }
            const localVarPath = `/bug_report/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists BugReports
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBugReports: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/bug_reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates BugReport
         * @param {number} id Id
         * @param {ModelsBugReport} bugReport BugReport
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBugReport: async (id: number, bugReport: ModelsBugReport, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateBugReport.');
            }
            // verify required parameter 'bugReport' is not null or undefined
            if (bugReport === null || bugReport === undefined) {
                throw new RequiredError('bugReport','Required parameter bugReport was null or undefined when calling updateBugReport.');
            }
            const localVarPath = `/bug_report/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof bugReport !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(bugReport !== undefined ? bugReport : {})
                : (bugReport || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BugReportApi - functional programming interface
 * @export
 */
export const BugReportApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates BugReport
         * @param {ModelsBugReport} bugReport BugReport
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBugReport(bugReport: ModelsBugReport, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsBugReport>>> {
            const localVarAxiosArgs = await BugReportApiAxiosParamCreator(configuration).createBugReport(bugReport, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes BugReport
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBugReport(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await BugReportApiAxiosParamCreator(configuration).deleteBugReport(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets BugReport
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBugReport(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsBugReport>>> {
            const localVarAxiosArgs = await BugReportApiAxiosParamCreator(configuration).getBugReport(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists BugReports
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBugReports(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsBugReport>>> {
            const localVarAxiosArgs = await BugReportApiAxiosParamCreator(configuration).listBugReports(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates BugReport
         * @param {number} id Id
         * @param {ModelsBugReport} bugReport BugReport
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBugReport(id: number, bugReport: ModelsBugReport, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsBugReport>>> {
            const localVarAxiosArgs = await BugReportApiAxiosParamCreator(configuration).updateBugReport(id, bugReport, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * BugReportApi - factory interface
 * @export
 */
export const BugReportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates BugReport
         * @param {ModelsBugReport} bugReport BugReport
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBugReport(bugReport: ModelsBugReport, options?: any): AxiosPromise<Array<ModelsBugReport>> {
            return BugReportApiFp(configuration).createBugReport(bugReport, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes BugReport
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBugReport(id: number, options?: any): AxiosPromise<string> {
            return BugReportApiFp(configuration).deleteBugReport(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets BugReport
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBugReport(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsBugReport>> {
            return BugReportApiFp(configuration).getBugReport(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists BugReports
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBugReports(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsBugReport>> {
            return BugReportApiFp(configuration).listBugReports(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates BugReport
         * @param {number} id Id
         * @param {ModelsBugReport} bugReport BugReport
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBugReport(id: number, bugReport: ModelsBugReport, options?: any): AxiosPromise<Array<ModelsBugReport>> {
            return BugReportApiFp(configuration).updateBugReport(id, bugReport, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createBugReport operation in BugReportApi.
 * @export
 * @interface BugReportApiCreateBugReportRequest
 */
export interface BugReportApiCreateBugReportRequest {
    /**
     * BugReport
     * @type {ModelsBugReport}
     * @memberof BugReportApiCreateBugReport
     */
    readonly bugReport: ModelsBugReport
}

/**
 * Request parameters for deleteBugReport operation in BugReportApi.
 * @export
 * @interface BugReportApiDeleteBugReportRequest
 */
export interface BugReportApiDeleteBugReportRequest {
    /**
     * Id
     * @type {number}
     * @memberof BugReportApiDeleteBugReport
     */
    readonly id: number
}

/**
 * Request parameters for getBugReport operation in BugReportApi.
 * @export
 * @interface BugReportApiGetBugReportRequest
 */
export interface BugReportApiGetBugReportRequest {
    /**
     * Id
     * @type {number}
     * @memberof BugReportApiGetBugReport
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof BugReportApiGetBugReport
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof BugReportApiGetBugReport
     */
    readonly select?: string
}

/**
 * Request parameters for listBugReports operation in BugReportApi.
 * @export
 * @interface BugReportApiListBugReportsRequest
 */
export interface BugReportApiListBugReportsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof BugReportApiListBugReports
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof BugReportApiListBugReports
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof BugReportApiListBugReports
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof BugReportApiListBugReports
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof BugReportApiListBugReports
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof BugReportApiListBugReports
     */
    readonly select?: string
}

/**
 * Request parameters for updateBugReport operation in BugReportApi.
 * @export
 * @interface BugReportApiUpdateBugReportRequest
 */
export interface BugReportApiUpdateBugReportRequest {
    /**
     * Id
     * @type {number}
     * @memberof BugReportApiUpdateBugReport
     */
    readonly id: number

    /**
     * BugReport
     * @type {ModelsBugReport}
     * @memberof BugReportApiUpdateBugReport
     */
    readonly bugReport: ModelsBugReport
}

/**
 * BugReportApi - object-oriented interface
 * @export
 * @class BugReportApi
 * @extends {BaseAPI}
 */
export class BugReportApi extends BaseAPI {
    /**
     * 
     * @summary Creates BugReport
     * @param {BugReportApiCreateBugReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BugReportApi
     */
    public createBugReport(requestParameters: BugReportApiCreateBugReportRequest, options?: any) {
        return BugReportApiFp(this.configuration).createBugReport(requestParameters.bugReport, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes BugReport
     * @param {BugReportApiDeleteBugReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BugReportApi
     */
    public deleteBugReport(requestParameters: BugReportApiDeleteBugReportRequest, options?: any) {
        return BugReportApiFp(this.configuration).deleteBugReport(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets BugReport
     * @param {BugReportApiGetBugReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BugReportApi
     */
    public getBugReport(requestParameters: BugReportApiGetBugReportRequest, options?: any) {
        return BugReportApiFp(this.configuration).getBugReport(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists BugReports
     * @param {BugReportApiListBugReportsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BugReportApi
     */
    public listBugReports(requestParameters: BugReportApiListBugReportsRequest = {}, options?: any) {
        return BugReportApiFp(this.configuration).listBugReports(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates BugReport
     * @param {BugReportApiUpdateBugReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BugReportApi
     */
    public updateBugReport(requestParameters: BugReportApiUpdateBugReportRequest, options?: any) {
        return BugReportApiFp(this.configuration).updateBugReport(requestParameters.id, requestParameters.bugReport, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BuyerApi - axios parameter creator
 * @export
 */
export const BuyerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Buyer
         * @param {ModelsBuyer} buyer Buyer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBuyer: async (buyer: ModelsBuyer, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'buyer' is not null or undefined
            if (buyer === null || buyer === undefined) {
                throw new RequiredError('buyer','Required parameter buyer was null or undefined when calling createBuyer.');
            }
            const localVarPath = `/buyer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof buyer !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(buyer !== undefined ? buyer : {})
                : (buyer || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes Buyer
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBuyer: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteBuyer.');
            }
            const localVarPath = `/buyer/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Buyer
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuyer: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getBuyer.');
            }
            const localVarPath = `/buyer/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists Buyers
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBuyers: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/buyers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates Buyer
         * @param {number} id Id
         * @param {ModelsBuyer} buyer Buyer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBuyer: async (id: number, buyer: ModelsBuyer, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateBuyer.');
            }
            // verify required parameter 'buyer' is not null or undefined
            if (buyer === null || buyer === undefined) {
                throw new RequiredError('buyer','Required parameter buyer was null or undefined when calling updateBuyer.');
            }
            const localVarPath = `/buyer/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof buyer !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(buyer !== undefined ? buyer : {})
                : (buyer || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BuyerApi - functional programming interface
 * @export
 */
export const BuyerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Buyer
         * @param {ModelsBuyer} buyer Buyer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBuyer(buyer: ModelsBuyer, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsBuyer>>> {
            const localVarAxiosArgs = await BuyerApiAxiosParamCreator(configuration).createBuyer(buyer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes Buyer
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBuyer(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await BuyerApiAxiosParamCreator(configuration).deleteBuyer(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Buyer
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBuyer(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsBuyer>>> {
            const localVarAxiosArgs = await BuyerApiAxiosParamCreator(configuration).getBuyer(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists Buyers
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBuyers(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsBuyer>>> {
            const localVarAxiosArgs = await BuyerApiAxiosParamCreator(configuration).listBuyers(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates Buyer
         * @param {number} id Id
         * @param {ModelsBuyer} buyer Buyer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBuyer(id: number, buyer: ModelsBuyer, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsBuyer>>> {
            const localVarAxiosArgs = await BuyerApiAxiosParamCreator(configuration).updateBuyer(id, buyer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * BuyerApi - factory interface
 * @export
 */
export const BuyerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates Buyer
         * @param {ModelsBuyer} buyer Buyer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBuyer(buyer: ModelsBuyer, options?: any): AxiosPromise<Array<ModelsBuyer>> {
            return BuyerApiFp(configuration).createBuyer(buyer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes Buyer
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBuyer(id: number, options?: any): AxiosPromise<string> {
            return BuyerApiFp(configuration).deleteBuyer(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Buyer
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuyer(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsBuyer>> {
            return BuyerApiFp(configuration).getBuyer(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists Buyers
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBuyers(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsBuyer>> {
            return BuyerApiFp(configuration).listBuyers(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates Buyer
         * @param {number} id Id
         * @param {ModelsBuyer} buyer Buyer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBuyer(id: number, buyer: ModelsBuyer, options?: any): AxiosPromise<Array<ModelsBuyer>> {
            return BuyerApiFp(configuration).updateBuyer(id, buyer, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createBuyer operation in BuyerApi.
 * @export
 * @interface BuyerApiCreateBuyerRequest
 */
export interface BuyerApiCreateBuyerRequest {
    /**
     * Buyer
     * @type {ModelsBuyer}
     * @memberof BuyerApiCreateBuyer
     */
    readonly buyer: ModelsBuyer
}

/**
 * Request parameters for deleteBuyer operation in BuyerApi.
 * @export
 * @interface BuyerApiDeleteBuyerRequest
 */
export interface BuyerApiDeleteBuyerRequest {
    /**
     * Id
     * @type {number}
     * @memberof BuyerApiDeleteBuyer
     */
    readonly id: number
}

/**
 * Request parameters for getBuyer operation in BuyerApi.
 * @export
 * @interface BuyerApiGetBuyerRequest
 */
export interface BuyerApiGetBuyerRequest {
    /**
     * Id
     * @type {number}
     * @memberof BuyerApiGetBuyer
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof BuyerApiGetBuyer
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof BuyerApiGetBuyer
     */
    readonly select?: string
}

/**
 * Request parameters for listBuyers operation in BuyerApi.
 * @export
 * @interface BuyerApiListBuyersRequest
 */
export interface BuyerApiListBuyersRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof BuyerApiListBuyers
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof BuyerApiListBuyers
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof BuyerApiListBuyers
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof BuyerApiListBuyers
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof BuyerApiListBuyers
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof BuyerApiListBuyers
     */
    readonly select?: string
}

/**
 * Request parameters for updateBuyer operation in BuyerApi.
 * @export
 * @interface BuyerApiUpdateBuyerRequest
 */
export interface BuyerApiUpdateBuyerRequest {
    /**
     * Id
     * @type {number}
     * @memberof BuyerApiUpdateBuyer
     */
    readonly id: number

    /**
     * Buyer
     * @type {ModelsBuyer}
     * @memberof BuyerApiUpdateBuyer
     */
    readonly buyer: ModelsBuyer
}

/**
 * BuyerApi - object-oriented interface
 * @export
 * @class BuyerApi
 * @extends {BaseAPI}
 */
export class BuyerApi extends BaseAPI {
    /**
     * 
     * @summary Creates Buyer
     * @param {BuyerApiCreateBuyerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuyerApi
     */
    public createBuyer(requestParameters: BuyerApiCreateBuyerRequest, options?: any) {
        return BuyerApiFp(this.configuration).createBuyer(requestParameters.buyer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes Buyer
     * @param {BuyerApiDeleteBuyerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuyerApi
     */
    public deleteBuyer(requestParameters: BuyerApiDeleteBuyerRequest, options?: any) {
        return BuyerApiFp(this.configuration).deleteBuyer(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Buyer
     * @param {BuyerApiGetBuyerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuyerApi
     */
    public getBuyer(requestParameters: BuyerApiGetBuyerRequest, options?: any) {
        return BuyerApiFp(this.configuration).getBuyer(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists Buyers
     * @param {BuyerApiListBuyersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuyerApi
     */
    public listBuyers(requestParameters: BuyerApiListBuyersRequest = {}, options?: any) {
        return BuyerApiFp(this.configuration).listBuyers(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates Buyer
     * @param {BuyerApiUpdateBuyerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuyerApi
     */
    public updateBuyer(requestParameters: BuyerApiUpdateBuyerRequest, options?: any) {
        return BuyerApiFp(this.configuration).updateBuyer(requestParameters.id, requestParameters.buyer, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CharCreatePointAllocationApi - axios parameter creator
 * @export
 */
export const CharCreatePointAllocationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharCreatePointAllocation
         * @param {ModelsCharCreatePointAllocation} charCreatePointAllocation CharCreatePointAllocation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharCreatePointAllocation: async (charCreatePointAllocation: ModelsCharCreatePointAllocation, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'charCreatePointAllocation' is not null or undefined
            if (charCreatePointAllocation === null || charCreatePointAllocation === undefined) {
                throw new RequiredError('charCreatePointAllocation','Required parameter charCreatePointAllocation was null or undefined when calling createCharCreatePointAllocation.');
            }
            const localVarPath = `/char_create_point_allocation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof charCreatePointAllocation !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(charCreatePointAllocation !== undefined ? charCreatePointAllocation : {})
                : (charCreatePointAllocation || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes CharCreatePointAllocation
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharCreatePointAllocation: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteCharCreatePointAllocation.');
            }
            const localVarPath = `/char_create_point_allocation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets CharCreatePointAllocation
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharCreatePointAllocation: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getCharCreatePointAllocation.');
            }
            const localVarPath = `/char_create_point_allocation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists CharCreatePointAllocations
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharCreatePointAllocations: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/char_create_point_allocations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates CharCreatePointAllocation
         * @param {number} id Id
         * @param {ModelsCharCreatePointAllocation} charCreatePointAllocation CharCreatePointAllocation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharCreatePointAllocation: async (id: number, charCreatePointAllocation: ModelsCharCreatePointAllocation, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateCharCreatePointAllocation.');
            }
            // verify required parameter 'charCreatePointAllocation' is not null or undefined
            if (charCreatePointAllocation === null || charCreatePointAllocation === undefined) {
                throw new RequiredError('charCreatePointAllocation','Required parameter charCreatePointAllocation was null or undefined when calling updateCharCreatePointAllocation.');
            }
            const localVarPath = `/char_create_point_allocation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof charCreatePointAllocation !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(charCreatePointAllocation !== undefined ? charCreatePointAllocation : {})
                : (charCreatePointAllocation || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CharCreatePointAllocationApi - functional programming interface
 * @export
 */
export const CharCreatePointAllocationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharCreatePointAllocation
         * @param {ModelsCharCreatePointAllocation} charCreatePointAllocation CharCreatePointAllocation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCharCreatePointAllocation(charCreatePointAllocation: ModelsCharCreatePointAllocation, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharCreatePointAllocation>>> {
            const localVarAxiosArgs = await CharCreatePointAllocationApiAxiosParamCreator(configuration).createCharCreatePointAllocation(charCreatePointAllocation, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes CharCreatePointAllocation
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCharCreatePointAllocation(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await CharCreatePointAllocationApiAxiosParamCreator(configuration).deleteCharCreatePointAllocation(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets CharCreatePointAllocation
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharCreatePointAllocation(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharCreatePointAllocation>>> {
            const localVarAxiosArgs = await CharCreatePointAllocationApiAxiosParamCreator(configuration).getCharCreatePointAllocation(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists CharCreatePointAllocations
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCharCreatePointAllocations(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharCreatePointAllocation>>> {
            const localVarAxiosArgs = await CharCreatePointAllocationApiAxiosParamCreator(configuration).listCharCreatePointAllocations(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates CharCreatePointAllocation
         * @param {number} id Id
         * @param {ModelsCharCreatePointAllocation} charCreatePointAllocation CharCreatePointAllocation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCharCreatePointAllocation(id: number, charCreatePointAllocation: ModelsCharCreatePointAllocation, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharCreatePointAllocation>>> {
            const localVarAxiosArgs = await CharCreatePointAllocationApiAxiosParamCreator(configuration).updateCharCreatePointAllocation(id, charCreatePointAllocation, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CharCreatePointAllocationApi - factory interface
 * @export
 */
export const CharCreatePointAllocationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates CharCreatePointAllocation
         * @param {ModelsCharCreatePointAllocation} charCreatePointAllocation CharCreatePointAllocation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharCreatePointAllocation(charCreatePointAllocation: ModelsCharCreatePointAllocation, options?: any): AxiosPromise<Array<ModelsCharCreatePointAllocation>> {
            return CharCreatePointAllocationApiFp(configuration).createCharCreatePointAllocation(charCreatePointAllocation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes CharCreatePointAllocation
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharCreatePointAllocation(id: number, options?: any): AxiosPromise<string> {
            return CharCreatePointAllocationApiFp(configuration).deleteCharCreatePointAllocation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets CharCreatePointAllocation
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharCreatePointAllocation(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharCreatePointAllocation>> {
            return CharCreatePointAllocationApiFp(configuration).getCharCreatePointAllocation(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists CharCreatePointAllocations
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharCreatePointAllocations(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharCreatePointAllocation>> {
            return CharCreatePointAllocationApiFp(configuration).listCharCreatePointAllocations(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates CharCreatePointAllocation
         * @param {number} id Id
         * @param {ModelsCharCreatePointAllocation} charCreatePointAllocation CharCreatePointAllocation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharCreatePointAllocation(id: number, charCreatePointAllocation: ModelsCharCreatePointAllocation, options?: any): AxiosPromise<Array<ModelsCharCreatePointAllocation>> {
            return CharCreatePointAllocationApiFp(configuration).updateCharCreatePointAllocation(id, charCreatePointAllocation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCharCreatePointAllocation operation in CharCreatePointAllocationApi.
 * @export
 * @interface CharCreatePointAllocationApiCreateCharCreatePointAllocationRequest
 */
export interface CharCreatePointAllocationApiCreateCharCreatePointAllocationRequest {
    /**
     * CharCreatePointAllocation
     * @type {ModelsCharCreatePointAllocation}
     * @memberof CharCreatePointAllocationApiCreateCharCreatePointAllocation
     */
    readonly charCreatePointAllocation: ModelsCharCreatePointAllocation
}

/**
 * Request parameters for deleteCharCreatePointAllocation operation in CharCreatePointAllocationApi.
 * @export
 * @interface CharCreatePointAllocationApiDeleteCharCreatePointAllocationRequest
 */
export interface CharCreatePointAllocationApiDeleteCharCreatePointAllocationRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharCreatePointAllocationApiDeleteCharCreatePointAllocation
     */
    readonly id: number
}

/**
 * Request parameters for getCharCreatePointAllocation operation in CharCreatePointAllocationApi.
 * @export
 * @interface CharCreatePointAllocationApiGetCharCreatePointAllocationRequest
 */
export interface CharCreatePointAllocationApiGetCharCreatePointAllocationRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharCreatePointAllocationApiGetCharCreatePointAllocation
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharCreatePointAllocationApiGetCharCreatePointAllocation
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharCreatePointAllocationApiGetCharCreatePointAllocation
     */
    readonly select?: string
}

/**
 * Request parameters for listCharCreatePointAllocations operation in CharCreatePointAllocationApi.
 * @export
 * @interface CharCreatePointAllocationApiListCharCreatePointAllocationsRequest
 */
export interface CharCreatePointAllocationApiListCharCreatePointAllocationsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharCreatePointAllocationApiListCharCreatePointAllocations
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof CharCreatePointAllocationApiListCharCreatePointAllocations
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof CharCreatePointAllocationApiListCharCreatePointAllocations
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof CharCreatePointAllocationApiListCharCreatePointAllocations
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof CharCreatePointAllocationApiListCharCreatePointAllocations
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharCreatePointAllocationApiListCharCreatePointAllocations
     */
    readonly select?: string
}

/**
 * Request parameters for updateCharCreatePointAllocation operation in CharCreatePointAllocationApi.
 * @export
 * @interface CharCreatePointAllocationApiUpdateCharCreatePointAllocationRequest
 */
export interface CharCreatePointAllocationApiUpdateCharCreatePointAllocationRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharCreatePointAllocationApiUpdateCharCreatePointAllocation
     */
    readonly id: number

    /**
     * CharCreatePointAllocation
     * @type {ModelsCharCreatePointAllocation}
     * @memberof CharCreatePointAllocationApiUpdateCharCreatePointAllocation
     */
    readonly charCreatePointAllocation: ModelsCharCreatePointAllocation
}

/**
 * CharCreatePointAllocationApi - object-oriented interface
 * @export
 * @class CharCreatePointAllocationApi
 * @extends {BaseAPI}
 */
export class CharCreatePointAllocationApi extends BaseAPI {
    /**
     * 
     * @summary Creates CharCreatePointAllocation
     * @param {CharCreatePointAllocationApiCreateCharCreatePointAllocationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharCreatePointAllocationApi
     */
    public createCharCreatePointAllocation(requestParameters: CharCreatePointAllocationApiCreateCharCreatePointAllocationRequest, options?: any) {
        return CharCreatePointAllocationApiFp(this.configuration).createCharCreatePointAllocation(requestParameters.charCreatePointAllocation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes CharCreatePointAllocation
     * @param {CharCreatePointAllocationApiDeleteCharCreatePointAllocationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharCreatePointAllocationApi
     */
    public deleteCharCreatePointAllocation(requestParameters: CharCreatePointAllocationApiDeleteCharCreatePointAllocationRequest, options?: any) {
        return CharCreatePointAllocationApiFp(this.configuration).deleteCharCreatePointAllocation(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets CharCreatePointAllocation
     * @param {CharCreatePointAllocationApiGetCharCreatePointAllocationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharCreatePointAllocationApi
     */
    public getCharCreatePointAllocation(requestParameters: CharCreatePointAllocationApiGetCharCreatePointAllocationRequest, options?: any) {
        return CharCreatePointAllocationApiFp(this.configuration).getCharCreatePointAllocation(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists CharCreatePointAllocations
     * @param {CharCreatePointAllocationApiListCharCreatePointAllocationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharCreatePointAllocationApi
     */
    public listCharCreatePointAllocations(requestParameters: CharCreatePointAllocationApiListCharCreatePointAllocationsRequest = {}, options?: any) {
        return CharCreatePointAllocationApiFp(this.configuration).listCharCreatePointAllocations(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates CharCreatePointAllocation
     * @param {CharCreatePointAllocationApiUpdateCharCreatePointAllocationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharCreatePointAllocationApi
     */
    public updateCharCreatePointAllocation(requestParameters: CharCreatePointAllocationApiUpdateCharCreatePointAllocationRequest, options?: any) {
        return CharCreatePointAllocationApiFp(this.configuration).updateCharCreatePointAllocation(requestParameters.id, requestParameters.charCreatePointAllocation, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CharRecipeListApi - axios parameter creator
 * @export
 */
export const CharRecipeListApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharRecipeList
         * @param {ModelsCharRecipeList} charRecipeList CharRecipeList
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharRecipeList: async (charRecipeList: ModelsCharRecipeList, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'charRecipeList' is not null or undefined
            if (charRecipeList === null || charRecipeList === undefined) {
                throw new RequiredError('charRecipeList','Required parameter charRecipeList was null or undefined when calling createCharRecipeList.');
            }
            const localVarPath = `/char_recipe_list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof charRecipeList !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(charRecipeList !== undefined ? charRecipeList : {})
                : (charRecipeList || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes CharRecipeList
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharRecipeList: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteCharRecipeList.');
            }
            const localVarPath = `/char_recipe_list/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets CharRecipeList
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharRecipeList: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getCharRecipeList.');
            }
            const localVarPath = `/char_recipe_list/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists CharRecipeLists
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharRecipeLists: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/char_recipe_lists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates CharRecipeList
         * @param {number} id Id
         * @param {ModelsCharRecipeList} charRecipeList CharRecipeList
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharRecipeList: async (id: number, charRecipeList: ModelsCharRecipeList, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateCharRecipeList.');
            }
            // verify required parameter 'charRecipeList' is not null or undefined
            if (charRecipeList === null || charRecipeList === undefined) {
                throw new RequiredError('charRecipeList','Required parameter charRecipeList was null or undefined when calling updateCharRecipeList.');
            }
            const localVarPath = `/char_recipe_list/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof charRecipeList !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(charRecipeList !== undefined ? charRecipeList : {})
                : (charRecipeList || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CharRecipeListApi - functional programming interface
 * @export
 */
export const CharRecipeListApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharRecipeList
         * @param {ModelsCharRecipeList} charRecipeList CharRecipeList
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCharRecipeList(charRecipeList: ModelsCharRecipeList, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharRecipeList>>> {
            const localVarAxiosArgs = await CharRecipeListApiAxiosParamCreator(configuration).createCharRecipeList(charRecipeList, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes CharRecipeList
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCharRecipeList(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await CharRecipeListApiAxiosParamCreator(configuration).deleteCharRecipeList(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets CharRecipeList
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharRecipeList(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharRecipeList>>> {
            const localVarAxiosArgs = await CharRecipeListApiAxiosParamCreator(configuration).getCharRecipeList(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists CharRecipeLists
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCharRecipeLists(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharRecipeList>>> {
            const localVarAxiosArgs = await CharRecipeListApiAxiosParamCreator(configuration).listCharRecipeLists(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates CharRecipeList
         * @param {number} id Id
         * @param {ModelsCharRecipeList} charRecipeList CharRecipeList
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCharRecipeList(id: number, charRecipeList: ModelsCharRecipeList, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharRecipeList>>> {
            const localVarAxiosArgs = await CharRecipeListApiAxiosParamCreator(configuration).updateCharRecipeList(id, charRecipeList, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CharRecipeListApi - factory interface
 * @export
 */
export const CharRecipeListApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates CharRecipeList
         * @param {ModelsCharRecipeList} charRecipeList CharRecipeList
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharRecipeList(charRecipeList: ModelsCharRecipeList, options?: any): AxiosPromise<Array<ModelsCharRecipeList>> {
            return CharRecipeListApiFp(configuration).createCharRecipeList(charRecipeList, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes CharRecipeList
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharRecipeList(id: number, options?: any): AxiosPromise<string> {
            return CharRecipeListApiFp(configuration).deleteCharRecipeList(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets CharRecipeList
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharRecipeList(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharRecipeList>> {
            return CharRecipeListApiFp(configuration).getCharRecipeList(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists CharRecipeLists
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharRecipeLists(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharRecipeList>> {
            return CharRecipeListApiFp(configuration).listCharRecipeLists(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates CharRecipeList
         * @param {number} id Id
         * @param {ModelsCharRecipeList} charRecipeList CharRecipeList
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharRecipeList(id: number, charRecipeList: ModelsCharRecipeList, options?: any): AxiosPromise<Array<ModelsCharRecipeList>> {
            return CharRecipeListApiFp(configuration).updateCharRecipeList(id, charRecipeList, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCharRecipeList operation in CharRecipeListApi.
 * @export
 * @interface CharRecipeListApiCreateCharRecipeListRequest
 */
export interface CharRecipeListApiCreateCharRecipeListRequest {
    /**
     * CharRecipeList
     * @type {ModelsCharRecipeList}
     * @memberof CharRecipeListApiCreateCharRecipeList
     */
    readonly charRecipeList: ModelsCharRecipeList
}

/**
 * Request parameters for deleteCharRecipeList operation in CharRecipeListApi.
 * @export
 * @interface CharRecipeListApiDeleteCharRecipeListRequest
 */
export interface CharRecipeListApiDeleteCharRecipeListRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharRecipeListApiDeleteCharRecipeList
     */
    readonly id: number
}

/**
 * Request parameters for getCharRecipeList operation in CharRecipeListApi.
 * @export
 * @interface CharRecipeListApiGetCharRecipeListRequest
 */
export interface CharRecipeListApiGetCharRecipeListRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharRecipeListApiGetCharRecipeList
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharRecipeListApiGetCharRecipeList
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharRecipeListApiGetCharRecipeList
     */
    readonly select?: string
}

/**
 * Request parameters for listCharRecipeLists operation in CharRecipeListApi.
 * @export
 * @interface CharRecipeListApiListCharRecipeListsRequest
 */
export interface CharRecipeListApiListCharRecipeListsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharRecipeListApiListCharRecipeLists
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof CharRecipeListApiListCharRecipeLists
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof CharRecipeListApiListCharRecipeLists
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof CharRecipeListApiListCharRecipeLists
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof CharRecipeListApiListCharRecipeLists
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharRecipeListApiListCharRecipeLists
     */
    readonly select?: string
}

/**
 * Request parameters for updateCharRecipeList operation in CharRecipeListApi.
 * @export
 * @interface CharRecipeListApiUpdateCharRecipeListRequest
 */
export interface CharRecipeListApiUpdateCharRecipeListRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharRecipeListApiUpdateCharRecipeList
     */
    readonly id: number

    /**
     * CharRecipeList
     * @type {ModelsCharRecipeList}
     * @memberof CharRecipeListApiUpdateCharRecipeList
     */
    readonly charRecipeList: ModelsCharRecipeList
}

/**
 * CharRecipeListApi - object-oriented interface
 * @export
 * @class CharRecipeListApi
 * @extends {BaseAPI}
 */
export class CharRecipeListApi extends BaseAPI {
    /**
     * 
     * @summary Creates CharRecipeList
     * @param {CharRecipeListApiCreateCharRecipeListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharRecipeListApi
     */
    public createCharRecipeList(requestParameters: CharRecipeListApiCreateCharRecipeListRequest, options?: any) {
        return CharRecipeListApiFp(this.configuration).createCharRecipeList(requestParameters.charRecipeList, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes CharRecipeList
     * @param {CharRecipeListApiDeleteCharRecipeListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharRecipeListApi
     */
    public deleteCharRecipeList(requestParameters: CharRecipeListApiDeleteCharRecipeListRequest, options?: any) {
        return CharRecipeListApiFp(this.configuration).deleteCharRecipeList(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets CharRecipeList
     * @param {CharRecipeListApiGetCharRecipeListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharRecipeListApi
     */
    public getCharRecipeList(requestParameters: CharRecipeListApiGetCharRecipeListRequest, options?: any) {
        return CharRecipeListApiFp(this.configuration).getCharRecipeList(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists CharRecipeLists
     * @param {CharRecipeListApiListCharRecipeListsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharRecipeListApi
     */
    public listCharRecipeLists(requestParameters: CharRecipeListApiListCharRecipeListsRequest = {}, options?: any) {
        return CharRecipeListApiFp(this.configuration).listCharRecipeLists(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates CharRecipeList
     * @param {CharRecipeListApiUpdateCharRecipeListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharRecipeListApi
     */
    public updateCharRecipeList(requestParameters: CharRecipeListApiUpdateCharRecipeListRequest, options?: any) {
        return CharRecipeListApiFp(this.configuration).updateCharRecipeList(requestParameters.id, requestParameters.charRecipeList, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CharacterAlternateAbilityApi - axios parameter creator
 * @export
 */
export const CharacterAlternateAbilityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharacterAlternateAbility
         * @param {ModelsCharacterAlternateAbility} characterAlternateAbility CharacterAlternateAbility
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterAlternateAbility: async (characterAlternateAbility: ModelsCharacterAlternateAbility, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterAlternateAbility' is not null or undefined
            if (characterAlternateAbility === null || characterAlternateAbility === undefined) {
                throw new RequiredError('characterAlternateAbility','Required parameter characterAlternateAbility was null or undefined when calling createCharacterAlternateAbility.');
            }
            const localVarPath = `/character_alternate_ability`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof characterAlternateAbility !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(characterAlternateAbility !== undefined ? characterAlternateAbility : {})
                : (characterAlternateAbility || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes CharacterAlternateAbility
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterAlternateAbility: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteCharacterAlternateAbility.');
            }
            const localVarPath = `/character_alternate_ability/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets CharacterAlternateAbility
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterAlternateAbility: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getCharacterAlternateAbility.');
            }
            const localVarPath = `/character_alternate_ability/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists CharacterAlternateAbilities
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharacterAlternateAbilities: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/character_alternate_abilities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates CharacterAlternateAbility
         * @param {number} id Id
         * @param {ModelsCharacterAlternateAbility} characterAlternateAbility CharacterAlternateAbility
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharacterAlternateAbility: async (id: number, characterAlternateAbility: ModelsCharacterAlternateAbility, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateCharacterAlternateAbility.');
            }
            // verify required parameter 'characterAlternateAbility' is not null or undefined
            if (characterAlternateAbility === null || characterAlternateAbility === undefined) {
                throw new RequiredError('characterAlternateAbility','Required parameter characterAlternateAbility was null or undefined when calling updateCharacterAlternateAbility.');
            }
            const localVarPath = `/character_alternate_ability/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof characterAlternateAbility !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(characterAlternateAbility !== undefined ? characterAlternateAbility : {})
                : (characterAlternateAbility || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CharacterAlternateAbilityApi - functional programming interface
 * @export
 */
export const CharacterAlternateAbilityApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharacterAlternateAbility
         * @param {ModelsCharacterAlternateAbility} characterAlternateAbility CharacterAlternateAbility
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCharacterAlternateAbility(characterAlternateAbility: ModelsCharacterAlternateAbility, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterAlternateAbility>>> {
            const localVarAxiosArgs = await CharacterAlternateAbilityApiAxiosParamCreator(configuration).createCharacterAlternateAbility(characterAlternateAbility, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes CharacterAlternateAbility
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCharacterAlternateAbility(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await CharacterAlternateAbilityApiAxiosParamCreator(configuration).deleteCharacterAlternateAbility(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets CharacterAlternateAbility
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharacterAlternateAbility(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterAlternateAbility>>> {
            const localVarAxiosArgs = await CharacterAlternateAbilityApiAxiosParamCreator(configuration).getCharacterAlternateAbility(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists CharacterAlternateAbilities
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCharacterAlternateAbilities(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterAlternateAbility>>> {
            const localVarAxiosArgs = await CharacterAlternateAbilityApiAxiosParamCreator(configuration).listCharacterAlternateAbilities(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates CharacterAlternateAbility
         * @param {number} id Id
         * @param {ModelsCharacterAlternateAbility} characterAlternateAbility CharacterAlternateAbility
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCharacterAlternateAbility(id: number, characterAlternateAbility: ModelsCharacterAlternateAbility, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterAlternateAbility>>> {
            const localVarAxiosArgs = await CharacterAlternateAbilityApiAxiosParamCreator(configuration).updateCharacterAlternateAbility(id, characterAlternateAbility, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CharacterAlternateAbilityApi - factory interface
 * @export
 */
export const CharacterAlternateAbilityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates CharacterAlternateAbility
         * @param {ModelsCharacterAlternateAbility} characterAlternateAbility CharacterAlternateAbility
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterAlternateAbility(characterAlternateAbility: ModelsCharacterAlternateAbility, options?: any): AxiosPromise<Array<ModelsCharacterAlternateAbility>> {
            return CharacterAlternateAbilityApiFp(configuration).createCharacterAlternateAbility(characterAlternateAbility, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes CharacterAlternateAbility
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterAlternateAbility(id: number, options?: any): AxiosPromise<string> {
            return CharacterAlternateAbilityApiFp(configuration).deleteCharacterAlternateAbility(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets CharacterAlternateAbility
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterAlternateAbility(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharacterAlternateAbility>> {
            return CharacterAlternateAbilityApiFp(configuration).getCharacterAlternateAbility(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists CharacterAlternateAbilities
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharacterAlternateAbilities(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharacterAlternateAbility>> {
            return CharacterAlternateAbilityApiFp(configuration).listCharacterAlternateAbilities(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates CharacterAlternateAbility
         * @param {number} id Id
         * @param {ModelsCharacterAlternateAbility} characterAlternateAbility CharacterAlternateAbility
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharacterAlternateAbility(id: number, characterAlternateAbility: ModelsCharacterAlternateAbility, options?: any): AxiosPromise<Array<ModelsCharacterAlternateAbility>> {
            return CharacterAlternateAbilityApiFp(configuration).updateCharacterAlternateAbility(id, characterAlternateAbility, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCharacterAlternateAbility operation in CharacterAlternateAbilityApi.
 * @export
 * @interface CharacterAlternateAbilityApiCreateCharacterAlternateAbilityRequest
 */
export interface CharacterAlternateAbilityApiCreateCharacterAlternateAbilityRequest {
    /**
     * CharacterAlternateAbility
     * @type {ModelsCharacterAlternateAbility}
     * @memberof CharacterAlternateAbilityApiCreateCharacterAlternateAbility
     */
    readonly characterAlternateAbility: ModelsCharacterAlternateAbility
}

/**
 * Request parameters for deleteCharacterAlternateAbility operation in CharacterAlternateAbilityApi.
 * @export
 * @interface CharacterAlternateAbilityApiDeleteCharacterAlternateAbilityRequest
 */
export interface CharacterAlternateAbilityApiDeleteCharacterAlternateAbilityRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterAlternateAbilityApiDeleteCharacterAlternateAbility
     */
    readonly id: number
}

/**
 * Request parameters for getCharacterAlternateAbility operation in CharacterAlternateAbilityApi.
 * @export
 * @interface CharacterAlternateAbilityApiGetCharacterAlternateAbilityRequest
 */
export interface CharacterAlternateAbilityApiGetCharacterAlternateAbilityRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterAlternateAbilityApiGetCharacterAlternateAbility
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharacterAlternateAbilityApiGetCharacterAlternateAbility
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharacterAlternateAbilityApiGetCharacterAlternateAbility
     */
    readonly select?: string
}

/**
 * Request parameters for listCharacterAlternateAbilities operation in CharacterAlternateAbilityApi.
 * @export
 * @interface CharacterAlternateAbilityApiListCharacterAlternateAbilitiesRequest
 */
export interface CharacterAlternateAbilityApiListCharacterAlternateAbilitiesRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharacterAlternateAbilityApiListCharacterAlternateAbilities
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof CharacterAlternateAbilityApiListCharacterAlternateAbilities
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof CharacterAlternateAbilityApiListCharacterAlternateAbilities
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof CharacterAlternateAbilityApiListCharacterAlternateAbilities
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof CharacterAlternateAbilityApiListCharacterAlternateAbilities
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharacterAlternateAbilityApiListCharacterAlternateAbilities
     */
    readonly select?: string
}

/**
 * Request parameters for updateCharacterAlternateAbility operation in CharacterAlternateAbilityApi.
 * @export
 * @interface CharacterAlternateAbilityApiUpdateCharacterAlternateAbilityRequest
 */
export interface CharacterAlternateAbilityApiUpdateCharacterAlternateAbilityRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterAlternateAbilityApiUpdateCharacterAlternateAbility
     */
    readonly id: number

    /**
     * CharacterAlternateAbility
     * @type {ModelsCharacterAlternateAbility}
     * @memberof CharacterAlternateAbilityApiUpdateCharacterAlternateAbility
     */
    readonly characterAlternateAbility: ModelsCharacterAlternateAbility
}

/**
 * CharacterAlternateAbilityApi - object-oriented interface
 * @export
 * @class CharacterAlternateAbilityApi
 * @extends {BaseAPI}
 */
export class CharacterAlternateAbilityApi extends BaseAPI {
    /**
     * 
     * @summary Creates CharacterAlternateAbility
     * @param {CharacterAlternateAbilityApiCreateCharacterAlternateAbilityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterAlternateAbilityApi
     */
    public createCharacterAlternateAbility(requestParameters: CharacterAlternateAbilityApiCreateCharacterAlternateAbilityRequest, options?: any) {
        return CharacterAlternateAbilityApiFp(this.configuration).createCharacterAlternateAbility(requestParameters.characterAlternateAbility, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes CharacterAlternateAbility
     * @param {CharacterAlternateAbilityApiDeleteCharacterAlternateAbilityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterAlternateAbilityApi
     */
    public deleteCharacterAlternateAbility(requestParameters: CharacterAlternateAbilityApiDeleteCharacterAlternateAbilityRequest, options?: any) {
        return CharacterAlternateAbilityApiFp(this.configuration).deleteCharacterAlternateAbility(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets CharacterAlternateAbility
     * @param {CharacterAlternateAbilityApiGetCharacterAlternateAbilityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterAlternateAbilityApi
     */
    public getCharacterAlternateAbility(requestParameters: CharacterAlternateAbilityApiGetCharacterAlternateAbilityRequest, options?: any) {
        return CharacterAlternateAbilityApiFp(this.configuration).getCharacterAlternateAbility(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists CharacterAlternateAbilities
     * @param {CharacterAlternateAbilityApiListCharacterAlternateAbilitiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterAlternateAbilityApi
     */
    public listCharacterAlternateAbilities(requestParameters: CharacterAlternateAbilityApiListCharacterAlternateAbilitiesRequest = {}, options?: any) {
        return CharacterAlternateAbilityApiFp(this.configuration).listCharacterAlternateAbilities(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates CharacterAlternateAbility
     * @param {CharacterAlternateAbilityApiUpdateCharacterAlternateAbilityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterAlternateAbilityApi
     */
    public updateCharacterAlternateAbility(requestParameters: CharacterAlternateAbilityApiUpdateCharacterAlternateAbilityRequest, options?: any) {
        return CharacterAlternateAbilityApiFp(this.configuration).updateCharacterAlternateAbility(requestParameters.id, requestParameters.characterAlternateAbility, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CharacterAuraApi - axios parameter creator
 * @export
 */
export const CharacterAuraApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharacterAura
         * @param {ModelsCharacterAura} characterAura CharacterAura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterAura: async (characterAura: ModelsCharacterAura, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterAura' is not null or undefined
            if (characterAura === null || characterAura === undefined) {
                throw new RequiredError('characterAura','Required parameter characterAura was null or undefined when calling createCharacterAura.');
            }
            const localVarPath = `/character_aura`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof characterAura !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(characterAura !== undefined ? characterAura : {})
                : (characterAura || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes CharacterAura
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterAura: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteCharacterAura.');
            }
            const localVarPath = `/character_aura/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets CharacterAura
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterAura: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getCharacterAura.');
            }
            const localVarPath = `/character_aura/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists CharacterAuras
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharacterAuras: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/character_auras`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates CharacterAura
         * @param {number} id Id
         * @param {ModelsCharacterAura} characterAura CharacterAura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharacterAura: async (id: number, characterAura: ModelsCharacterAura, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateCharacterAura.');
            }
            // verify required parameter 'characterAura' is not null or undefined
            if (characterAura === null || characterAura === undefined) {
                throw new RequiredError('characterAura','Required parameter characterAura was null or undefined when calling updateCharacterAura.');
            }
            const localVarPath = `/character_aura/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof characterAura !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(characterAura !== undefined ? characterAura : {})
                : (characterAura || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CharacterAuraApi - functional programming interface
 * @export
 */
export const CharacterAuraApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharacterAura
         * @param {ModelsCharacterAura} characterAura CharacterAura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCharacterAura(characterAura: ModelsCharacterAura, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterAura>>> {
            const localVarAxiosArgs = await CharacterAuraApiAxiosParamCreator(configuration).createCharacterAura(characterAura, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes CharacterAura
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCharacterAura(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await CharacterAuraApiAxiosParamCreator(configuration).deleteCharacterAura(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets CharacterAura
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharacterAura(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterAura>>> {
            const localVarAxiosArgs = await CharacterAuraApiAxiosParamCreator(configuration).getCharacterAura(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists CharacterAuras
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCharacterAuras(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterAura>>> {
            const localVarAxiosArgs = await CharacterAuraApiAxiosParamCreator(configuration).listCharacterAuras(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates CharacterAura
         * @param {number} id Id
         * @param {ModelsCharacterAura} characterAura CharacterAura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCharacterAura(id: number, characterAura: ModelsCharacterAura, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterAura>>> {
            const localVarAxiosArgs = await CharacterAuraApiAxiosParamCreator(configuration).updateCharacterAura(id, characterAura, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CharacterAuraApi - factory interface
 * @export
 */
export const CharacterAuraApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates CharacterAura
         * @param {ModelsCharacterAura} characterAura CharacterAura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterAura(characterAura: ModelsCharacterAura, options?: any): AxiosPromise<Array<ModelsCharacterAura>> {
            return CharacterAuraApiFp(configuration).createCharacterAura(characterAura, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes CharacterAura
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterAura(id: number, options?: any): AxiosPromise<string> {
            return CharacterAuraApiFp(configuration).deleteCharacterAura(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets CharacterAura
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterAura(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharacterAura>> {
            return CharacterAuraApiFp(configuration).getCharacterAura(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists CharacterAuras
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharacterAuras(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharacterAura>> {
            return CharacterAuraApiFp(configuration).listCharacterAuras(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates CharacterAura
         * @param {number} id Id
         * @param {ModelsCharacterAura} characterAura CharacterAura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharacterAura(id: number, characterAura: ModelsCharacterAura, options?: any): AxiosPromise<Array<ModelsCharacterAura>> {
            return CharacterAuraApiFp(configuration).updateCharacterAura(id, characterAura, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCharacterAura operation in CharacterAuraApi.
 * @export
 * @interface CharacterAuraApiCreateCharacterAuraRequest
 */
export interface CharacterAuraApiCreateCharacterAuraRequest {
    /**
     * CharacterAura
     * @type {ModelsCharacterAura}
     * @memberof CharacterAuraApiCreateCharacterAura
     */
    readonly characterAura: ModelsCharacterAura
}

/**
 * Request parameters for deleteCharacterAura operation in CharacterAuraApi.
 * @export
 * @interface CharacterAuraApiDeleteCharacterAuraRequest
 */
export interface CharacterAuraApiDeleteCharacterAuraRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterAuraApiDeleteCharacterAura
     */
    readonly id: number
}

/**
 * Request parameters for getCharacterAura operation in CharacterAuraApi.
 * @export
 * @interface CharacterAuraApiGetCharacterAuraRequest
 */
export interface CharacterAuraApiGetCharacterAuraRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterAuraApiGetCharacterAura
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharacterAuraApiGetCharacterAura
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharacterAuraApiGetCharacterAura
     */
    readonly select?: string
}

/**
 * Request parameters for listCharacterAuras operation in CharacterAuraApi.
 * @export
 * @interface CharacterAuraApiListCharacterAurasRequest
 */
export interface CharacterAuraApiListCharacterAurasRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharacterAuraApiListCharacterAuras
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof CharacterAuraApiListCharacterAuras
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof CharacterAuraApiListCharacterAuras
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof CharacterAuraApiListCharacterAuras
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof CharacterAuraApiListCharacterAuras
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharacterAuraApiListCharacterAuras
     */
    readonly select?: string
}

/**
 * Request parameters for updateCharacterAura operation in CharacterAuraApi.
 * @export
 * @interface CharacterAuraApiUpdateCharacterAuraRequest
 */
export interface CharacterAuraApiUpdateCharacterAuraRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterAuraApiUpdateCharacterAura
     */
    readonly id: number

    /**
     * CharacterAura
     * @type {ModelsCharacterAura}
     * @memberof CharacterAuraApiUpdateCharacterAura
     */
    readonly characterAura: ModelsCharacterAura
}

/**
 * CharacterAuraApi - object-oriented interface
 * @export
 * @class CharacterAuraApi
 * @extends {BaseAPI}
 */
export class CharacterAuraApi extends BaseAPI {
    /**
     * 
     * @summary Creates CharacterAura
     * @param {CharacterAuraApiCreateCharacterAuraRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterAuraApi
     */
    public createCharacterAura(requestParameters: CharacterAuraApiCreateCharacterAuraRequest, options?: any) {
        return CharacterAuraApiFp(this.configuration).createCharacterAura(requestParameters.characterAura, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes CharacterAura
     * @param {CharacterAuraApiDeleteCharacterAuraRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterAuraApi
     */
    public deleteCharacterAura(requestParameters: CharacterAuraApiDeleteCharacterAuraRequest, options?: any) {
        return CharacterAuraApiFp(this.configuration).deleteCharacterAura(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets CharacterAura
     * @param {CharacterAuraApiGetCharacterAuraRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterAuraApi
     */
    public getCharacterAura(requestParameters: CharacterAuraApiGetCharacterAuraRequest, options?: any) {
        return CharacterAuraApiFp(this.configuration).getCharacterAura(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists CharacterAuras
     * @param {CharacterAuraApiListCharacterAurasRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterAuraApi
     */
    public listCharacterAuras(requestParameters: CharacterAuraApiListCharacterAurasRequest = {}, options?: any) {
        return CharacterAuraApiFp(this.configuration).listCharacterAuras(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates CharacterAura
     * @param {CharacterAuraApiUpdateCharacterAuraRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterAuraApi
     */
    public updateCharacterAura(requestParameters: CharacterAuraApiUpdateCharacterAuraRequest, options?: any) {
        return CharacterAuraApiFp(this.configuration).updateCharacterAura(requestParameters.id, requestParameters.characterAura, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CharacterBandolierApi - axios parameter creator
 * @export
 */
export const CharacterBandolierApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharacterBandolier
         * @param {ModelsCharacterBandolier} characterBandolier CharacterBandolier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterBandolier: async (characterBandolier: ModelsCharacterBandolier, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterBandolier' is not null or undefined
            if (characterBandolier === null || characterBandolier === undefined) {
                throw new RequiredError('characterBandolier','Required parameter characterBandolier was null or undefined when calling createCharacterBandolier.');
            }
            const localVarPath = `/character_bandolier`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof characterBandolier !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(characterBandolier !== undefined ? characterBandolier : {})
                : (characterBandolier || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes CharacterBandolier
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterBandolier: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteCharacterBandolier.');
            }
            const localVarPath = `/character_bandolier/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets CharacterBandolier
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterBandolier: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getCharacterBandolier.');
            }
            const localVarPath = `/character_bandolier/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists CharacterBandoliers
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharacterBandoliers: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/character_bandoliers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates CharacterBandolier
         * @param {number} id Id
         * @param {ModelsCharacterBandolier} characterBandolier CharacterBandolier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharacterBandolier: async (id: number, characterBandolier: ModelsCharacterBandolier, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateCharacterBandolier.');
            }
            // verify required parameter 'characterBandolier' is not null or undefined
            if (characterBandolier === null || characterBandolier === undefined) {
                throw new RequiredError('characterBandolier','Required parameter characterBandolier was null or undefined when calling updateCharacterBandolier.');
            }
            const localVarPath = `/character_bandolier/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof characterBandolier !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(characterBandolier !== undefined ? characterBandolier : {})
                : (characterBandolier || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CharacterBandolierApi - functional programming interface
 * @export
 */
export const CharacterBandolierApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharacterBandolier
         * @param {ModelsCharacterBandolier} characterBandolier CharacterBandolier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCharacterBandolier(characterBandolier: ModelsCharacterBandolier, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterBandolier>>> {
            const localVarAxiosArgs = await CharacterBandolierApiAxiosParamCreator(configuration).createCharacterBandolier(characterBandolier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes CharacterBandolier
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCharacterBandolier(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await CharacterBandolierApiAxiosParamCreator(configuration).deleteCharacterBandolier(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets CharacterBandolier
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharacterBandolier(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterBandolier>>> {
            const localVarAxiosArgs = await CharacterBandolierApiAxiosParamCreator(configuration).getCharacterBandolier(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists CharacterBandoliers
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCharacterBandoliers(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterBandolier>>> {
            const localVarAxiosArgs = await CharacterBandolierApiAxiosParamCreator(configuration).listCharacterBandoliers(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates CharacterBandolier
         * @param {number} id Id
         * @param {ModelsCharacterBandolier} characterBandolier CharacterBandolier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCharacterBandolier(id: number, characterBandolier: ModelsCharacterBandolier, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterBandolier>>> {
            const localVarAxiosArgs = await CharacterBandolierApiAxiosParamCreator(configuration).updateCharacterBandolier(id, characterBandolier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CharacterBandolierApi - factory interface
 * @export
 */
export const CharacterBandolierApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates CharacterBandolier
         * @param {ModelsCharacterBandolier} characterBandolier CharacterBandolier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterBandolier(characterBandolier: ModelsCharacterBandolier, options?: any): AxiosPromise<Array<ModelsCharacterBandolier>> {
            return CharacterBandolierApiFp(configuration).createCharacterBandolier(characterBandolier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes CharacterBandolier
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterBandolier(id: number, options?: any): AxiosPromise<string> {
            return CharacterBandolierApiFp(configuration).deleteCharacterBandolier(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets CharacterBandolier
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterBandolier(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharacterBandolier>> {
            return CharacterBandolierApiFp(configuration).getCharacterBandolier(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists CharacterBandoliers
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharacterBandoliers(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharacterBandolier>> {
            return CharacterBandolierApiFp(configuration).listCharacterBandoliers(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates CharacterBandolier
         * @param {number} id Id
         * @param {ModelsCharacterBandolier} characterBandolier CharacterBandolier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharacterBandolier(id: number, characterBandolier: ModelsCharacterBandolier, options?: any): AxiosPromise<Array<ModelsCharacterBandolier>> {
            return CharacterBandolierApiFp(configuration).updateCharacterBandolier(id, characterBandolier, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCharacterBandolier operation in CharacterBandolierApi.
 * @export
 * @interface CharacterBandolierApiCreateCharacterBandolierRequest
 */
export interface CharacterBandolierApiCreateCharacterBandolierRequest {
    /**
     * CharacterBandolier
     * @type {ModelsCharacterBandolier}
     * @memberof CharacterBandolierApiCreateCharacterBandolier
     */
    readonly characterBandolier: ModelsCharacterBandolier
}

/**
 * Request parameters for deleteCharacterBandolier operation in CharacterBandolierApi.
 * @export
 * @interface CharacterBandolierApiDeleteCharacterBandolierRequest
 */
export interface CharacterBandolierApiDeleteCharacterBandolierRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterBandolierApiDeleteCharacterBandolier
     */
    readonly id: number
}

/**
 * Request parameters for getCharacterBandolier operation in CharacterBandolierApi.
 * @export
 * @interface CharacterBandolierApiGetCharacterBandolierRequest
 */
export interface CharacterBandolierApiGetCharacterBandolierRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterBandolierApiGetCharacterBandolier
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharacterBandolierApiGetCharacterBandolier
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharacterBandolierApiGetCharacterBandolier
     */
    readonly select?: string
}

/**
 * Request parameters for listCharacterBandoliers operation in CharacterBandolierApi.
 * @export
 * @interface CharacterBandolierApiListCharacterBandoliersRequest
 */
export interface CharacterBandolierApiListCharacterBandoliersRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharacterBandolierApiListCharacterBandoliers
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof CharacterBandolierApiListCharacterBandoliers
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof CharacterBandolierApiListCharacterBandoliers
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof CharacterBandolierApiListCharacterBandoliers
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof CharacterBandolierApiListCharacterBandoliers
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharacterBandolierApiListCharacterBandoliers
     */
    readonly select?: string
}

/**
 * Request parameters for updateCharacterBandolier operation in CharacterBandolierApi.
 * @export
 * @interface CharacterBandolierApiUpdateCharacterBandolierRequest
 */
export interface CharacterBandolierApiUpdateCharacterBandolierRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterBandolierApiUpdateCharacterBandolier
     */
    readonly id: number

    /**
     * CharacterBandolier
     * @type {ModelsCharacterBandolier}
     * @memberof CharacterBandolierApiUpdateCharacterBandolier
     */
    readonly characterBandolier: ModelsCharacterBandolier
}

/**
 * CharacterBandolierApi - object-oriented interface
 * @export
 * @class CharacterBandolierApi
 * @extends {BaseAPI}
 */
export class CharacterBandolierApi extends BaseAPI {
    /**
     * 
     * @summary Creates CharacterBandolier
     * @param {CharacterBandolierApiCreateCharacterBandolierRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterBandolierApi
     */
    public createCharacterBandolier(requestParameters: CharacterBandolierApiCreateCharacterBandolierRequest, options?: any) {
        return CharacterBandolierApiFp(this.configuration).createCharacterBandolier(requestParameters.characterBandolier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes CharacterBandolier
     * @param {CharacterBandolierApiDeleteCharacterBandolierRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterBandolierApi
     */
    public deleteCharacterBandolier(requestParameters: CharacterBandolierApiDeleteCharacterBandolierRequest, options?: any) {
        return CharacterBandolierApiFp(this.configuration).deleteCharacterBandolier(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets CharacterBandolier
     * @param {CharacterBandolierApiGetCharacterBandolierRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterBandolierApi
     */
    public getCharacterBandolier(requestParameters: CharacterBandolierApiGetCharacterBandolierRequest, options?: any) {
        return CharacterBandolierApiFp(this.configuration).getCharacterBandolier(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists CharacterBandoliers
     * @param {CharacterBandolierApiListCharacterBandoliersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterBandolierApi
     */
    public listCharacterBandoliers(requestParameters: CharacterBandolierApiListCharacterBandoliersRequest = {}, options?: any) {
        return CharacterBandolierApiFp(this.configuration).listCharacterBandoliers(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates CharacterBandolier
     * @param {CharacterBandolierApiUpdateCharacterBandolierRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterBandolierApi
     */
    public updateCharacterBandolier(requestParameters: CharacterBandolierApiUpdateCharacterBandolierRequest, options?: any) {
        return CharacterBandolierApiFp(this.configuration).updateCharacterBandolier(requestParameters.id, requestParameters.characterBandolier, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CharacterBindApi - axios parameter creator
 * @export
 */
export const CharacterBindApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharacterBind
         * @param {ModelsCharacterBind} characterBind CharacterBind
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterBind: async (characterBind: ModelsCharacterBind, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterBind' is not null or undefined
            if (characterBind === null || characterBind === undefined) {
                throw new RequiredError('characterBind','Required parameter characterBind was null or undefined when calling createCharacterBind.');
            }
            const localVarPath = `/character_bind`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof characterBind !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(characterBind !== undefined ? characterBind : {})
                : (characterBind || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes CharacterBind
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterBind: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteCharacterBind.');
            }
            const localVarPath = `/character_bind/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets CharacterBind
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterBind: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getCharacterBind.');
            }
            const localVarPath = `/character_bind/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists CharacterBinds
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharacterBinds: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/character_binds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates CharacterBind
         * @param {number} id Id
         * @param {ModelsCharacterBind} characterBind CharacterBind
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharacterBind: async (id: number, characterBind: ModelsCharacterBind, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateCharacterBind.');
            }
            // verify required parameter 'characterBind' is not null or undefined
            if (characterBind === null || characterBind === undefined) {
                throw new RequiredError('characterBind','Required parameter characterBind was null or undefined when calling updateCharacterBind.');
            }
            const localVarPath = `/character_bind/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof characterBind !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(characterBind !== undefined ? characterBind : {})
                : (characterBind || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CharacterBindApi - functional programming interface
 * @export
 */
export const CharacterBindApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharacterBind
         * @param {ModelsCharacterBind} characterBind CharacterBind
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCharacterBind(characterBind: ModelsCharacterBind, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterBind>>> {
            const localVarAxiosArgs = await CharacterBindApiAxiosParamCreator(configuration).createCharacterBind(characterBind, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes CharacterBind
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCharacterBind(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await CharacterBindApiAxiosParamCreator(configuration).deleteCharacterBind(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets CharacterBind
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharacterBind(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterBind>>> {
            const localVarAxiosArgs = await CharacterBindApiAxiosParamCreator(configuration).getCharacterBind(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists CharacterBinds
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCharacterBinds(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterBind>>> {
            const localVarAxiosArgs = await CharacterBindApiAxiosParamCreator(configuration).listCharacterBinds(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates CharacterBind
         * @param {number} id Id
         * @param {ModelsCharacterBind} characterBind CharacterBind
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCharacterBind(id: number, characterBind: ModelsCharacterBind, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterBind>>> {
            const localVarAxiosArgs = await CharacterBindApiAxiosParamCreator(configuration).updateCharacterBind(id, characterBind, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CharacterBindApi - factory interface
 * @export
 */
export const CharacterBindApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates CharacterBind
         * @param {ModelsCharacterBind} characterBind CharacterBind
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterBind(characterBind: ModelsCharacterBind, options?: any): AxiosPromise<Array<ModelsCharacterBind>> {
            return CharacterBindApiFp(configuration).createCharacterBind(characterBind, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes CharacterBind
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterBind(id: number, options?: any): AxiosPromise<string> {
            return CharacterBindApiFp(configuration).deleteCharacterBind(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets CharacterBind
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterBind(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharacterBind>> {
            return CharacterBindApiFp(configuration).getCharacterBind(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists CharacterBinds
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharacterBinds(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharacterBind>> {
            return CharacterBindApiFp(configuration).listCharacterBinds(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates CharacterBind
         * @param {number} id Id
         * @param {ModelsCharacterBind} characterBind CharacterBind
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharacterBind(id: number, characterBind: ModelsCharacterBind, options?: any): AxiosPromise<Array<ModelsCharacterBind>> {
            return CharacterBindApiFp(configuration).updateCharacterBind(id, characterBind, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCharacterBind operation in CharacterBindApi.
 * @export
 * @interface CharacterBindApiCreateCharacterBindRequest
 */
export interface CharacterBindApiCreateCharacterBindRequest {
    /**
     * CharacterBind
     * @type {ModelsCharacterBind}
     * @memberof CharacterBindApiCreateCharacterBind
     */
    readonly characterBind: ModelsCharacterBind
}

/**
 * Request parameters for deleteCharacterBind operation in CharacterBindApi.
 * @export
 * @interface CharacterBindApiDeleteCharacterBindRequest
 */
export interface CharacterBindApiDeleteCharacterBindRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterBindApiDeleteCharacterBind
     */
    readonly id: number
}

/**
 * Request parameters for getCharacterBind operation in CharacterBindApi.
 * @export
 * @interface CharacterBindApiGetCharacterBindRequest
 */
export interface CharacterBindApiGetCharacterBindRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterBindApiGetCharacterBind
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharacterBindApiGetCharacterBind
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharacterBindApiGetCharacterBind
     */
    readonly select?: string
}

/**
 * Request parameters for listCharacterBinds operation in CharacterBindApi.
 * @export
 * @interface CharacterBindApiListCharacterBindsRequest
 */
export interface CharacterBindApiListCharacterBindsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharacterBindApiListCharacterBinds
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof CharacterBindApiListCharacterBinds
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof CharacterBindApiListCharacterBinds
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof CharacterBindApiListCharacterBinds
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof CharacterBindApiListCharacterBinds
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharacterBindApiListCharacterBinds
     */
    readonly select?: string
}

/**
 * Request parameters for updateCharacterBind operation in CharacterBindApi.
 * @export
 * @interface CharacterBindApiUpdateCharacterBindRequest
 */
export interface CharacterBindApiUpdateCharacterBindRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterBindApiUpdateCharacterBind
     */
    readonly id: number

    /**
     * CharacterBind
     * @type {ModelsCharacterBind}
     * @memberof CharacterBindApiUpdateCharacterBind
     */
    readonly characterBind: ModelsCharacterBind
}

/**
 * CharacterBindApi - object-oriented interface
 * @export
 * @class CharacterBindApi
 * @extends {BaseAPI}
 */
export class CharacterBindApi extends BaseAPI {
    /**
     * 
     * @summary Creates CharacterBind
     * @param {CharacterBindApiCreateCharacterBindRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterBindApi
     */
    public createCharacterBind(requestParameters: CharacterBindApiCreateCharacterBindRequest, options?: any) {
        return CharacterBindApiFp(this.configuration).createCharacterBind(requestParameters.characterBind, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes CharacterBind
     * @param {CharacterBindApiDeleteCharacterBindRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterBindApi
     */
    public deleteCharacterBind(requestParameters: CharacterBindApiDeleteCharacterBindRequest, options?: any) {
        return CharacterBindApiFp(this.configuration).deleteCharacterBind(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets CharacterBind
     * @param {CharacterBindApiGetCharacterBindRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterBindApi
     */
    public getCharacterBind(requestParameters: CharacterBindApiGetCharacterBindRequest, options?: any) {
        return CharacterBindApiFp(this.configuration).getCharacterBind(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists CharacterBinds
     * @param {CharacterBindApiListCharacterBindsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterBindApi
     */
    public listCharacterBinds(requestParameters: CharacterBindApiListCharacterBindsRequest = {}, options?: any) {
        return CharacterBindApiFp(this.configuration).listCharacterBinds(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates CharacterBind
     * @param {CharacterBindApiUpdateCharacterBindRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterBindApi
     */
    public updateCharacterBind(requestParameters: CharacterBindApiUpdateCharacterBindRequest, options?: any) {
        return CharacterBindApiFp(this.configuration).updateCharacterBind(requestParameters.id, requestParameters.characterBind, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CharacterCorpseApi - axios parameter creator
 * @export
 */
export const CharacterCorpseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharacterCorpse
         * @param {ModelsCharacterCorpse} characterCorpse CharacterCorpse
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterCorpse: async (characterCorpse: ModelsCharacterCorpse, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterCorpse' is not null or undefined
            if (characterCorpse === null || characterCorpse === undefined) {
                throw new RequiredError('characterCorpse','Required parameter characterCorpse was null or undefined when calling createCharacterCorpse.');
            }
            const localVarPath = `/character_corpse`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof characterCorpse !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(characterCorpse !== undefined ? characterCorpse : {})
                : (characterCorpse || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes CharacterCorpse
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterCorpse: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteCharacterCorpse.');
            }
            const localVarPath = `/character_corpse/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets CharacterCorpse
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterCorpse: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getCharacterCorpse.');
            }
            const localVarPath = `/character_corpse/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists CharacterCorpses
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharacterCorpses: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/character_corpses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates CharacterCorpse
         * @param {number} id Id
         * @param {ModelsCharacterCorpse} characterCorpse CharacterCorpse
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharacterCorpse: async (id: number, characterCorpse: ModelsCharacterCorpse, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateCharacterCorpse.');
            }
            // verify required parameter 'characterCorpse' is not null or undefined
            if (characterCorpse === null || characterCorpse === undefined) {
                throw new RequiredError('characterCorpse','Required parameter characterCorpse was null or undefined when calling updateCharacterCorpse.');
            }
            const localVarPath = `/character_corpse/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof characterCorpse !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(characterCorpse !== undefined ? characterCorpse : {})
                : (characterCorpse || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CharacterCorpseApi - functional programming interface
 * @export
 */
export const CharacterCorpseApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharacterCorpse
         * @param {ModelsCharacterCorpse} characterCorpse CharacterCorpse
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCharacterCorpse(characterCorpse: ModelsCharacterCorpse, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterCorpse>>> {
            const localVarAxiosArgs = await CharacterCorpseApiAxiosParamCreator(configuration).createCharacterCorpse(characterCorpse, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes CharacterCorpse
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCharacterCorpse(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await CharacterCorpseApiAxiosParamCreator(configuration).deleteCharacterCorpse(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets CharacterCorpse
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharacterCorpse(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterCorpse>>> {
            const localVarAxiosArgs = await CharacterCorpseApiAxiosParamCreator(configuration).getCharacterCorpse(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists CharacterCorpses
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCharacterCorpses(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterCorpse>>> {
            const localVarAxiosArgs = await CharacterCorpseApiAxiosParamCreator(configuration).listCharacterCorpses(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates CharacterCorpse
         * @param {number} id Id
         * @param {ModelsCharacterCorpse} characterCorpse CharacterCorpse
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCharacterCorpse(id: number, characterCorpse: ModelsCharacterCorpse, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterCorpse>>> {
            const localVarAxiosArgs = await CharacterCorpseApiAxiosParamCreator(configuration).updateCharacterCorpse(id, characterCorpse, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CharacterCorpseApi - factory interface
 * @export
 */
export const CharacterCorpseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates CharacterCorpse
         * @param {ModelsCharacterCorpse} characterCorpse CharacterCorpse
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterCorpse(characterCorpse: ModelsCharacterCorpse, options?: any): AxiosPromise<Array<ModelsCharacterCorpse>> {
            return CharacterCorpseApiFp(configuration).createCharacterCorpse(characterCorpse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes CharacterCorpse
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterCorpse(id: number, options?: any): AxiosPromise<string> {
            return CharacterCorpseApiFp(configuration).deleteCharacterCorpse(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets CharacterCorpse
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterCorpse(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharacterCorpse>> {
            return CharacterCorpseApiFp(configuration).getCharacterCorpse(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists CharacterCorpses
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharacterCorpses(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharacterCorpse>> {
            return CharacterCorpseApiFp(configuration).listCharacterCorpses(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates CharacterCorpse
         * @param {number} id Id
         * @param {ModelsCharacterCorpse} characterCorpse CharacterCorpse
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharacterCorpse(id: number, characterCorpse: ModelsCharacterCorpse, options?: any): AxiosPromise<Array<ModelsCharacterCorpse>> {
            return CharacterCorpseApiFp(configuration).updateCharacterCorpse(id, characterCorpse, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCharacterCorpse operation in CharacterCorpseApi.
 * @export
 * @interface CharacterCorpseApiCreateCharacterCorpseRequest
 */
export interface CharacterCorpseApiCreateCharacterCorpseRequest {
    /**
     * CharacterCorpse
     * @type {ModelsCharacterCorpse}
     * @memberof CharacterCorpseApiCreateCharacterCorpse
     */
    readonly characterCorpse: ModelsCharacterCorpse
}

/**
 * Request parameters for deleteCharacterCorpse operation in CharacterCorpseApi.
 * @export
 * @interface CharacterCorpseApiDeleteCharacterCorpseRequest
 */
export interface CharacterCorpseApiDeleteCharacterCorpseRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterCorpseApiDeleteCharacterCorpse
     */
    readonly id: number
}

/**
 * Request parameters for getCharacterCorpse operation in CharacterCorpseApi.
 * @export
 * @interface CharacterCorpseApiGetCharacterCorpseRequest
 */
export interface CharacterCorpseApiGetCharacterCorpseRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterCorpseApiGetCharacterCorpse
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharacterCorpseApiGetCharacterCorpse
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharacterCorpseApiGetCharacterCorpse
     */
    readonly select?: string
}

/**
 * Request parameters for listCharacterCorpses operation in CharacterCorpseApi.
 * @export
 * @interface CharacterCorpseApiListCharacterCorpsesRequest
 */
export interface CharacterCorpseApiListCharacterCorpsesRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharacterCorpseApiListCharacterCorpses
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof CharacterCorpseApiListCharacterCorpses
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof CharacterCorpseApiListCharacterCorpses
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof CharacterCorpseApiListCharacterCorpses
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof CharacterCorpseApiListCharacterCorpses
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharacterCorpseApiListCharacterCorpses
     */
    readonly select?: string
}

/**
 * Request parameters for updateCharacterCorpse operation in CharacterCorpseApi.
 * @export
 * @interface CharacterCorpseApiUpdateCharacterCorpseRequest
 */
export interface CharacterCorpseApiUpdateCharacterCorpseRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterCorpseApiUpdateCharacterCorpse
     */
    readonly id: number

    /**
     * CharacterCorpse
     * @type {ModelsCharacterCorpse}
     * @memberof CharacterCorpseApiUpdateCharacterCorpse
     */
    readonly characterCorpse: ModelsCharacterCorpse
}

/**
 * CharacterCorpseApi - object-oriented interface
 * @export
 * @class CharacterCorpseApi
 * @extends {BaseAPI}
 */
export class CharacterCorpseApi extends BaseAPI {
    /**
     * 
     * @summary Creates CharacterCorpse
     * @param {CharacterCorpseApiCreateCharacterCorpseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterCorpseApi
     */
    public createCharacterCorpse(requestParameters: CharacterCorpseApiCreateCharacterCorpseRequest, options?: any) {
        return CharacterCorpseApiFp(this.configuration).createCharacterCorpse(requestParameters.characterCorpse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes CharacterCorpse
     * @param {CharacterCorpseApiDeleteCharacterCorpseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterCorpseApi
     */
    public deleteCharacterCorpse(requestParameters: CharacterCorpseApiDeleteCharacterCorpseRequest, options?: any) {
        return CharacterCorpseApiFp(this.configuration).deleteCharacterCorpse(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets CharacterCorpse
     * @param {CharacterCorpseApiGetCharacterCorpseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterCorpseApi
     */
    public getCharacterCorpse(requestParameters: CharacterCorpseApiGetCharacterCorpseRequest, options?: any) {
        return CharacterCorpseApiFp(this.configuration).getCharacterCorpse(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists CharacterCorpses
     * @param {CharacterCorpseApiListCharacterCorpsesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterCorpseApi
     */
    public listCharacterCorpses(requestParameters: CharacterCorpseApiListCharacterCorpsesRequest = {}, options?: any) {
        return CharacterCorpseApiFp(this.configuration).listCharacterCorpses(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates CharacterCorpse
     * @param {CharacterCorpseApiUpdateCharacterCorpseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterCorpseApi
     */
    public updateCharacterCorpse(requestParameters: CharacterCorpseApiUpdateCharacterCorpseRequest, options?: any) {
        return CharacterCorpseApiFp(this.configuration).updateCharacterCorpse(requestParameters.id, requestParameters.characterCorpse, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CharacterCurrencyApi - axios parameter creator
 * @export
 */
export const CharacterCurrencyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharacterCurrency
         * @param {ModelsCharacterCurrency} characterCurrency CharacterCurrency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterCurrency: async (characterCurrency: ModelsCharacterCurrency, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterCurrency' is not null or undefined
            if (characterCurrency === null || characterCurrency === undefined) {
                throw new RequiredError('characterCurrency','Required parameter characterCurrency was null or undefined when calling createCharacterCurrency.');
            }
            const localVarPath = `/character_currency`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof characterCurrency !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(characterCurrency !== undefined ? characterCurrency : {})
                : (characterCurrency || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes CharacterCurrency
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterCurrency: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteCharacterCurrency.');
            }
            const localVarPath = `/character_currency/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets CharacterCurrency
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterCurrency: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getCharacterCurrency.');
            }
            const localVarPath = `/character_currency/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists CharacterCurrencies
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharacterCurrencies: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/character_currencies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates CharacterCurrency
         * @param {number} id Id
         * @param {ModelsCharacterCurrency} characterCurrency CharacterCurrency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharacterCurrency: async (id: number, characterCurrency: ModelsCharacterCurrency, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateCharacterCurrency.');
            }
            // verify required parameter 'characterCurrency' is not null or undefined
            if (characterCurrency === null || characterCurrency === undefined) {
                throw new RequiredError('characterCurrency','Required parameter characterCurrency was null or undefined when calling updateCharacterCurrency.');
            }
            const localVarPath = `/character_currency/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof characterCurrency !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(characterCurrency !== undefined ? characterCurrency : {})
                : (characterCurrency || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CharacterCurrencyApi - functional programming interface
 * @export
 */
export const CharacterCurrencyApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharacterCurrency
         * @param {ModelsCharacterCurrency} characterCurrency CharacterCurrency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCharacterCurrency(characterCurrency: ModelsCharacterCurrency, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterCurrency>>> {
            const localVarAxiosArgs = await CharacterCurrencyApiAxiosParamCreator(configuration).createCharacterCurrency(characterCurrency, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes CharacterCurrency
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCharacterCurrency(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await CharacterCurrencyApiAxiosParamCreator(configuration).deleteCharacterCurrency(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets CharacterCurrency
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharacterCurrency(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterCurrency>>> {
            const localVarAxiosArgs = await CharacterCurrencyApiAxiosParamCreator(configuration).getCharacterCurrency(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists CharacterCurrencies
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCharacterCurrencies(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterCurrency>>> {
            const localVarAxiosArgs = await CharacterCurrencyApiAxiosParamCreator(configuration).listCharacterCurrencies(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates CharacterCurrency
         * @param {number} id Id
         * @param {ModelsCharacterCurrency} characterCurrency CharacterCurrency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCharacterCurrency(id: number, characterCurrency: ModelsCharacterCurrency, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterCurrency>>> {
            const localVarAxiosArgs = await CharacterCurrencyApiAxiosParamCreator(configuration).updateCharacterCurrency(id, characterCurrency, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CharacterCurrencyApi - factory interface
 * @export
 */
export const CharacterCurrencyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates CharacterCurrency
         * @param {ModelsCharacterCurrency} characterCurrency CharacterCurrency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterCurrency(characterCurrency: ModelsCharacterCurrency, options?: any): AxiosPromise<Array<ModelsCharacterCurrency>> {
            return CharacterCurrencyApiFp(configuration).createCharacterCurrency(characterCurrency, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes CharacterCurrency
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterCurrency(id: number, options?: any): AxiosPromise<string> {
            return CharacterCurrencyApiFp(configuration).deleteCharacterCurrency(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets CharacterCurrency
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterCurrency(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharacterCurrency>> {
            return CharacterCurrencyApiFp(configuration).getCharacterCurrency(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists CharacterCurrencies
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharacterCurrencies(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharacterCurrency>> {
            return CharacterCurrencyApiFp(configuration).listCharacterCurrencies(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates CharacterCurrency
         * @param {number} id Id
         * @param {ModelsCharacterCurrency} characterCurrency CharacterCurrency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharacterCurrency(id: number, characterCurrency: ModelsCharacterCurrency, options?: any): AxiosPromise<Array<ModelsCharacterCurrency>> {
            return CharacterCurrencyApiFp(configuration).updateCharacterCurrency(id, characterCurrency, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCharacterCurrency operation in CharacterCurrencyApi.
 * @export
 * @interface CharacterCurrencyApiCreateCharacterCurrencyRequest
 */
export interface CharacterCurrencyApiCreateCharacterCurrencyRequest {
    /**
     * CharacterCurrency
     * @type {ModelsCharacterCurrency}
     * @memberof CharacterCurrencyApiCreateCharacterCurrency
     */
    readonly characterCurrency: ModelsCharacterCurrency
}

/**
 * Request parameters for deleteCharacterCurrency operation in CharacterCurrencyApi.
 * @export
 * @interface CharacterCurrencyApiDeleteCharacterCurrencyRequest
 */
export interface CharacterCurrencyApiDeleteCharacterCurrencyRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterCurrencyApiDeleteCharacterCurrency
     */
    readonly id: number
}

/**
 * Request parameters for getCharacterCurrency operation in CharacterCurrencyApi.
 * @export
 * @interface CharacterCurrencyApiGetCharacterCurrencyRequest
 */
export interface CharacterCurrencyApiGetCharacterCurrencyRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterCurrencyApiGetCharacterCurrency
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharacterCurrencyApiGetCharacterCurrency
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharacterCurrencyApiGetCharacterCurrency
     */
    readonly select?: string
}

/**
 * Request parameters for listCharacterCurrencies operation in CharacterCurrencyApi.
 * @export
 * @interface CharacterCurrencyApiListCharacterCurrenciesRequest
 */
export interface CharacterCurrencyApiListCharacterCurrenciesRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharacterCurrencyApiListCharacterCurrencies
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof CharacterCurrencyApiListCharacterCurrencies
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof CharacterCurrencyApiListCharacterCurrencies
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof CharacterCurrencyApiListCharacterCurrencies
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof CharacterCurrencyApiListCharacterCurrencies
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharacterCurrencyApiListCharacterCurrencies
     */
    readonly select?: string
}

/**
 * Request parameters for updateCharacterCurrency operation in CharacterCurrencyApi.
 * @export
 * @interface CharacterCurrencyApiUpdateCharacterCurrencyRequest
 */
export interface CharacterCurrencyApiUpdateCharacterCurrencyRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterCurrencyApiUpdateCharacterCurrency
     */
    readonly id: number

    /**
     * CharacterCurrency
     * @type {ModelsCharacterCurrency}
     * @memberof CharacterCurrencyApiUpdateCharacterCurrency
     */
    readonly characterCurrency: ModelsCharacterCurrency
}

/**
 * CharacterCurrencyApi - object-oriented interface
 * @export
 * @class CharacterCurrencyApi
 * @extends {BaseAPI}
 */
export class CharacterCurrencyApi extends BaseAPI {
    /**
     * 
     * @summary Creates CharacterCurrency
     * @param {CharacterCurrencyApiCreateCharacterCurrencyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterCurrencyApi
     */
    public createCharacterCurrency(requestParameters: CharacterCurrencyApiCreateCharacterCurrencyRequest, options?: any) {
        return CharacterCurrencyApiFp(this.configuration).createCharacterCurrency(requestParameters.characterCurrency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes CharacterCurrency
     * @param {CharacterCurrencyApiDeleteCharacterCurrencyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterCurrencyApi
     */
    public deleteCharacterCurrency(requestParameters: CharacterCurrencyApiDeleteCharacterCurrencyRequest, options?: any) {
        return CharacterCurrencyApiFp(this.configuration).deleteCharacterCurrency(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets CharacterCurrency
     * @param {CharacterCurrencyApiGetCharacterCurrencyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterCurrencyApi
     */
    public getCharacterCurrency(requestParameters: CharacterCurrencyApiGetCharacterCurrencyRequest, options?: any) {
        return CharacterCurrencyApiFp(this.configuration).getCharacterCurrency(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists CharacterCurrencies
     * @param {CharacterCurrencyApiListCharacterCurrenciesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterCurrencyApi
     */
    public listCharacterCurrencies(requestParameters: CharacterCurrencyApiListCharacterCurrenciesRequest = {}, options?: any) {
        return CharacterCurrencyApiFp(this.configuration).listCharacterCurrencies(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates CharacterCurrency
     * @param {CharacterCurrencyApiUpdateCharacterCurrencyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterCurrencyApi
     */
    public updateCharacterCurrency(requestParameters: CharacterCurrencyApiUpdateCharacterCurrencyRequest, options?: any) {
        return CharacterCurrencyApiFp(this.configuration).updateCharacterCurrency(requestParameters.id, requestParameters.characterCurrency, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CharacterDatumApi - axios parameter creator
 * @export
 */
export const CharacterDatumApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharacterDatum
         * @param {ModelsCharacterDatum} characterDatum CharacterDatum
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterDatum: async (characterDatum: ModelsCharacterDatum, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterDatum' is not null or undefined
            if (characterDatum === null || characterDatum === undefined) {
                throw new RequiredError('characterDatum','Required parameter characterDatum was null or undefined when calling createCharacterDatum.');
            }
            const localVarPath = `/character_datum`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof characterDatum !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(characterDatum !== undefined ? characterDatum : {})
                : (characterDatum || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes CharacterDatum
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterDatum: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteCharacterDatum.');
            }
            const localVarPath = `/character_datum/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets CharacterDatum
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;AdventureStats&lt;br&gt;Buyers&lt;br&gt;CharRecipeLists&lt;br&gt;CharacterActivities&lt;br&gt;CharacterAltCurrencies&lt;br&gt;CharacterAlternateAbilities&lt;br&gt;CharacterAuras&lt;br&gt;CharacterBandoliers&lt;br&gt;CharacterBinds&lt;br&gt;CharacterBuffs&lt;br&gt;CharacterCorpses&lt;br&gt;CharacterCurrencies&lt;br&gt;CharacterDisciplines&lt;br&gt;CharacterEnabledtasks&lt;br&gt;CharacterInspectMessages&lt;br&gt;CharacterItemRecasts&lt;br&gt;CharacterLanguages&lt;br&gt;CharacterLeadershipAbilities&lt;br&gt;CharacterMaterials&lt;br&gt;CharacterMemmedSpells&lt;br&gt;CharacterPetBuffs&lt;br&gt;CharacterPetInfos&lt;br&gt;CharacterPetInventories&lt;br&gt;CharacterPotionbelts&lt;br&gt;CharacterSkills&lt;br&gt;CharacterSpells&lt;br&gt;CharacterTasks&lt;br&gt;CharacterTributes&lt;br&gt;CompletedTasks&lt;br&gt;DataBuckets&lt;br&gt;FactionValues&lt;br&gt;Friends&lt;br&gt;Guild&lt;br&gt;Guild.GuildBanks&lt;br&gt;Guild.GuildMembers&lt;br&gt;Guild.GuildRanks&lt;br&gt;GuildMembers&lt;br&gt;InstanceListPlayers&lt;br&gt;Inventories&lt;br&gt;Inventories.Item&lt;br&gt;Inventories.Item.DiscoveredItems&lt;br&gt;Keyrings&lt;br&gt;Mail&lt;br&gt;PlayerTitlesets&lt;br&gt;QuestGlobals&lt;br&gt;Timers&lt;br&gt;Titles&lt;br&gt;Traders&lt;br&gt;ZoneFlags
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterDatum: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getCharacterDatum.');
            }
            const localVarPath = `/character_datum/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists CharacterData
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;AdventureStats&lt;br&gt;Buyers&lt;br&gt;CharRecipeLists&lt;br&gt;CharacterActivities&lt;br&gt;CharacterAltCurrencies&lt;br&gt;CharacterAlternateAbilities&lt;br&gt;CharacterAuras&lt;br&gt;CharacterBandoliers&lt;br&gt;CharacterBinds&lt;br&gt;CharacterBuffs&lt;br&gt;CharacterCorpses&lt;br&gt;CharacterCurrencies&lt;br&gt;CharacterDisciplines&lt;br&gt;CharacterEnabledtasks&lt;br&gt;CharacterInspectMessages&lt;br&gt;CharacterItemRecasts&lt;br&gt;CharacterLanguages&lt;br&gt;CharacterLeadershipAbilities&lt;br&gt;CharacterMaterials&lt;br&gt;CharacterMemmedSpells&lt;br&gt;CharacterPetBuffs&lt;br&gt;CharacterPetInfos&lt;br&gt;CharacterPetInventories&lt;br&gt;CharacterPotionbelts&lt;br&gt;CharacterSkills&lt;br&gt;CharacterSpells&lt;br&gt;CharacterTasks&lt;br&gt;CharacterTributes&lt;br&gt;CompletedTasks&lt;br&gt;DataBuckets&lt;br&gt;FactionValues&lt;br&gt;Friends&lt;br&gt;Guild&lt;br&gt;Guild.GuildBanks&lt;br&gt;Guild.GuildMembers&lt;br&gt;Guild.GuildRanks&lt;br&gt;GuildMembers&lt;br&gt;InstanceListPlayers&lt;br&gt;Inventories&lt;br&gt;Inventories.Item&lt;br&gt;Inventories.Item.DiscoveredItems&lt;br&gt;Keyrings&lt;br&gt;Mail&lt;br&gt;PlayerTitlesets&lt;br&gt;QuestGlobals&lt;br&gt;Timers&lt;br&gt;Titles&lt;br&gt;Traders&lt;br&gt;ZoneFlags
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharacterData: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/character_data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates CharacterDatum
         * @param {number} id Id
         * @param {ModelsCharacterDatum} characterDatum CharacterDatum
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharacterDatum: async (id: number, characterDatum: ModelsCharacterDatum, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateCharacterDatum.');
            }
            // verify required parameter 'characterDatum' is not null or undefined
            if (characterDatum === null || characterDatum === undefined) {
                throw new RequiredError('characterDatum','Required parameter characterDatum was null or undefined when calling updateCharacterDatum.');
            }
            const localVarPath = `/character_datum/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof characterDatum !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(characterDatum !== undefined ? characterDatum : {})
                : (characterDatum || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CharacterDatumApi - functional programming interface
 * @export
 */
export const CharacterDatumApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharacterDatum
         * @param {ModelsCharacterDatum} characterDatum CharacterDatum
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCharacterDatum(characterDatum: ModelsCharacterDatum, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterDatum>>> {
            const localVarAxiosArgs = await CharacterDatumApiAxiosParamCreator(configuration).createCharacterDatum(characterDatum, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes CharacterDatum
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCharacterDatum(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await CharacterDatumApiAxiosParamCreator(configuration).deleteCharacterDatum(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets CharacterDatum
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;AdventureStats&lt;br&gt;Buyers&lt;br&gt;CharRecipeLists&lt;br&gt;CharacterActivities&lt;br&gt;CharacterAltCurrencies&lt;br&gt;CharacterAlternateAbilities&lt;br&gt;CharacterAuras&lt;br&gt;CharacterBandoliers&lt;br&gt;CharacterBinds&lt;br&gt;CharacterBuffs&lt;br&gt;CharacterCorpses&lt;br&gt;CharacterCurrencies&lt;br&gt;CharacterDisciplines&lt;br&gt;CharacterEnabledtasks&lt;br&gt;CharacterInspectMessages&lt;br&gt;CharacterItemRecasts&lt;br&gt;CharacterLanguages&lt;br&gt;CharacterLeadershipAbilities&lt;br&gt;CharacterMaterials&lt;br&gt;CharacterMemmedSpells&lt;br&gt;CharacterPetBuffs&lt;br&gt;CharacterPetInfos&lt;br&gt;CharacterPetInventories&lt;br&gt;CharacterPotionbelts&lt;br&gt;CharacterSkills&lt;br&gt;CharacterSpells&lt;br&gt;CharacterTasks&lt;br&gt;CharacterTributes&lt;br&gt;CompletedTasks&lt;br&gt;DataBuckets&lt;br&gt;FactionValues&lt;br&gt;Friends&lt;br&gt;Guild&lt;br&gt;Guild.GuildBanks&lt;br&gt;Guild.GuildMembers&lt;br&gt;Guild.GuildRanks&lt;br&gt;GuildMembers&lt;br&gt;InstanceListPlayers&lt;br&gt;Inventories&lt;br&gt;Inventories.Item&lt;br&gt;Inventories.Item.DiscoveredItems&lt;br&gt;Keyrings&lt;br&gt;Mail&lt;br&gt;PlayerTitlesets&lt;br&gt;QuestGlobals&lt;br&gt;Timers&lt;br&gt;Titles&lt;br&gt;Traders&lt;br&gt;ZoneFlags
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharacterDatum(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterDatum>>> {
            const localVarAxiosArgs = await CharacterDatumApiAxiosParamCreator(configuration).getCharacterDatum(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists CharacterData
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;AdventureStats&lt;br&gt;Buyers&lt;br&gt;CharRecipeLists&lt;br&gt;CharacterActivities&lt;br&gt;CharacterAltCurrencies&lt;br&gt;CharacterAlternateAbilities&lt;br&gt;CharacterAuras&lt;br&gt;CharacterBandoliers&lt;br&gt;CharacterBinds&lt;br&gt;CharacterBuffs&lt;br&gt;CharacterCorpses&lt;br&gt;CharacterCurrencies&lt;br&gt;CharacterDisciplines&lt;br&gt;CharacterEnabledtasks&lt;br&gt;CharacterInspectMessages&lt;br&gt;CharacterItemRecasts&lt;br&gt;CharacterLanguages&lt;br&gt;CharacterLeadershipAbilities&lt;br&gt;CharacterMaterials&lt;br&gt;CharacterMemmedSpells&lt;br&gt;CharacterPetBuffs&lt;br&gt;CharacterPetInfos&lt;br&gt;CharacterPetInventories&lt;br&gt;CharacterPotionbelts&lt;br&gt;CharacterSkills&lt;br&gt;CharacterSpells&lt;br&gt;CharacterTasks&lt;br&gt;CharacterTributes&lt;br&gt;CompletedTasks&lt;br&gt;DataBuckets&lt;br&gt;FactionValues&lt;br&gt;Friends&lt;br&gt;Guild&lt;br&gt;Guild.GuildBanks&lt;br&gt;Guild.GuildMembers&lt;br&gt;Guild.GuildRanks&lt;br&gt;GuildMembers&lt;br&gt;InstanceListPlayers&lt;br&gt;Inventories&lt;br&gt;Inventories.Item&lt;br&gt;Inventories.Item.DiscoveredItems&lt;br&gt;Keyrings&lt;br&gt;Mail&lt;br&gt;PlayerTitlesets&lt;br&gt;QuestGlobals&lt;br&gt;Timers&lt;br&gt;Titles&lt;br&gt;Traders&lt;br&gt;ZoneFlags
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCharacterData(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterDatum>>> {
            const localVarAxiosArgs = await CharacterDatumApiAxiosParamCreator(configuration).listCharacterData(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates CharacterDatum
         * @param {number} id Id
         * @param {ModelsCharacterDatum} characterDatum CharacterDatum
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCharacterDatum(id: number, characterDatum: ModelsCharacterDatum, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterDatum>>> {
            const localVarAxiosArgs = await CharacterDatumApiAxiosParamCreator(configuration).updateCharacterDatum(id, characterDatum, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CharacterDatumApi - factory interface
 * @export
 */
export const CharacterDatumApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates CharacterDatum
         * @param {ModelsCharacterDatum} characterDatum CharacterDatum
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterDatum(characterDatum: ModelsCharacterDatum, options?: any): AxiosPromise<Array<ModelsCharacterDatum>> {
            return CharacterDatumApiFp(configuration).createCharacterDatum(characterDatum, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes CharacterDatum
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterDatum(id: number, options?: any): AxiosPromise<string> {
            return CharacterDatumApiFp(configuration).deleteCharacterDatum(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets CharacterDatum
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;AdventureStats&lt;br&gt;Buyers&lt;br&gt;CharRecipeLists&lt;br&gt;CharacterActivities&lt;br&gt;CharacterAltCurrencies&lt;br&gt;CharacterAlternateAbilities&lt;br&gt;CharacterAuras&lt;br&gt;CharacterBandoliers&lt;br&gt;CharacterBinds&lt;br&gt;CharacterBuffs&lt;br&gt;CharacterCorpses&lt;br&gt;CharacterCurrencies&lt;br&gt;CharacterDisciplines&lt;br&gt;CharacterEnabledtasks&lt;br&gt;CharacterInspectMessages&lt;br&gt;CharacterItemRecasts&lt;br&gt;CharacterLanguages&lt;br&gt;CharacterLeadershipAbilities&lt;br&gt;CharacterMaterials&lt;br&gt;CharacterMemmedSpells&lt;br&gt;CharacterPetBuffs&lt;br&gt;CharacterPetInfos&lt;br&gt;CharacterPetInventories&lt;br&gt;CharacterPotionbelts&lt;br&gt;CharacterSkills&lt;br&gt;CharacterSpells&lt;br&gt;CharacterTasks&lt;br&gt;CharacterTributes&lt;br&gt;CompletedTasks&lt;br&gt;DataBuckets&lt;br&gt;FactionValues&lt;br&gt;Friends&lt;br&gt;Guild&lt;br&gt;Guild.GuildBanks&lt;br&gt;Guild.GuildMembers&lt;br&gt;Guild.GuildRanks&lt;br&gt;GuildMembers&lt;br&gt;InstanceListPlayers&lt;br&gt;Inventories&lt;br&gt;Inventories.Item&lt;br&gt;Inventories.Item.DiscoveredItems&lt;br&gt;Keyrings&lt;br&gt;Mail&lt;br&gt;PlayerTitlesets&lt;br&gt;QuestGlobals&lt;br&gt;Timers&lt;br&gt;Titles&lt;br&gt;Traders&lt;br&gt;ZoneFlags
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterDatum(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharacterDatum>> {
            return CharacterDatumApiFp(configuration).getCharacterDatum(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists CharacterData
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;AdventureStats&lt;br&gt;Buyers&lt;br&gt;CharRecipeLists&lt;br&gt;CharacterActivities&lt;br&gt;CharacterAltCurrencies&lt;br&gt;CharacterAlternateAbilities&lt;br&gt;CharacterAuras&lt;br&gt;CharacterBandoliers&lt;br&gt;CharacterBinds&lt;br&gt;CharacterBuffs&lt;br&gt;CharacterCorpses&lt;br&gt;CharacterCurrencies&lt;br&gt;CharacterDisciplines&lt;br&gt;CharacterEnabledtasks&lt;br&gt;CharacterInspectMessages&lt;br&gt;CharacterItemRecasts&lt;br&gt;CharacterLanguages&lt;br&gt;CharacterLeadershipAbilities&lt;br&gt;CharacterMaterials&lt;br&gt;CharacterMemmedSpells&lt;br&gt;CharacterPetBuffs&lt;br&gt;CharacterPetInfos&lt;br&gt;CharacterPetInventories&lt;br&gt;CharacterPotionbelts&lt;br&gt;CharacterSkills&lt;br&gt;CharacterSpells&lt;br&gt;CharacterTasks&lt;br&gt;CharacterTributes&lt;br&gt;CompletedTasks&lt;br&gt;DataBuckets&lt;br&gt;FactionValues&lt;br&gt;Friends&lt;br&gt;Guild&lt;br&gt;Guild.GuildBanks&lt;br&gt;Guild.GuildMembers&lt;br&gt;Guild.GuildRanks&lt;br&gt;GuildMembers&lt;br&gt;InstanceListPlayers&lt;br&gt;Inventories&lt;br&gt;Inventories.Item&lt;br&gt;Inventories.Item.DiscoveredItems&lt;br&gt;Keyrings&lt;br&gt;Mail&lt;br&gt;PlayerTitlesets&lt;br&gt;QuestGlobals&lt;br&gt;Timers&lt;br&gt;Titles&lt;br&gt;Traders&lt;br&gt;ZoneFlags
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharacterData(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharacterDatum>> {
            return CharacterDatumApiFp(configuration).listCharacterData(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates CharacterDatum
         * @param {number} id Id
         * @param {ModelsCharacterDatum} characterDatum CharacterDatum
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharacterDatum(id: number, characterDatum: ModelsCharacterDatum, options?: any): AxiosPromise<Array<ModelsCharacterDatum>> {
            return CharacterDatumApiFp(configuration).updateCharacterDatum(id, characterDatum, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCharacterDatum operation in CharacterDatumApi.
 * @export
 * @interface CharacterDatumApiCreateCharacterDatumRequest
 */
export interface CharacterDatumApiCreateCharacterDatumRequest {
    /**
     * CharacterDatum
     * @type {ModelsCharacterDatum}
     * @memberof CharacterDatumApiCreateCharacterDatum
     */
    readonly characterDatum: ModelsCharacterDatum
}

/**
 * Request parameters for deleteCharacterDatum operation in CharacterDatumApi.
 * @export
 * @interface CharacterDatumApiDeleteCharacterDatumRequest
 */
export interface CharacterDatumApiDeleteCharacterDatumRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterDatumApiDeleteCharacterDatum
     */
    readonly id: number
}

/**
 * Request parameters for getCharacterDatum operation in CharacterDatumApi.
 * @export
 * @interface CharacterDatumApiGetCharacterDatumRequest
 */
export interface CharacterDatumApiGetCharacterDatumRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterDatumApiGetCharacterDatum
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;AdventureStats&lt;br&gt;Buyers&lt;br&gt;CharRecipeLists&lt;br&gt;CharacterActivities&lt;br&gt;CharacterAltCurrencies&lt;br&gt;CharacterAlternateAbilities&lt;br&gt;CharacterAuras&lt;br&gt;CharacterBandoliers&lt;br&gt;CharacterBinds&lt;br&gt;CharacterBuffs&lt;br&gt;CharacterCorpses&lt;br&gt;CharacterCurrencies&lt;br&gt;CharacterDisciplines&lt;br&gt;CharacterEnabledtasks&lt;br&gt;CharacterInspectMessages&lt;br&gt;CharacterItemRecasts&lt;br&gt;CharacterLanguages&lt;br&gt;CharacterLeadershipAbilities&lt;br&gt;CharacterMaterials&lt;br&gt;CharacterMemmedSpells&lt;br&gt;CharacterPetBuffs&lt;br&gt;CharacterPetInfos&lt;br&gt;CharacterPetInventories&lt;br&gt;CharacterPotionbelts&lt;br&gt;CharacterSkills&lt;br&gt;CharacterSpells&lt;br&gt;CharacterTasks&lt;br&gt;CharacterTributes&lt;br&gt;CompletedTasks&lt;br&gt;DataBuckets&lt;br&gt;FactionValues&lt;br&gt;Friends&lt;br&gt;Guild&lt;br&gt;Guild.GuildBanks&lt;br&gt;Guild.GuildMembers&lt;br&gt;Guild.GuildRanks&lt;br&gt;GuildMembers&lt;br&gt;InstanceListPlayers&lt;br&gt;Inventories&lt;br&gt;Inventories.Item&lt;br&gt;Inventories.Item.DiscoveredItems&lt;br&gt;Keyrings&lt;br&gt;Mail&lt;br&gt;PlayerTitlesets&lt;br&gt;QuestGlobals&lt;br&gt;Timers&lt;br&gt;Titles&lt;br&gt;Traders&lt;br&gt;ZoneFlags
     * @type {string}
     * @memberof CharacterDatumApiGetCharacterDatum
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharacterDatumApiGetCharacterDatum
     */
    readonly select?: string
}

/**
 * Request parameters for listCharacterData operation in CharacterDatumApi.
 * @export
 * @interface CharacterDatumApiListCharacterDataRequest
 */
export interface CharacterDatumApiListCharacterDataRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;AdventureStats&lt;br&gt;Buyers&lt;br&gt;CharRecipeLists&lt;br&gt;CharacterActivities&lt;br&gt;CharacterAltCurrencies&lt;br&gt;CharacterAlternateAbilities&lt;br&gt;CharacterAuras&lt;br&gt;CharacterBandoliers&lt;br&gt;CharacterBinds&lt;br&gt;CharacterBuffs&lt;br&gt;CharacterCorpses&lt;br&gt;CharacterCurrencies&lt;br&gt;CharacterDisciplines&lt;br&gt;CharacterEnabledtasks&lt;br&gt;CharacterInspectMessages&lt;br&gt;CharacterItemRecasts&lt;br&gt;CharacterLanguages&lt;br&gt;CharacterLeadershipAbilities&lt;br&gt;CharacterMaterials&lt;br&gt;CharacterMemmedSpells&lt;br&gt;CharacterPetBuffs&lt;br&gt;CharacterPetInfos&lt;br&gt;CharacterPetInventories&lt;br&gt;CharacterPotionbelts&lt;br&gt;CharacterSkills&lt;br&gt;CharacterSpells&lt;br&gt;CharacterTasks&lt;br&gt;CharacterTributes&lt;br&gt;CompletedTasks&lt;br&gt;DataBuckets&lt;br&gt;FactionValues&lt;br&gt;Friends&lt;br&gt;Guild&lt;br&gt;Guild.GuildBanks&lt;br&gt;Guild.GuildMembers&lt;br&gt;Guild.GuildRanks&lt;br&gt;GuildMembers&lt;br&gt;InstanceListPlayers&lt;br&gt;Inventories&lt;br&gt;Inventories.Item&lt;br&gt;Inventories.Item.DiscoveredItems&lt;br&gt;Keyrings&lt;br&gt;Mail&lt;br&gt;PlayerTitlesets&lt;br&gt;QuestGlobals&lt;br&gt;Timers&lt;br&gt;Titles&lt;br&gt;Traders&lt;br&gt;ZoneFlags
     * @type {string}
     * @memberof CharacterDatumApiListCharacterData
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof CharacterDatumApiListCharacterData
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof CharacterDatumApiListCharacterData
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof CharacterDatumApiListCharacterData
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof CharacterDatumApiListCharacterData
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharacterDatumApiListCharacterData
     */
    readonly select?: string
}

/**
 * Request parameters for updateCharacterDatum operation in CharacterDatumApi.
 * @export
 * @interface CharacterDatumApiUpdateCharacterDatumRequest
 */
export interface CharacterDatumApiUpdateCharacterDatumRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterDatumApiUpdateCharacterDatum
     */
    readonly id: number

    /**
     * CharacterDatum
     * @type {ModelsCharacterDatum}
     * @memberof CharacterDatumApiUpdateCharacterDatum
     */
    readonly characterDatum: ModelsCharacterDatum
}

/**
 * CharacterDatumApi - object-oriented interface
 * @export
 * @class CharacterDatumApi
 * @extends {BaseAPI}
 */
export class CharacterDatumApi extends BaseAPI {
    /**
     * 
     * @summary Creates CharacterDatum
     * @param {CharacterDatumApiCreateCharacterDatumRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterDatumApi
     */
    public createCharacterDatum(requestParameters: CharacterDatumApiCreateCharacterDatumRequest, options?: any) {
        return CharacterDatumApiFp(this.configuration).createCharacterDatum(requestParameters.characterDatum, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes CharacterDatum
     * @param {CharacterDatumApiDeleteCharacterDatumRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterDatumApi
     */
    public deleteCharacterDatum(requestParameters: CharacterDatumApiDeleteCharacterDatumRequest, options?: any) {
        return CharacterDatumApiFp(this.configuration).deleteCharacterDatum(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets CharacterDatum
     * @param {CharacterDatumApiGetCharacterDatumRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterDatumApi
     */
    public getCharacterDatum(requestParameters: CharacterDatumApiGetCharacterDatumRequest, options?: any) {
        return CharacterDatumApiFp(this.configuration).getCharacterDatum(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists CharacterData
     * @param {CharacterDatumApiListCharacterDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterDatumApi
     */
    public listCharacterData(requestParameters: CharacterDatumApiListCharacterDataRequest = {}, options?: any) {
        return CharacterDatumApiFp(this.configuration).listCharacterData(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates CharacterDatum
     * @param {CharacterDatumApiUpdateCharacterDatumRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterDatumApi
     */
    public updateCharacterDatum(requestParameters: CharacterDatumApiUpdateCharacterDatumRequest, options?: any) {
        return CharacterDatumApiFp(this.configuration).updateCharacterDatum(requestParameters.id, requestParameters.characterDatum, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CharacterDisciplineApi - axios parameter creator
 * @export
 */
export const CharacterDisciplineApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharacterDiscipline
         * @param {ModelsCharacterDiscipline} characterDiscipline CharacterDiscipline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterDiscipline: async (characterDiscipline: ModelsCharacterDiscipline, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterDiscipline' is not null or undefined
            if (characterDiscipline === null || characterDiscipline === undefined) {
                throw new RequiredError('characterDiscipline','Required parameter characterDiscipline was null or undefined when calling createCharacterDiscipline.');
            }
            const localVarPath = `/character_discipline`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof characterDiscipline !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(characterDiscipline !== undefined ? characterDiscipline : {})
                : (characterDiscipline || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes CharacterDiscipline
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterDiscipline: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteCharacterDiscipline.');
            }
            const localVarPath = `/character_discipline/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets CharacterDiscipline
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterDiscipline: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getCharacterDiscipline.');
            }
            const localVarPath = `/character_discipline/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists CharacterDisciplines
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharacterDisciplines: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/character_disciplines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates CharacterDiscipline
         * @param {number} id Id
         * @param {ModelsCharacterDiscipline} characterDiscipline CharacterDiscipline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharacterDiscipline: async (id: number, characterDiscipline: ModelsCharacterDiscipline, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateCharacterDiscipline.');
            }
            // verify required parameter 'characterDiscipline' is not null or undefined
            if (characterDiscipline === null || characterDiscipline === undefined) {
                throw new RequiredError('characterDiscipline','Required parameter characterDiscipline was null or undefined when calling updateCharacterDiscipline.');
            }
            const localVarPath = `/character_discipline/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof characterDiscipline !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(characterDiscipline !== undefined ? characterDiscipline : {})
                : (characterDiscipline || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CharacterDisciplineApi - functional programming interface
 * @export
 */
export const CharacterDisciplineApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharacterDiscipline
         * @param {ModelsCharacterDiscipline} characterDiscipline CharacterDiscipline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCharacterDiscipline(characterDiscipline: ModelsCharacterDiscipline, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterDiscipline>>> {
            const localVarAxiosArgs = await CharacterDisciplineApiAxiosParamCreator(configuration).createCharacterDiscipline(characterDiscipline, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes CharacterDiscipline
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCharacterDiscipline(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await CharacterDisciplineApiAxiosParamCreator(configuration).deleteCharacterDiscipline(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets CharacterDiscipline
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharacterDiscipline(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterDiscipline>>> {
            const localVarAxiosArgs = await CharacterDisciplineApiAxiosParamCreator(configuration).getCharacterDiscipline(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists CharacterDisciplines
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCharacterDisciplines(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterDiscipline>>> {
            const localVarAxiosArgs = await CharacterDisciplineApiAxiosParamCreator(configuration).listCharacterDisciplines(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates CharacterDiscipline
         * @param {number} id Id
         * @param {ModelsCharacterDiscipline} characterDiscipline CharacterDiscipline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCharacterDiscipline(id: number, characterDiscipline: ModelsCharacterDiscipline, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterDiscipline>>> {
            const localVarAxiosArgs = await CharacterDisciplineApiAxiosParamCreator(configuration).updateCharacterDiscipline(id, characterDiscipline, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CharacterDisciplineApi - factory interface
 * @export
 */
export const CharacterDisciplineApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates CharacterDiscipline
         * @param {ModelsCharacterDiscipline} characterDiscipline CharacterDiscipline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterDiscipline(characterDiscipline: ModelsCharacterDiscipline, options?: any): AxiosPromise<Array<ModelsCharacterDiscipline>> {
            return CharacterDisciplineApiFp(configuration).createCharacterDiscipline(characterDiscipline, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes CharacterDiscipline
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterDiscipline(id: number, options?: any): AxiosPromise<string> {
            return CharacterDisciplineApiFp(configuration).deleteCharacterDiscipline(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets CharacterDiscipline
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterDiscipline(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharacterDiscipline>> {
            return CharacterDisciplineApiFp(configuration).getCharacterDiscipline(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists CharacterDisciplines
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharacterDisciplines(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharacterDiscipline>> {
            return CharacterDisciplineApiFp(configuration).listCharacterDisciplines(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates CharacterDiscipline
         * @param {number} id Id
         * @param {ModelsCharacterDiscipline} characterDiscipline CharacterDiscipline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharacterDiscipline(id: number, characterDiscipline: ModelsCharacterDiscipline, options?: any): AxiosPromise<Array<ModelsCharacterDiscipline>> {
            return CharacterDisciplineApiFp(configuration).updateCharacterDiscipline(id, characterDiscipline, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCharacterDiscipline operation in CharacterDisciplineApi.
 * @export
 * @interface CharacterDisciplineApiCreateCharacterDisciplineRequest
 */
export interface CharacterDisciplineApiCreateCharacterDisciplineRequest {
    /**
     * CharacterDiscipline
     * @type {ModelsCharacterDiscipline}
     * @memberof CharacterDisciplineApiCreateCharacterDiscipline
     */
    readonly characterDiscipline: ModelsCharacterDiscipline
}

/**
 * Request parameters for deleteCharacterDiscipline operation in CharacterDisciplineApi.
 * @export
 * @interface CharacterDisciplineApiDeleteCharacterDisciplineRequest
 */
export interface CharacterDisciplineApiDeleteCharacterDisciplineRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterDisciplineApiDeleteCharacterDiscipline
     */
    readonly id: number
}

/**
 * Request parameters for getCharacterDiscipline operation in CharacterDisciplineApi.
 * @export
 * @interface CharacterDisciplineApiGetCharacterDisciplineRequest
 */
export interface CharacterDisciplineApiGetCharacterDisciplineRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterDisciplineApiGetCharacterDiscipline
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharacterDisciplineApiGetCharacterDiscipline
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharacterDisciplineApiGetCharacterDiscipline
     */
    readonly select?: string
}

/**
 * Request parameters for listCharacterDisciplines operation in CharacterDisciplineApi.
 * @export
 * @interface CharacterDisciplineApiListCharacterDisciplinesRequest
 */
export interface CharacterDisciplineApiListCharacterDisciplinesRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharacterDisciplineApiListCharacterDisciplines
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof CharacterDisciplineApiListCharacterDisciplines
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof CharacterDisciplineApiListCharacterDisciplines
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof CharacterDisciplineApiListCharacterDisciplines
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof CharacterDisciplineApiListCharacterDisciplines
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharacterDisciplineApiListCharacterDisciplines
     */
    readonly select?: string
}

/**
 * Request parameters for updateCharacterDiscipline operation in CharacterDisciplineApi.
 * @export
 * @interface CharacterDisciplineApiUpdateCharacterDisciplineRequest
 */
export interface CharacterDisciplineApiUpdateCharacterDisciplineRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterDisciplineApiUpdateCharacterDiscipline
     */
    readonly id: number

    /**
     * CharacterDiscipline
     * @type {ModelsCharacterDiscipline}
     * @memberof CharacterDisciplineApiUpdateCharacterDiscipline
     */
    readonly characterDiscipline: ModelsCharacterDiscipline
}

/**
 * CharacterDisciplineApi - object-oriented interface
 * @export
 * @class CharacterDisciplineApi
 * @extends {BaseAPI}
 */
export class CharacterDisciplineApi extends BaseAPI {
    /**
     * 
     * @summary Creates CharacterDiscipline
     * @param {CharacterDisciplineApiCreateCharacterDisciplineRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterDisciplineApi
     */
    public createCharacterDiscipline(requestParameters: CharacterDisciplineApiCreateCharacterDisciplineRequest, options?: any) {
        return CharacterDisciplineApiFp(this.configuration).createCharacterDiscipline(requestParameters.characterDiscipline, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes CharacterDiscipline
     * @param {CharacterDisciplineApiDeleteCharacterDisciplineRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterDisciplineApi
     */
    public deleteCharacterDiscipline(requestParameters: CharacterDisciplineApiDeleteCharacterDisciplineRequest, options?: any) {
        return CharacterDisciplineApiFp(this.configuration).deleteCharacterDiscipline(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets CharacterDiscipline
     * @param {CharacterDisciplineApiGetCharacterDisciplineRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterDisciplineApi
     */
    public getCharacterDiscipline(requestParameters: CharacterDisciplineApiGetCharacterDisciplineRequest, options?: any) {
        return CharacterDisciplineApiFp(this.configuration).getCharacterDiscipline(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists CharacterDisciplines
     * @param {CharacterDisciplineApiListCharacterDisciplinesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterDisciplineApi
     */
    public listCharacterDisciplines(requestParameters: CharacterDisciplineApiListCharacterDisciplinesRequest = {}, options?: any) {
        return CharacterDisciplineApiFp(this.configuration).listCharacterDisciplines(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates CharacterDiscipline
     * @param {CharacterDisciplineApiUpdateCharacterDisciplineRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterDisciplineApi
     */
    public updateCharacterDiscipline(requestParameters: CharacterDisciplineApiUpdateCharacterDisciplineRequest, options?: any) {
        return CharacterDisciplineApiFp(this.configuration).updateCharacterDiscipline(requestParameters.id, requestParameters.characterDiscipline, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CharacterInspectMessageApi - axios parameter creator
 * @export
 */
export const CharacterInspectMessageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharacterInspectMessage
         * @param {ModelsCharacterInspectMessage} characterInspectMessage CharacterInspectMessage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterInspectMessage: async (characterInspectMessage: ModelsCharacterInspectMessage, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterInspectMessage' is not null or undefined
            if (characterInspectMessage === null || characterInspectMessage === undefined) {
                throw new RequiredError('characterInspectMessage','Required parameter characterInspectMessage was null or undefined when calling createCharacterInspectMessage.');
            }
            const localVarPath = `/character_inspect_message`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof characterInspectMessage !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(characterInspectMessage !== undefined ? characterInspectMessage : {})
                : (characterInspectMessage || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes CharacterInspectMessage
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterInspectMessage: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteCharacterInspectMessage.');
            }
            const localVarPath = `/character_inspect_message/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets CharacterInspectMessage
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterInspectMessage: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getCharacterInspectMessage.');
            }
            const localVarPath = `/character_inspect_message/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists CharacterInspectMessages
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharacterInspectMessages: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/character_inspect_messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates CharacterInspectMessage
         * @param {number} id Id
         * @param {ModelsCharacterInspectMessage} characterInspectMessage CharacterInspectMessage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharacterInspectMessage: async (id: number, characterInspectMessage: ModelsCharacterInspectMessage, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateCharacterInspectMessage.');
            }
            // verify required parameter 'characterInspectMessage' is not null or undefined
            if (characterInspectMessage === null || characterInspectMessage === undefined) {
                throw new RequiredError('characterInspectMessage','Required parameter characterInspectMessage was null or undefined when calling updateCharacterInspectMessage.');
            }
            const localVarPath = `/character_inspect_message/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof characterInspectMessage !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(characterInspectMessage !== undefined ? characterInspectMessage : {})
                : (characterInspectMessage || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CharacterInspectMessageApi - functional programming interface
 * @export
 */
export const CharacterInspectMessageApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharacterInspectMessage
         * @param {ModelsCharacterInspectMessage} characterInspectMessage CharacterInspectMessage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCharacterInspectMessage(characterInspectMessage: ModelsCharacterInspectMessage, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterInspectMessage>>> {
            const localVarAxiosArgs = await CharacterInspectMessageApiAxiosParamCreator(configuration).createCharacterInspectMessage(characterInspectMessage, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes CharacterInspectMessage
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCharacterInspectMessage(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await CharacterInspectMessageApiAxiosParamCreator(configuration).deleteCharacterInspectMessage(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets CharacterInspectMessage
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharacterInspectMessage(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterInspectMessage>>> {
            const localVarAxiosArgs = await CharacterInspectMessageApiAxiosParamCreator(configuration).getCharacterInspectMessage(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists CharacterInspectMessages
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCharacterInspectMessages(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterInspectMessage>>> {
            const localVarAxiosArgs = await CharacterInspectMessageApiAxiosParamCreator(configuration).listCharacterInspectMessages(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates CharacterInspectMessage
         * @param {number} id Id
         * @param {ModelsCharacterInspectMessage} characterInspectMessage CharacterInspectMessage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCharacterInspectMessage(id: number, characterInspectMessage: ModelsCharacterInspectMessage, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterInspectMessage>>> {
            const localVarAxiosArgs = await CharacterInspectMessageApiAxiosParamCreator(configuration).updateCharacterInspectMessage(id, characterInspectMessage, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CharacterInspectMessageApi - factory interface
 * @export
 */
export const CharacterInspectMessageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates CharacterInspectMessage
         * @param {ModelsCharacterInspectMessage} characterInspectMessage CharacterInspectMessage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterInspectMessage(characterInspectMessage: ModelsCharacterInspectMessage, options?: any): AxiosPromise<Array<ModelsCharacterInspectMessage>> {
            return CharacterInspectMessageApiFp(configuration).createCharacterInspectMessage(characterInspectMessage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes CharacterInspectMessage
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterInspectMessage(id: number, options?: any): AxiosPromise<string> {
            return CharacterInspectMessageApiFp(configuration).deleteCharacterInspectMessage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets CharacterInspectMessage
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterInspectMessage(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharacterInspectMessage>> {
            return CharacterInspectMessageApiFp(configuration).getCharacterInspectMessage(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists CharacterInspectMessages
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharacterInspectMessages(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharacterInspectMessage>> {
            return CharacterInspectMessageApiFp(configuration).listCharacterInspectMessages(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates CharacterInspectMessage
         * @param {number} id Id
         * @param {ModelsCharacterInspectMessage} characterInspectMessage CharacterInspectMessage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharacterInspectMessage(id: number, characterInspectMessage: ModelsCharacterInspectMessage, options?: any): AxiosPromise<Array<ModelsCharacterInspectMessage>> {
            return CharacterInspectMessageApiFp(configuration).updateCharacterInspectMessage(id, characterInspectMessage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCharacterInspectMessage operation in CharacterInspectMessageApi.
 * @export
 * @interface CharacterInspectMessageApiCreateCharacterInspectMessageRequest
 */
export interface CharacterInspectMessageApiCreateCharacterInspectMessageRequest {
    /**
     * CharacterInspectMessage
     * @type {ModelsCharacterInspectMessage}
     * @memberof CharacterInspectMessageApiCreateCharacterInspectMessage
     */
    readonly characterInspectMessage: ModelsCharacterInspectMessage
}

/**
 * Request parameters for deleteCharacterInspectMessage operation in CharacterInspectMessageApi.
 * @export
 * @interface CharacterInspectMessageApiDeleteCharacterInspectMessageRequest
 */
export interface CharacterInspectMessageApiDeleteCharacterInspectMessageRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterInspectMessageApiDeleteCharacterInspectMessage
     */
    readonly id: number
}

/**
 * Request parameters for getCharacterInspectMessage operation in CharacterInspectMessageApi.
 * @export
 * @interface CharacterInspectMessageApiGetCharacterInspectMessageRequest
 */
export interface CharacterInspectMessageApiGetCharacterInspectMessageRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterInspectMessageApiGetCharacterInspectMessage
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharacterInspectMessageApiGetCharacterInspectMessage
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharacterInspectMessageApiGetCharacterInspectMessage
     */
    readonly select?: string
}

/**
 * Request parameters for listCharacterInspectMessages operation in CharacterInspectMessageApi.
 * @export
 * @interface CharacterInspectMessageApiListCharacterInspectMessagesRequest
 */
export interface CharacterInspectMessageApiListCharacterInspectMessagesRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharacterInspectMessageApiListCharacterInspectMessages
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof CharacterInspectMessageApiListCharacterInspectMessages
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof CharacterInspectMessageApiListCharacterInspectMessages
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof CharacterInspectMessageApiListCharacterInspectMessages
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof CharacterInspectMessageApiListCharacterInspectMessages
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharacterInspectMessageApiListCharacterInspectMessages
     */
    readonly select?: string
}

/**
 * Request parameters for updateCharacterInspectMessage operation in CharacterInspectMessageApi.
 * @export
 * @interface CharacterInspectMessageApiUpdateCharacterInspectMessageRequest
 */
export interface CharacterInspectMessageApiUpdateCharacterInspectMessageRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterInspectMessageApiUpdateCharacterInspectMessage
     */
    readonly id: number

    /**
     * CharacterInspectMessage
     * @type {ModelsCharacterInspectMessage}
     * @memberof CharacterInspectMessageApiUpdateCharacterInspectMessage
     */
    readonly characterInspectMessage: ModelsCharacterInspectMessage
}

/**
 * CharacterInspectMessageApi - object-oriented interface
 * @export
 * @class CharacterInspectMessageApi
 * @extends {BaseAPI}
 */
export class CharacterInspectMessageApi extends BaseAPI {
    /**
     * 
     * @summary Creates CharacterInspectMessage
     * @param {CharacterInspectMessageApiCreateCharacterInspectMessageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterInspectMessageApi
     */
    public createCharacterInspectMessage(requestParameters: CharacterInspectMessageApiCreateCharacterInspectMessageRequest, options?: any) {
        return CharacterInspectMessageApiFp(this.configuration).createCharacterInspectMessage(requestParameters.characterInspectMessage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes CharacterInspectMessage
     * @param {CharacterInspectMessageApiDeleteCharacterInspectMessageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterInspectMessageApi
     */
    public deleteCharacterInspectMessage(requestParameters: CharacterInspectMessageApiDeleteCharacterInspectMessageRequest, options?: any) {
        return CharacterInspectMessageApiFp(this.configuration).deleteCharacterInspectMessage(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets CharacterInspectMessage
     * @param {CharacterInspectMessageApiGetCharacterInspectMessageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterInspectMessageApi
     */
    public getCharacterInspectMessage(requestParameters: CharacterInspectMessageApiGetCharacterInspectMessageRequest, options?: any) {
        return CharacterInspectMessageApiFp(this.configuration).getCharacterInspectMessage(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists CharacterInspectMessages
     * @param {CharacterInspectMessageApiListCharacterInspectMessagesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterInspectMessageApi
     */
    public listCharacterInspectMessages(requestParameters: CharacterInspectMessageApiListCharacterInspectMessagesRequest = {}, options?: any) {
        return CharacterInspectMessageApiFp(this.configuration).listCharacterInspectMessages(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates CharacterInspectMessage
     * @param {CharacterInspectMessageApiUpdateCharacterInspectMessageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterInspectMessageApi
     */
    public updateCharacterInspectMessage(requestParameters: CharacterInspectMessageApiUpdateCharacterInspectMessageRequest, options?: any) {
        return CharacterInspectMessageApiFp(this.configuration).updateCharacterInspectMessage(requestParameters.id, requestParameters.characterInspectMessage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CharacterItemRecastApi - axios parameter creator
 * @export
 */
export const CharacterItemRecastApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharacterItemRecast
         * @param {ModelsCharacterItemRecast} characterItemRecast CharacterItemRecast
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterItemRecast: async (characterItemRecast: ModelsCharacterItemRecast, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterItemRecast' is not null or undefined
            if (characterItemRecast === null || characterItemRecast === undefined) {
                throw new RequiredError('characterItemRecast','Required parameter characterItemRecast was null or undefined when calling createCharacterItemRecast.');
            }
            const localVarPath = `/character_item_recast`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof characterItemRecast !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(characterItemRecast !== undefined ? characterItemRecast : {})
                : (characterItemRecast || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes CharacterItemRecast
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterItemRecast: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteCharacterItemRecast.');
            }
            const localVarPath = `/character_item_recast/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets CharacterItemRecast
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterItemRecast: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getCharacterItemRecast.');
            }
            const localVarPath = `/character_item_recast/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists CharacterItemRecasts
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharacterItemRecasts: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/character_item_recasts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates CharacterItemRecast
         * @param {number} id Id
         * @param {ModelsCharacterItemRecast} characterItemRecast CharacterItemRecast
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharacterItemRecast: async (id: number, characterItemRecast: ModelsCharacterItemRecast, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateCharacterItemRecast.');
            }
            // verify required parameter 'characterItemRecast' is not null or undefined
            if (characterItemRecast === null || characterItemRecast === undefined) {
                throw new RequiredError('characterItemRecast','Required parameter characterItemRecast was null or undefined when calling updateCharacterItemRecast.');
            }
            const localVarPath = `/character_item_recast/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof characterItemRecast !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(characterItemRecast !== undefined ? characterItemRecast : {})
                : (characterItemRecast || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CharacterItemRecastApi - functional programming interface
 * @export
 */
export const CharacterItemRecastApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharacterItemRecast
         * @param {ModelsCharacterItemRecast} characterItemRecast CharacterItemRecast
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCharacterItemRecast(characterItemRecast: ModelsCharacterItemRecast, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterItemRecast>>> {
            const localVarAxiosArgs = await CharacterItemRecastApiAxiosParamCreator(configuration).createCharacterItemRecast(characterItemRecast, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes CharacterItemRecast
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCharacterItemRecast(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await CharacterItemRecastApiAxiosParamCreator(configuration).deleteCharacterItemRecast(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets CharacterItemRecast
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharacterItemRecast(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterItemRecast>>> {
            const localVarAxiosArgs = await CharacterItemRecastApiAxiosParamCreator(configuration).getCharacterItemRecast(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists CharacterItemRecasts
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCharacterItemRecasts(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterItemRecast>>> {
            const localVarAxiosArgs = await CharacterItemRecastApiAxiosParamCreator(configuration).listCharacterItemRecasts(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates CharacterItemRecast
         * @param {number} id Id
         * @param {ModelsCharacterItemRecast} characterItemRecast CharacterItemRecast
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCharacterItemRecast(id: number, characterItemRecast: ModelsCharacterItemRecast, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterItemRecast>>> {
            const localVarAxiosArgs = await CharacterItemRecastApiAxiosParamCreator(configuration).updateCharacterItemRecast(id, characterItemRecast, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CharacterItemRecastApi - factory interface
 * @export
 */
export const CharacterItemRecastApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates CharacterItemRecast
         * @param {ModelsCharacterItemRecast} characterItemRecast CharacterItemRecast
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterItemRecast(characterItemRecast: ModelsCharacterItemRecast, options?: any): AxiosPromise<Array<ModelsCharacterItemRecast>> {
            return CharacterItemRecastApiFp(configuration).createCharacterItemRecast(characterItemRecast, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes CharacterItemRecast
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterItemRecast(id: number, options?: any): AxiosPromise<string> {
            return CharacterItemRecastApiFp(configuration).deleteCharacterItemRecast(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets CharacterItemRecast
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterItemRecast(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharacterItemRecast>> {
            return CharacterItemRecastApiFp(configuration).getCharacterItemRecast(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists CharacterItemRecasts
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharacterItemRecasts(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharacterItemRecast>> {
            return CharacterItemRecastApiFp(configuration).listCharacterItemRecasts(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates CharacterItemRecast
         * @param {number} id Id
         * @param {ModelsCharacterItemRecast} characterItemRecast CharacterItemRecast
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharacterItemRecast(id: number, characterItemRecast: ModelsCharacterItemRecast, options?: any): AxiosPromise<Array<ModelsCharacterItemRecast>> {
            return CharacterItemRecastApiFp(configuration).updateCharacterItemRecast(id, characterItemRecast, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCharacterItemRecast operation in CharacterItemRecastApi.
 * @export
 * @interface CharacterItemRecastApiCreateCharacterItemRecastRequest
 */
export interface CharacterItemRecastApiCreateCharacterItemRecastRequest {
    /**
     * CharacterItemRecast
     * @type {ModelsCharacterItemRecast}
     * @memberof CharacterItemRecastApiCreateCharacterItemRecast
     */
    readonly characterItemRecast: ModelsCharacterItemRecast
}

/**
 * Request parameters for deleteCharacterItemRecast operation in CharacterItemRecastApi.
 * @export
 * @interface CharacterItemRecastApiDeleteCharacterItemRecastRequest
 */
export interface CharacterItemRecastApiDeleteCharacterItemRecastRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterItemRecastApiDeleteCharacterItemRecast
     */
    readonly id: number
}

/**
 * Request parameters for getCharacterItemRecast operation in CharacterItemRecastApi.
 * @export
 * @interface CharacterItemRecastApiGetCharacterItemRecastRequest
 */
export interface CharacterItemRecastApiGetCharacterItemRecastRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterItemRecastApiGetCharacterItemRecast
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharacterItemRecastApiGetCharacterItemRecast
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharacterItemRecastApiGetCharacterItemRecast
     */
    readonly select?: string
}

/**
 * Request parameters for listCharacterItemRecasts operation in CharacterItemRecastApi.
 * @export
 * @interface CharacterItemRecastApiListCharacterItemRecastsRequest
 */
export interface CharacterItemRecastApiListCharacterItemRecastsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharacterItemRecastApiListCharacterItemRecasts
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof CharacterItemRecastApiListCharacterItemRecasts
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof CharacterItemRecastApiListCharacterItemRecasts
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof CharacterItemRecastApiListCharacterItemRecasts
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof CharacterItemRecastApiListCharacterItemRecasts
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharacterItemRecastApiListCharacterItemRecasts
     */
    readonly select?: string
}

/**
 * Request parameters for updateCharacterItemRecast operation in CharacterItemRecastApi.
 * @export
 * @interface CharacterItemRecastApiUpdateCharacterItemRecastRequest
 */
export interface CharacterItemRecastApiUpdateCharacterItemRecastRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterItemRecastApiUpdateCharacterItemRecast
     */
    readonly id: number

    /**
     * CharacterItemRecast
     * @type {ModelsCharacterItemRecast}
     * @memberof CharacterItemRecastApiUpdateCharacterItemRecast
     */
    readonly characterItemRecast: ModelsCharacterItemRecast
}

/**
 * CharacterItemRecastApi - object-oriented interface
 * @export
 * @class CharacterItemRecastApi
 * @extends {BaseAPI}
 */
export class CharacterItemRecastApi extends BaseAPI {
    /**
     * 
     * @summary Creates CharacterItemRecast
     * @param {CharacterItemRecastApiCreateCharacterItemRecastRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterItemRecastApi
     */
    public createCharacterItemRecast(requestParameters: CharacterItemRecastApiCreateCharacterItemRecastRequest, options?: any) {
        return CharacterItemRecastApiFp(this.configuration).createCharacterItemRecast(requestParameters.characterItemRecast, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes CharacterItemRecast
     * @param {CharacterItemRecastApiDeleteCharacterItemRecastRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterItemRecastApi
     */
    public deleteCharacterItemRecast(requestParameters: CharacterItemRecastApiDeleteCharacterItemRecastRequest, options?: any) {
        return CharacterItemRecastApiFp(this.configuration).deleteCharacterItemRecast(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets CharacterItemRecast
     * @param {CharacterItemRecastApiGetCharacterItemRecastRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterItemRecastApi
     */
    public getCharacterItemRecast(requestParameters: CharacterItemRecastApiGetCharacterItemRecastRequest, options?: any) {
        return CharacterItemRecastApiFp(this.configuration).getCharacterItemRecast(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists CharacterItemRecasts
     * @param {CharacterItemRecastApiListCharacterItemRecastsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterItemRecastApi
     */
    public listCharacterItemRecasts(requestParameters: CharacterItemRecastApiListCharacterItemRecastsRequest = {}, options?: any) {
        return CharacterItemRecastApiFp(this.configuration).listCharacterItemRecasts(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates CharacterItemRecast
     * @param {CharacterItemRecastApiUpdateCharacterItemRecastRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterItemRecastApi
     */
    public updateCharacterItemRecast(requestParameters: CharacterItemRecastApiUpdateCharacterItemRecastRequest, options?: any) {
        return CharacterItemRecastApiFp(this.configuration).updateCharacterItemRecast(requestParameters.id, requestParameters.characterItemRecast, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CharacterLanguageApi - axios parameter creator
 * @export
 */
export const CharacterLanguageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharacterLanguage
         * @param {ModelsCharacterLanguage} characterLanguage CharacterLanguage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterLanguage: async (characterLanguage: ModelsCharacterLanguage, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterLanguage' is not null or undefined
            if (characterLanguage === null || characterLanguage === undefined) {
                throw new RequiredError('characterLanguage','Required parameter characterLanguage was null or undefined when calling createCharacterLanguage.');
            }
            const localVarPath = `/character_language`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof characterLanguage !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(characterLanguage !== undefined ? characterLanguage : {})
                : (characterLanguage || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes CharacterLanguage
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterLanguage: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteCharacterLanguage.');
            }
            const localVarPath = `/character_language/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets CharacterLanguage
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterLanguage: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getCharacterLanguage.');
            }
            const localVarPath = `/character_language/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists CharacterLanguages
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharacterLanguages: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/character_languages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates CharacterLanguage
         * @param {number} id Id
         * @param {ModelsCharacterLanguage} characterLanguage CharacterLanguage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharacterLanguage: async (id: number, characterLanguage: ModelsCharacterLanguage, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateCharacterLanguage.');
            }
            // verify required parameter 'characterLanguage' is not null or undefined
            if (characterLanguage === null || characterLanguage === undefined) {
                throw new RequiredError('characterLanguage','Required parameter characterLanguage was null or undefined when calling updateCharacterLanguage.');
            }
            const localVarPath = `/character_language/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof characterLanguage !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(characterLanguage !== undefined ? characterLanguage : {})
                : (characterLanguage || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CharacterLanguageApi - functional programming interface
 * @export
 */
export const CharacterLanguageApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharacterLanguage
         * @param {ModelsCharacterLanguage} characterLanguage CharacterLanguage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCharacterLanguage(characterLanguage: ModelsCharacterLanguage, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterLanguage>>> {
            const localVarAxiosArgs = await CharacterLanguageApiAxiosParamCreator(configuration).createCharacterLanguage(characterLanguage, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes CharacterLanguage
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCharacterLanguage(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await CharacterLanguageApiAxiosParamCreator(configuration).deleteCharacterLanguage(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets CharacterLanguage
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharacterLanguage(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterLanguage>>> {
            const localVarAxiosArgs = await CharacterLanguageApiAxiosParamCreator(configuration).getCharacterLanguage(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists CharacterLanguages
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCharacterLanguages(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterLanguage>>> {
            const localVarAxiosArgs = await CharacterLanguageApiAxiosParamCreator(configuration).listCharacterLanguages(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates CharacterLanguage
         * @param {number} id Id
         * @param {ModelsCharacterLanguage} characterLanguage CharacterLanguage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCharacterLanguage(id: number, characterLanguage: ModelsCharacterLanguage, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterLanguage>>> {
            const localVarAxiosArgs = await CharacterLanguageApiAxiosParamCreator(configuration).updateCharacterLanguage(id, characterLanguage, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CharacterLanguageApi - factory interface
 * @export
 */
export const CharacterLanguageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates CharacterLanguage
         * @param {ModelsCharacterLanguage} characterLanguage CharacterLanguage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterLanguage(characterLanguage: ModelsCharacterLanguage, options?: any): AxiosPromise<Array<ModelsCharacterLanguage>> {
            return CharacterLanguageApiFp(configuration).createCharacterLanguage(characterLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes CharacterLanguage
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterLanguage(id: number, options?: any): AxiosPromise<string> {
            return CharacterLanguageApiFp(configuration).deleteCharacterLanguage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets CharacterLanguage
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterLanguage(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharacterLanguage>> {
            return CharacterLanguageApiFp(configuration).getCharacterLanguage(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists CharacterLanguages
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharacterLanguages(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharacterLanguage>> {
            return CharacterLanguageApiFp(configuration).listCharacterLanguages(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates CharacterLanguage
         * @param {number} id Id
         * @param {ModelsCharacterLanguage} characterLanguage CharacterLanguage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharacterLanguage(id: number, characterLanguage: ModelsCharacterLanguage, options?: any): AxiosPromise<Array<ModelsCharacterLanguage>> {
            return CharacterLanguageApiFp(configuration).updateCharacterLanguage(id, characterLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCharacterLanguage operation in CharacterLanguageApi.
 * @export
 * @interface CharacterLanguageApiCreateCharacterLanguageRequest
 */
export interface CharacterLanguageApiCreateCharacterLanguageRequest {
    /**
     * CharacterLanguage
     * @type {ModelsCharacterLanguage}
     * @memberof CharacterLanguageApiCreateCharacterLanguage
     */
    readonly characterLanguage: ModelsCharacterLanguage
}

/**
 * Request parameters for deleteCharacterLanguage operation in CharacterLanguageApi.
 * @export
 * @interface CharacterLanguageApiDeleteCharacterLanguageRequest
 */
export interface CharacterLanguageApiDeleteCharacterLanguageRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterLanguageApiDeleteCharacterLanguage
     */
    readonly id: number
}

/**
 * Request parameters for getCharacterLanguage operation in CharacterLanguageApi.
 * @export
 * @interface CharacterLanguageApiGetCharacterLanguageRequest
 */
export interface CharacterLanguageApiGetCharacterLanguageRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterLanguageApiGetCharacterLanguage
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharacterLanguageApiGetCharacterLanguage
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharacterLanguageApiGetCharacterLanguage
     */
    readonly select?: string
}

/**
 * Request parameters for listCharacterLanguages operation in CharacterLanguageApi.
 * @export
 * @interface CharacterLanguageApiListCharacterLanguagesRequest
 */
export interface CharacterLanguageApiListCharacterLanguagesRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharacterLanguageApiListCharacterLanguages
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof CharacterLanguageApiListCharacterLanguages
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof CharacterLanguageApiListCharacterLanguages
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof CharacterLanguageApiListCharacterLanguages
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof CharacterLanguageApiListCharacterLanguages
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharacterLanguageApiListCharacterLanguages
     */
    readonly select?: string
}

/**
 * Request parameters for updateCharacterLanguage operation in CharacterLanguageApi.
 * @export
 * @interface CharacterLanguageApiUpdateCharacterLanguageRequest
 */
export interface CharacterLanguageApiUpdateCharacterLanguageRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterLanguageApiUpdateCharacterLanguage
     */
    readonly id: number

    /**
     * CharacterLanguage
     * @type {ModelsCharacterLanguage}
     * @memberof CharacterLanguageApiUpdateCharacterLanguage
     */
    readonly characterLanguage: ModelsCharacterLanguage
}

/**
 * CharacterLanguageApi - object-oriented interface
 * @export
 * @class CharacterLanguageApi
 * @extends {BaseAPI}
 */
export class CharacterLanguageApi extends BaseAPI {
    /**
     * 
     * @summary Creates CharacterLanguage
     * @param {CharacterLanguageApiCreateCharacterLanguageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterLanguageApi
     */
    public createCharacterLanguage(requestParameters: CharacterLanguageApiCreateCharacterLanguageRequest, options?: any) {
        return CharacterLanguageApiFp(this.configuration).createCharacterLanguage(requestParameters.characterLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes CharacterLanguage
     * @param {CharacterLanguageApiDeleteCharacterLanguageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterLanguageApi
     */
    public deleteCharacterLanguage(requestParameters: CharacterLanguageApiDeleteCharacterLanguageRequest, options?: any) {
        return CharacterLanguageApiFp(this.configuration).deleteCharacterLanguage(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets CharacterLanguage
     * @param {CharacterLanguageApiGetCharacterLanguageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterLanguageApi
     */
    public getCharacterLanguage(requestParameters: CharacterLanguageApiGetCharacterLanguageRequest, options?: any) {
        return CharacterLanguageApiFp(this.configuration).getCharacterLanguage(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists CharacterLanguages
     * @param {CharacterLanguageApiListCharacterLanguagesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterLanguageApi
     */
    public listCharacterLanguages(requestParameters: CharacterLanguageApiListCharacterLanguagesRequest = {}, options?: any) {
        return CharacterLanguageApiFp(this.configuration).listCharacterLanguages(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates CharacterLanguage
     * @param {CharacterLanguageApiUpdateCharacterLanguageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterLanguageApi
     */
    public updateCharacterLanguage(requestParameters: CharacterLanguageApiUpdateCharacterLanguageRequest, options?: any) {
        return CharacterLanguageApiFp(this.configuration).updateCharacterLanguage(requestParameters.id, requestParameters.characterLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CharacterLeadershipAbilityApi - axios parameter creator
 * @export
 */
export const CharacterLeadershipAbilityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharacterLeadershipAbility
         * @param {ModelsCharacterLeadershipAbility} characterLeadershipAbility CharacterLeadershipAbility
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterLeadershipAbility: async (characterLeadershipAbility: ModelsCharacterLeadershipAbility, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterLeadershipAbility' is not null or undefined
            if (characterLeadershipAbility === null || characterLeadershipAbility === undefined) {
                throw new RequiredError('characterLeadershipAbility','Required parameter characterLeadershipAbility was null or undefined when calling createCharacterLeadershipAbility.');
            }
            const localVarPath = `/character_leadership_ability`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof characterLeadershipAbility !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(characterLeadershipAbility !== undefined ? characterLeadershipAbility : {})
                : (characterLeadershipAbility || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes CharacterLeadershipAbility
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterLeadershipAbility: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteCharacterLeadershipAbility.');
            }
            const localVarPath = `/character_leadership_ability/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets CharacterLeadershipAbility
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterLeadershipAbility: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getCharacterLeadershipAbility.');
            }
            const localVarPath = `/character_leadership_ability/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists CharacterLeadershipAbilities
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharacterLeadershipAbilities: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/character_leadership_abilities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates CharacterLeadershipAbility
         * @param {number} id Id
         * @param {ModelsCharacterLeadershipAbility} characterLeadershipAbility CharacterLeadershipAbility
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharacterLeadershipAbility: async (id: number, characterLeadershipAbility: ModelsCharacterLeadershipAbility, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateCharacterLeadershipAbility.');
            }
            // verify required parameter 'characterLeadershipAbility' is not null or undefined
            if (characterLeadershipAbility === null || characterLeadershipAbility === undefined) {
                throw new RequiredError('characterLeadershipAbility','Required parameter characterLeadershipAbility was null or undefined when calling updateCharacterLeadershipAbility.');
            }
            const localVarPath = `/character_leadership_ability/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof characterLeadershipAbility !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(characterLeadershipAbility !== undefined ? characterLeadershipAbility : {})
                : (characterLeadershipAbility || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CharacterLeadershipAbilityApi - functional programming interface
 * @export
 */
export const CharacterLeadershipAbilityApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharacterLeadershipAbility
         * @param {ModelsCharacterLeadershipAbility} characterLeadershipAbility CharacterLeadershipAbility
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCharacterLeadershipAbility(characterLeadershipAbility: ModelsCharacterLeadershipAbility, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterLeadershipAbility>>> {
            const localVarAxiosArgs = await CharacterLeadershipAbilityApiAxiosParamCreator(configuration).createCharacterLeadershipAbility(characterLeadershipAbility, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes CharacterLeadershipAbility
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCharacterLeadershipAbility(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await CharacterLeadershipAbilityApiAxiosParamCreator(configuration).deleteCharacterLeadershipAbility(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets CharacterLeadershipAbility
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharacterLeadershipAbility(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterLeadershipAbility>>> {
            const localVarAxiosArgs = await CharacterLeadershipAbilityApiAxiosParamCreator(configuration).getCharacterLeadershipAbility(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists CharacterLeadershipAbilities
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCharacterLeadershipAbilities(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterLeadershipAbility>>> {
            const localVarAxiosArgs = await CharacterLeadershipAbilityApiAxiosParamCreator(configuration).listCharacterLeadershipAbilities(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates CharacterLeadershipAbility
         * @param {number} id Id
         * @param {ModelsCharacterLeadershipAbility} characterLeadershipAbility CharacterLeadershipAbility
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCharacterLeadershipAbility(id: number, characterLeadershipAbility: ModelsCharacterLeadershipAbility, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterLeadershipAbility>>> {
            const localVarAxiosArgs = await CharacterLeadershipAbilityApiAxiosParamCreator(configuration).updateCharacterLeadershipAbility(id, characterLeadershipAbility, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CharacterLeadershipAbilityApi - factory interface
 * @export
 */
export const CharacterLeadershipAbilityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates CharacterLeadershipAbility
         * @param {ModelsCharacterLeadershipAbility} characterLeadershipAbility CharacterLeadershipAbility
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterLeadershipAbility(characterLeadershipAbility: ModelsCharacterLeadershipAbility, options?: any): AxiosPromise<Array<ModelsCharacterLeadershipAbility>> {
            return CharacterLeadershipAbilityApiFp(configuration).createCharacterLeadershipAbility(characterLeadershipAbility, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes CharacterLeadershipAbility
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterLeadershipAbility(id: number, options?: any): AxiosPromise<string> {
            return CharacterLeadershipAbilityApiFp(configuration).deleteCharacterLeadershipAbility(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets CharacterLeadershipAbility
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterLeadershipAbility(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharacterLeadershipAbility>> {
            return CharacterLeadershipAbilityApiFp(configuration).getCharacterLeadershipAbility(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists CharacterLeadershipAbilities
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharacterLeadershipAbilities(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharacterLeadershipAbility>> {
            return CharacterLeadershipAbilityApiFp(configuration).listCharacterLeadershipAbilities(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates CharacterLeadershipAbility
         * @param {number} id Id
         * @param {ModelsCharacterLeadershipAbility} characterLeadershipAbility CharacterLeadershipAbility
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharacterLeadershipAbility(id: number, characterLeadershipAbility: ModelsCharacterLeadershipAbility, options?: any): AxiosPromise<Array<ModelsCharacterLeadershipAbility>> {
            return CharacterLeadershipAbilityApiFp(configuration).updateCharacterLeadershipAbility(id, characterLeadershipAbility, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCharacterLeadershipAbility operation in CharacterLeadershipAbilityApi.
 * @export
 * @interface CharacterLeadershipAbilityApiCreateCharacterLeadershipAbilityRequest
 */
export interface CharacterLeadershipAbilityApiCreateCharacterLeadershipAbilityRequest {
    /**
     * CharacterLeadershipAbility
     * @type {ModelsCharacterLeadershipAbility}
     * @memberof CharacterLeadershipAbilityApiCreateCharacterLeadershipAbility
     */
    readonly characterLeadershipAbility: ModelsCharacterLeadershipAbility
}

/**
 * Request parameters for deleteCharacterLeadershipAbility operation in CharacterLeadershipAbilityApi.
 * @export
 * @interface CharacterLeadershipAbilityApiDeleteCharacterLeadershipAbilityRequest
 */
export interface CharacterLeadershipAbilityApiDeleteCharacterLeadershipAbilityRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterLeadershipAbilityApiDeleteCharacterLeadershipAbility
     */
    readonly id: number
}

/**
 * Request parameters for getCharacterLeadershipAbility operation in CharacterLeadershipAbilityApi.
 * @export
 * @interface CharacterLeadershipAbilityApiGetCharacterLeadershipAbilityRequest
 */
export interface CharacterLeadershipAbilityApiGetCharacterLeadershipAbilityRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterLeadershipAbilityApiGetCharacterLeadershipAbility
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharacterLeadershipAbilityApiGetCharacterLeadershipAbility
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharacterLeadershipAbilityApiGetCharacterLeadershipAbility
     */
    readonly select?: string
}

/**
 * Request parameters for listCharacterLeadershipAbilities operation in CharacterLeadershipAbilityApi.
 * @export
 * @interface CharacterLeadershipAbilityApiListCharacterLeadershipAbilitiesRequest
 */
export interface CharacterLeadershipAbilityApiListCharacterLeadershipAbilitiesRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharacterLeadershipAbilityApiListCharacterLeadershipAbilities
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof CharacterLeadershipAbilityApiListCharacterLeadershipAbilities
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof CharacterLeadershipAbilityApiListCharacterLeadershipAbilities
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof CharacterLeadershipAbilityApiListCharacterLeadershipAbilities
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof CharacterLeadershipAbilityApiListCharacterLeadershipAbilities
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharacterLeadershipAbilityApiListCharacterLeadershipAbilities
     */
    readonly select?: string
}

/**
 * Request parameters for updateCharacterLeadershipAbility operation in CharacterLeadershipAbilityApi.
 * @export
 * @interface CharacterLeadershipAbilityApiUpdateCharacterLeadershipAbilityRequest
 */
export interface CharacterLeadershipAbilityApiUpdateCharacterLeadershipAbilityRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterLeadershipAbilityApiUpdateCharacterLeadershipAbility
     */
    readonly id: number

    /**
     * CharacterLeadershipAbility
     * @type {ModelsCharacterLeadershipAbility}
     * @memberof CharacterLeadershipAbilityApiUpdateCharacterLeadershipAbility
     */
    readonly characterLeadershipAbility: ModelsCharacterLeadershipAbility
}

/**
 * CharacterLeadershipAbilityApi - object-oriented interface
 * @export
 * @class CharacterLeadershipAbilityApi
 * @extends {BaseAPI}
 */
export class CharacterLeadershipAbilityApi extends BaseAPI {
    /**
     * 
     * @summary Creates CharacterLeadershipAbility
     * @param {CharacterLeadershipAbilityApiCreateCharacterLeadershipAbilityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterLeadershipAbilityApi
     */
    public createCharacterLeadershipAbility(requestParameters: CharacterLeadershipAbilityApiCreateCharacterLeadershipAbilityRequest, options?: any) {
        return CharacterLeadershipAbilityApiFp(this.configuration).createCharacterLeadershipAbility(requestParameters.characterLeadershipAbility, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes CharacterLeadershipAbility
     * @param {CharacterLeadershipAbilityApiDeleteCharacterLeadershipAbilityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterLeadershipAbilityApi
     */
    public deleteCharacterLeadershipAbility(requestParameters: CharacterLeadershipAbilityApiDeleteCharacterLeadershipAbilityRequest, options?: any) {
        return CharacterLeadershipAbilityApiFp(this.configuration).deleteCharacterLeadershipAbility(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets CharacterLeadershipAbility
     * @param {CharacterLeadershipAbilityApiGetCharacterLeadershipAbilityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterLeadershipAbilityApi
     */
    public getCharacterLeadershipAbility(requestParameters: CharacterLeadershipAbilityApiGetCharacterLeadershipAbilityRequest, options?: any) {
        return CharacterLeadershipAbilityApiFp(this.configuration).getCharacterLeadershipAbility(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists CharacterLeadershipAbilities
     * @param {CharacterLeadershipAbilityApiListCharacterLeadershipAbilitiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterLeadershipAbilityApi
     */
    public listCharacterLeadershipAbilities(requestParameters: CharacterLeadershipAbilityApiListCharacterLeadershipAbilitiesRequest = {}, options?: any) {
        return CharacterLeadershipAbilityApiFp(this.configuration).listCharacterLeadershipAbilities(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates CharacterLeadershipAbility
     * @param {CharacterLeadershipAbilityApiUpdateCharacterLeadershipAbilityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterLeadershipAbilityApi
     */
    public updateCharacterLeadershipAbility(requestParameters: CharacterLeadershipAbilityApiUpdateCharacterLeadershipAbilityRequest, options?: any) {
        return CharacterLeadershipAbilityApiFp(this.configuration).updateCharacterLeadershipAbility(requestParameters.id, requestParameters.characterLeadershipAbility, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CharacterMaterialApi - axios parameter creator
 * @export
 */
export const CharacterMaterialApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharacterMaterial
         * @param {ModelsCharacterMaterial} characterMaterial CharacterMaterial
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterMaterial: async (characterMaterial: ModelsCharacterMaterial, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterMaterial' is not null or undefined
            if (characterMaterial === null || characterMaterial === undefined) {
                throw new RequiredError('characterMaterial','Required parameter characterMaterial was null or undefined when calling createCharacterMaterial.');
            }
            const localVarPath = `/character_material`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof characterMaterial !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(characterMaterial !== undefined ? characterMaterial : {})
                : (characterMaterial || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes CharacterMaterial
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterMaterial: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteCharacterMaterial.');
            }
            const localVarPath = `/character_material/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets CharacterMaterial
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterMaterial: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getCharacterMaterial.');
            }
            const localVarPath = `/character_material/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists CharacterMaterials
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharacterMaterials: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/character_materials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates CharacterMaterial
         * @param {number} id Id
         * @param {ModelsCharacterMaterial} characterMaterial CharacterMaterial
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharacterMaterial: async (id: number, characterMaterial: ModelsCharacterMaterial, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateCharacterMaterial.');
            }
            // verify required parameter 'characterMaterial' is not null or undefined
            if (characterMaterial === null || characterMaterial === undefined) {
                throw new RequiredError('characterMaterial','Required parameter characterMaterial was null or undefined when calling updateCharacterMaterial.');
            }
            const localVarPath = `/character_material/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof characterMaterial !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(characterMaterial !== undefined ? characterMaterial : {})
                : (characterMaterial || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CharacterMaterialApi - functional programming interface
 * @export
 */
export const CharacterMaterialApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharacterMaterial
         * @param {ModelsCharacterMaterial} characterMaterial CharacterMaterial
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCharacterMaterial(characterMaterial: ModelsCharacterMaterial, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterMaterial>>> {
            const localVarAxiosArgs = await CharacterMaterialApiAxiosParamCreator(configuration).createCharacterMaterial(characterMaterial, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes CharacterMaterial
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCharacterMaterial(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await CharacterMaterialApiAxiosParamCreator(configuration).deleteCharacterMaterial(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets CharacterMaterial
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharacterMaterial(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterMaterial>>> {
            const localVarAxiosArgs = await CharacterMaterialApiAxiosParamCreator(configuration).getCharacterMaterial(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists CharacterMaterials
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCharacterMaterials(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterMaterial>>> {
            const localVarAxiosArgs = await CharacterMaterialApiAxiosParamCreator(configuration).listCharacterMaterials(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates CharacterMaterial
         * @param {number} id Id
         * @param {ModelsCharacterMaterial} characterMaterial CharacterMaterial
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCharacterMaterial(id: number, characterMaterial: ModelsCharacterMaterial, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterMaterial>>> {
            const localVarAxiosArgs = await CharacterMaterialApiAxiosParamCreator(configuration).updateCharacterMaterial(id, characterMaterial, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CharacterMaterialApi - factory interface
 * @export
 */
export const CharacterMaterialApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates CharacterMaterial
         * @param {ModelsCharacterMaterial} characterMaterial CharacterMaterial
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterMaterial(characterMaterial: ModelsCharacterMaterial, options?: any): AxiosPromise<Array<ModelsCharacterMaterial>> {
            return CharacterMaterialApiFp(configuration).createCharacterMaterial(characterMaterial, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes CharacterMaterial
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterMaterial(id: number, options?: any): AxiosPromise<string> {
            return CharacterMaterialApiFp(configuration).deleteCharacterMaterial(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets CharacterMaterial
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterMaterial(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharacterMaterial>> {
            return CharacterMaterialApiFp(configuration).getCharacterMaterial(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists CharacterMaterials
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharacterMaterials(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharacterMaterial>> {
            return CharacterMaterialApiFp(configuration).listCharacterMaterials(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates CharacterMaterial
         * @param {number} id Id
         * @param {ModelsCharacterMaterial} characterMaterial CharacterMaterial
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharacterMaterial(id: number, characterMaterial: ModelsCharacterMaterial, options?: any): AxiosPromise<Array<ModelsCharacterMaterial>> {
            return CharacterMaterialApiFp(configuration).updateCharacterMaterial(id, characterMaterial, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCharacterMaterial operation in CharacterMaterialApi.
 * @export
 * @interface CharacterMaterialApiCreateCharacterMaterialRequest
 */
export interface CharacterMaterialApiCreateCharacterMaterialRequest {
    /**
     * CharacterMaterial
     * @type {ModelsCharacterMaterial}
     * @memberof CharacterMaterialApiCreateCharacterMaterial
     */
    readonly characterMaterial: ModelsCharacterMaterial
}

/**
 * Request parameters for deleteCharacterMaterial operation in CharacterMaterialApi.
 * @export
 * @interface CharacterMaterialApiDeleteCharacterMaterialRequest
 */
export interface CharacterMaterialApiDeleteCharacterMaterialRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterMaterialApiDeleteCharacterMaterial
     */
    readonly id: number
}

/**
 * Request parameters for getCharacterMaterial operation in CharacterMaterialApi.
 * @export
 * @interface CharacterMaterialApiGetCharacterMaterialRequest
 */
export interface CharacterMaterialApiGetCharacterMaterialRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterMaterialApiGetCharacterMaterial
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharacterMaterialApiGetCharacterMaterial
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharacterMaterialApiGetCharacterMaterial
     */
    readonly select?: string
}

/**
 * Request parameters for listCharacterMaterials operation in CharacterMaterialApi.
 * @export
 * @interface CharacterMaterialApiListCharacterMaterialsRequest
 */
export interface CharacterMaterialApiListCharacterMaterialsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharacterMaterialApiListCharacterMaterials
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof CharacterMaterialApiListCharacterMaterials
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof CharacterMaterialApiListCharacterMaterials
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof CharacterMaterialApiListCharacterMaterials
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof CharacterMaterialApiListCharacterMaterials
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharacterMaterialApiListCharacterMaterials
     */
    readonly select?: string
}

/**
 * Request parameters for updateCharacterMaterial operation in CharacterMaterialApi.
 * @export
 * @interface CharacterMaterialApiUpdateCharacterMaterialRequest
 */
export interface CharacterMaterialApiUpdateCharacterMaterialRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterMaterialApiUpdateCharacterMaterial
     */
    readonly id: number

    /**
     * CharacterMaterial
     * @type {ModelsCharacterMaterial}
     * @memberof CharacterMaterialApiUpdateCharacterMaterial
     */
    readonly characterMaterial: ModelsCharacterMaterial
}

/**
 * CharacterMaterialApi - object-oriented interface
 * @export
 * @class CharacterMaterialApi
 * @extends {BaseAPI}
 */
export class CharacterMaterialApi extends BaseAPI {
    /**
     * 
     * @summary Creates CharacterMaterial
     * @param {CharacterMaterialApiCreateCharacterMaterialRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterMaterialApi
     */
    public createCharacterMaterial(requestParameters: CharacterMaterialApiCreateCharacterMaterialRequest, options?: any) {
        return CharacterMaterialApiFp(this.configuration).createCharacterMaterial(requestParameters.characterMaterial, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes CharacterMaterial
     * @param {CharacterMaterialApiDeleteCharacterMaterialRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterMaterialApi
     */
    public deleteCharacterMaterial(requestParameters: CharacterMaterialApiDeleteCharacterMaterialRequest, options?: any) {
        return CharacterMaterialApiFp(this.configuration).deleteCharacterMaterial(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets CharacterMaterial
     * @param {CharacterMaterialApiGetCharacterMaterialRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterMaterialApi
     */
    public getCharacterMaterial(requestParameters: CharacterMaterialApiGetCharacterMaterialRequest, options?: any) {
        return CharacterMaterialApiFp(this.configuration).getCharacterMaterial(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists CharacterMaterials
     * @param {CharacterMaterialApiListCharacterMaterialsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterMaterialApi
     */
    public listCharacterMaterials(requestParameters: CharacterMaterialApiListCharacterMaterialsRequest = {}, options?: any) {
        return CharacterMaterialApiFp(this.configuration).listCharacterMaterials(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates CharacterMaterial
     * @param {CharacterMaterialApiUpdateCharacterMaterialRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterMaterialApi
     */
    public updateCharacterMaterial(requestParameters: CharacterMaterialApiUpdateCharacterMaterialRequest, options?: any) {
        return CharacterMaterialApiFp(this.configuration).updateCharacterMaterial(requestParameters.id, requestParameters.characterMaterial, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CharacterMemmedSpellApi - axios parameter creator
 * @export
 */
export const CharacterMemmedSpellApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharacterMemmedSpell
         * @param {ModelsCharacterMemmedSpell} characterMemmedSpell CharacterMemmedSpell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterMemmedSpell: async (characterMemmedSpell: ModelsCharacterMemmedSpell, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterMemmedSpell' is not null or undefined
            if (characterMemmedSpell === null || characterMemmedSpell === undefined) {
                throw new RequiredError('characterMemmedSpell','Required parameter characterMemmedSpell was null or undefined when calling createCharacterMemmedSpell.');
            }
            const localVarPath = `/character_memmed_spell`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof characterMemmedSpell !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(characterMemmedSpell !== undefined ? characterMemmedSpell : {})
                : (characterMemmedSpell || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes CharacterMemmedSpell
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterMemmedSpell: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteCharacterMemmedSpell.');
            }
            const localVarPath = `/character_memmed_spell/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets CharacterMemmedSpell
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterMemmedSpell: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getCharacterMemmedSpell.');
            }
            const localVarPath = `/character_memmed_spell/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists CharacterMemmedSpells
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharacterMemmedSpells: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/character_memmed_spells`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates CharacterMemmedSpell
         * @param {number} id Id
         * @param {ModelsCharacterMemmedSpell} characterMemmedSpell CharacterMemmedSpell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharacterMemmedSpell: async (id: number, characterMemmedSpell: ModelsCharacterMemmedSpell, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateCharacterMemmedSpell.');
            }
            // verify required parameter 'characterMemmedSpell' is not null or undefined
            if (characterMemmedSpell === null || characterMemmedSpell === undefined) {
                throw new RequiredError('characterMemmedSpell','Required parameter characterMemmedSpell was null or undefined when calling updateCharacterMemmedSpell.');
            }
            const localVarPath = `/character_memmed_spell/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof characterMemmedSpell !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(characterMemmedSpell !== undefined ? characterMemmedSpell : {})
                : (characterMemmedSpell || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CharacterMemmedSpellApi - functional programming interface
 * @export
 */
export const CharacterMemmedSpellApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharacterMemmedSpell
         * @param {ModelsCharacterMemmedSpell} characterMemmedSpell CharacterMemmedSpell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCharacterMemmedSpell(characterMemmedSpell: ModelsCharacterMemmedSpell, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterMemmedSpell>>> {
            const localVarAxiosArgs = await CharacterMemmedSpellApiAxiosParamCreator(configuration).createCharacterMemmedSpell(characterMemmedSpell, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes CharacterMemmedSpell
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCharacterMemmedSpell(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await CharacterMemmedSpellApiAxiosParamCreator(configuration).deleteCharacterMemmedSpell(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets CharacterMemmedSpell
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharacterMemmedSpell(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterMemmedSpell>>> {
            const localVarAxiosArgs = await CharacterMemmedSpellApiAxiosParamCreator(configuration).getCharacterMemmedSpell(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists CharacterMemmedSpells
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCharacterMemmedSpells(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterMemmedSpell>>> {
            const localVarAxiosArgs = await CharacterMemmedSpellApiAxiosParamCreator(configuration).listCharacterMemmedSpells(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates CharacterMemmedSpell
         * @param {number} id Id
         * @param {ModelsCharacterMemmedSpell} characterMemmedSpell CharacterMemmedSpell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCharacterMemmedSpell(id: number, characterMemmedSpell: ModelsCharacterMemmedSpell, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterMemmedSpell>>> {
            const localVarAxiosArgs = await CharacterMemmedSpellApiAxiosParamCreator(configuration).updateCharacterMemmedSpell(id, characterMemmedSpell, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CharacterMemmedSpellApi - factory interface
 * @export
 */
export const CharacterMemmedSpellApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates CharacterMemmedSpell
         * @param {ModelsCharacterMemmedSpell} characterMemmedSpell CharacterMemmedSpell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterMemmedSpell(characterMemmedSpell: ModelsCharacterMemmedSpell, options?: any): AxiosPromise<Array<ModelsCharacterMemmedSpell>> {
            return CharacterMemmedSpellApiFp(configuration).createCharacterMemmedSpell(characterMemmedSpell, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes CharacterMemmedSpell
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterMemmedSpell(id: number, options?: any): AxiosPromise<string> {
            return CharacterMemmedSpellApiFp(configuration).deleteCharacterMemmedSpell(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets CharacterMemmedSpell
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterMemmedSpell(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharacterMemmedSpell>> {
            return CharacterMemmedSpellApiFp(configuration).getCharacterMemmedSpell(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists CharacterMemmedSpells
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharacterMemmedSpells(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharacterMemmedSpell>> {
            return CharacterMemmedSpellApiFp(configuration).listCharacterMemmedSpells(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates CharacterMemmedSpell
         * @param {number} id Id
         * @param {ModelsCharacterMemmedSpell} characterMemmedSpell CharacterMemmedSpell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharacterMemmedSpell(id: number, characterMemmedSpell: ModelsCharacterMemmedSpell, options?: any): AxiosPromise<Array<ModelsCharacterMemmedSpell>> {
            return CharacterMemmedSpellApiFp(configuration).updateCharacterMemmedSpell(id, characterMemmedSpell, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCharacterMemmedSpell operation in CharacterMemmedSpellApi.
 * @export
 * @interface CharacterMemmedSpellApiCreateCharacterMemmedSpellRequest
 */
export interface CharacterMemmedSpellApiCreateCharacterMemmedSpellRequest {
    /**
     * CharacterMemmedSpell
     * @type {ModelsCharacterMemmedSpell}
     * @memberof CharacterMemmedSpellApiCreateCharacterMemmedSpell
     */
    readonly characterMemmedSpell: ModelsCharacterMemmedSpell
}

/**
 * Request parameters for deleteCharacterMemmedSpell operation in CharacterMemmedSpellApi.
 * @export
 * @interface CharacterMemmedSpellApiDeleteCharacterMemmedSpellRequest
 */
export interface CharacterMemmedSpellApiDeleteCharacterMemmedSpellRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterMemmedSpellApiDeleteCharacterMemmedSpell
     */
    readonly id: number
}

/**
 * Request parameters for getCharacterMemmedSpell operation in CharacterMemmedSpellApi.
 * @export
 * @interface CharacterMemmedSpellApiGetCharacterMemmedSpellRequest
 */
export interface CharacterMemmedSpellApiGetCharacterMemmedSpellRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterMemmedSpellApiGetCharacterMemmedSpell
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharacterMemmedSpellApiGetCharacterMemmedSpell
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharacterMemmedSpellApiGetCharacterMemmedSpell
     */
    readonly select?: string
}

/**
 * Request parameters for listCharacterMemmedSpells operation in CharacterMemmedSpellApi.
 * @export
 * @interface CharacterMemmedSpellApiListCharacterMemmedSpellsRequest
 */
export interface CharacterMemmedSpellApiListCharacterMemmedSpellsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharacterMemmedSpellApiListCharacterMemmedSpells
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof CharacterMemmedSpellApiListCharacterMemmedSpells
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof CharacterMemmedSpellApiListCharacterMemmedSpells
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof CharacterMemmedSpellApiListCharacterMemmedSpells
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof CharacterMemmedSpellApiListCharacterMemmedSpells
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharacterMemmedSpellApiListCharacterMemmedSpells
     */
    readonly select?: string
}

/**
 * Request parameters for updateCharacterMemmedSpell operation in CharacterMemmedSpellApi.
 * @export
 * @interface CharacterMemmedSpellApiUpdateCharacterMemmedSpellRequest
 */
export interface CharacterMemmedSpellApiUpdateCharacterMemmedSpellRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterMemmedSpellApiUpdateCharacterMemmedSpell
     */
    readonly id: number

    /**
     * CharacterMemmedSpell
     * @type {ModelsCharacterMemmedSpell}
     * @memberof CharacterMemmedSpellApiUpdateCharacterMemmedSpell
     */
    readonly characterMemmedSpell: ModelsCharacterMemmedSpell
}

/**
 * CharacterMemmedSpellApi - object-oriented interface
 * @export
 * @class CharacterMemmedSpellApi
 * @extends {BaseAPI}
 */
export class CharacterMemmedSpellApi extends BaseAPI {
    /**
     * 
     * @summary Creates CharacterMemmedSpell
     * @param {CharacterMemmedSpellApiCreateCharacterMemmedSpellRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterMemmedSpellApi
     */
    public createCharacterMemmedSpell(requestParameters: CharacterMemmedSpellApiCreateCharacterMemmedSpellRequest, options?: any) {
        return CharacterMemmedSpellApiFp(this.configuration).createCharacterMemmedSpell(requestParameters.characterMemmedSpell, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes CharacterMemmedSpell
     * @param {CharacterMemmedSpellApiDeleteCharacterMemmedSpellRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterMemmedSpellApi
     */
    public deleteCharacterMemmedSpell(requestParameters: CharacterMemmedSpellApiDeleteCharacterMemmedSpellRequest, options?: any) {
        return CharacterMemmedSpellApiFp(this.configuration).deleteCharacterMemmedSpell(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets CharacterMemmedSpell
     * @param {CharacterMemmedSpellApiGetCharacterMemmedSpellRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterMemmedSpellApi
     */
    public getCharacterMemmedSpell(requestParameters: CharacterMemmedSpellApiGetCharacterMemmedSpellRequest, options?: any) {
        return CharacterMemmedSpellApiFp(this.configuration).getCharacterMemmedSpell(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists CharacterMemmedSpells
     * @param {CharacterMemmedSpellApiListCharacterMemmedSpellsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterMemmedSpellApi
     */
    public listCharacterMemmedSpells(requestParameters: CharacterMemmedSpellApiListCharacterMemmedSpellsRequest = {}, options?: any) {
        return CharacterMemmedSpellApiFp(this.configuration).listCharacterMemmedSpells(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates CharacterMemmedSpell
     * @param {CharacterMemmedSpellApiUpdateCharacterMemmedSpellRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterMemmedSpellApi
     */
    public updateCharacterMemmedSpell(requestParameters: CharacterMemmedSpellApiUpdateCharacterMemmedSpellRequest, options?: any) {
        return CharacterMemmedSpellApiFp(this.configuration).updateCharacterMemmedSpell(requestParameters.id, requestParameters.characterMemmedSpell, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CharacterPetBuffApi - axios parameter creator
 * @export
 */
export const CharacterPetBuffApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharacterPetBuff
         * @param {ModelsCharacterPetBuff} characterPetBuff CharacterPetBuff
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterPetBuff: async (characterPetBuff: ModelsCharacterPetBuff, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterPetBuff' is not null or undefined
            if (characterPetBuff === null || characterPetBuff === undefined) {
                throw new RequiredError('characterPetBuff','Required parameter characterPetBuff was null or undefined when calling createCharacterPetBuff.');
            }
            const localVarPath = `/character_pet_buff`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof characterPetBuff !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(characterPetBuff !== undefined ? characterPetBuff : {})
                : (characterPetBuff || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes CharacterPetBuff
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterPetBuff: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteCharacterPetBuff.');
            }
            const localVarPath = `/character_pet_buff/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets CharacterPetBuff
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterPetBuff: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getCharacterPetBuff.');
            }
            const localVarPath = `/character_pet_buff/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists CharacterPetBuffs
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharacterPetBuffs: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/character_pet_buffs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates CharacterPetBuff
         * @param {number} id Id
         * @param {ModelsCharacterPetBuff} characterPetBuff CharacterPetBuff
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharacterPetBuff: async (id: number, characterPetBuff: ModelsCharacterPetBuff, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateCharacterPetBuff.');
            }
            // verify required parameter 'characterPetBuff' is not null or undefined
            if (characterPetBuff === null || characterPetBuff === undefined) {
                throw new RequiredError('characterPetBuff','Required parameter characterPetBuff was null or undefined when calling updateCharacterPetBuff.');
            }
            const localVarPath = `/character_pet_buff/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof characterPetBuff !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(characterPetBuff !== undefined ? characterPetBuff : {})
                : (characterPetBuff || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CharacterPetBuffApi - functional programming interface
 * @export
 */
export const CharacterPetBuffApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharacterPetBuff
         * @param {ModelsCharacterPetBuff} characterPetBuff CharacterPetBuff
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCharacterPetBuff(characterPetBuff: ModelsCharacterPetBuff, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterPetBuff>>> {
            const localVarAxiosArgs = await CharacterPetBuffApiAxiosParamCreator(configuration).createCharacterPetBuff(characterPetBuff, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes CharacterPetBuff
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCharacterPetBuff(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await CharacterPetBuffApiAxiosParamCreator(configuration).deleteCharacterPetBuff(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets CharacterPetBuff
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharacterPetBuff(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterPetBuff>>> {
            const localVarAxiosArgs = await CharacterPetBuffApiAxiosParamCreator(configuration).getCharacterPetBuff(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists CharacterPetBuffs
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCharacterPetBuffs(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterPetBuff>>> {
            const localVarAxiosArgs = await CharacterPetBuffApiAxiosParamCreator(configuration).listCharacterPetBuffs(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates CharacterPetBuff
         * @param {number} id Id
         * @param {ModelsCharacterPetBuff} characterPetBuff CharacterPetBuff
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCharacterPetBuff(id: number, characterPetBuff: ModelsCharacterPetBuff, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterPetBuff>>> {
            const localVarAxiosArgs = await CharacterPetBuffApiAxiosParamCreator(configuration).updateCharacterPetBuff(id, characterPetBuff, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CharacterPetBuffApi - factory interface
 * @export
 */
export const CharacterPetBuffApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates CharacterPetBuff
         * @param {ModelsCharacterPetBuff} characterPetBuff CharacterPetBuff
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterPetBuff(characterPetBuff: ModelsCharacterPetBuff, options?: any): AxiosPromise<Array<ModelsCharacterPetBuff>> {
            return CharacterPetBuffApiFp(configuration).createCharacterPetBuff(characterPetBuff, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes CharacterPetBuff
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterPetBuff(id: number, options?: any): AxiosPromise<string> {
            return CharacterPetBuffApiFp(configuration).deleteCharacterPetBuff(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets CharacterPetBuff
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterPetBuff(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharacterPetBuff>> {
            return CharacterPetBuffApiFp(configuration).getCharacterPetBuff(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists CharacterPetBuffs
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharacterPetBuffs(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharacterPetBuff>> {
            return CharacterPetBuffApiFp(configuration).listCharacterPetBuffs(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates CharacterPetBuff
         * @param {number} id Id
         * @param {ModelsCharacterPetBuff} characterPetBuff CharacterPetBuff
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharacterPetBuff(id: number, characterPetBuff: ModelsCharacterPetBuff, options?: any): AxiosPromise<Array<ModelsCharacterPetBuff>> {
            return CharacterPetBuffApiFp(configuration).updateCharacterPetBuff(id, characterPetBuff, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCharacterPetBuff operation in CharacterPetBuffApi.
 * @export
 * @interface CharacterPetBuffApiCreateCharacterPetBuffRequest
 */
export interface CharacterPetBuffApiCreateCharacterPetBuffRequest {
    /**
     * CharacterPetBuff
     * @type {ModelsCharacterPetBuff}
     * @memberof CharacterPetBuffApiCreateCharacterPetBuff
     */
    readonly characterPetBuff: ModelsCharacterPetBuff
}

/**
 * Request parameters for deleteCharacterPetBuff operation in CharacterPetBuffApi.
 * @export
 * @interface CharacterPetBuffApiDeleteCharacterPetBuffRequest
 */
export interface CharacterPetBuffApiDeleteCharacterPetBuffRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterPetBuffApiDeleteCharacterPetBuff
     */
    readonly id: number
}

/**
 * Request parameters for getCharacterPetBuff operation in CharacterPetBuffApi.
 * @export
 * @interface CharacterPetBuffApiGetCharacterPetBuffRequest
 */
export interface CharacterPetBuffApiGetCharacterPetBuffRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterPetBuffApiGetCharacterPetBuff
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharacterPetBuffApiGetCharacterPetBuff
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharacterPetBuffApiGetCharacterPetBuff
     */
    readonly select?: string
}

/**
 * Request parameters for listCharacterPetBuffs operation in CharacterPetBuffApi.
 * @export
 * @interface CharacterPetBuffApiListCharacterPetBuffsRequest
 */
export interface CharacterPetBuffApiListCharacterPetBuffsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharacterPetBuffApiListCharacterPetBuffs
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof CharacterPetBuffApiListCharacterPetBuffs
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof CharacterPetBuffApiListCharacterPetBuffs
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof CharacterPetBuffApiListCharacterPetBuffs
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof CharacterPetBuffApiListCharacterPetBuffs
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharacterPetBuffApiListCharacterPetBuffs
     */
    readonly select?: string
}

/**
 * Request parameters for updateCharacterPetBuff operation in CharacterPetBuffApi.
 * @export
 * @interface CharacterPetBuffApiUpdateCharacterPetBuffRequest
 */
export interface CharacterPetBuffApiUpdateCharacterPetBuffRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterPetBuffApiUpdateCharacterPetBuff
     */
    readonly id: number

    /**
     * CharacterPetBuff
     * @type {ModelsCharacterPetBuff}
     * @memberof CharacterPetBuffApiUpdateCharacterPetBuff
     */
    readonly characterPetBuff: ModelsCharacterPetBuff
}

/**
 * CharacterPetBuffApi - object-oriented interface
 * @export
 * @class CharacterPetBuffApi
 * @extends {BaseAPI}
 */
export class CharacterPetBuffApi extends BaseAPI {
    /**
     * 
     * @summary Creates CharacterPetBuff
     * @param {CharacterPetBuffApiCreateCharacterPetBuffRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterPetBuffApi
     */
    public createCharacterPetBuff(requestParameters: CharacterPetBuffApiCreateCharacterPetBuffRequest, options?: any) {
        return CharacterPetBuffApiFp(this.configuration).createCharacterPetBuff(requestParameters.characterPetBuff, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes CharacterPetBuff
     * @param {CharacterPetBuffApiDeleteCharacterPetBuffRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterPetBuffApi
     */
    public deleteCharacterPetBuff(requestParameters: CharacterPetBuffApiDeleteCharacterPetBuffRequest, options?: any) {
        return CharacterPetBuffApiFp(this.configuration).deleteCharacterPetBuff(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets CharacterPetBuff
     * @param {CharacterPetBuffApiGetCharacterPetBuffRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterPetBuffApi
     */
    public getCharacterPetBuff(requestParameters: CharacterPetBuffApiGetCharacterPetBuffRequest, options?: any) {
        return CharacterPetBuffApiFp(this.configuration).getCharacterPetBuff(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists CharacterPetBuffs
     * @param {CharacterPetBuffApiListCharacterPetBuffsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterPetBuffApi
     */
    public listCharacterPetBuffs(requestParameters: CharacterPetBuffApiListCharacterPetBuffsRequest = {}, options?: any) {
        return CharacterPetBuffApiFp(this.configuration).listCharacterPetBuffs(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates CharacterPetBuff
     * @param {CharacterPetBuffApiUpdateCharacterPetBuffRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterPetBuffApi
     */
    public updateCharacterPetBuff(requestParameters: CharacterPetBuffApiUpdateCharacterPetBuffRequest, options?: any) {
        return CharacterPetBuffApiFp(this.configuration).updateCharacterPetBuff(requestParameters.id, requestParameters.characterPetBuff, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CharacterPetInfoApi - axios parameter creator
 * @export
 */
export const CharacterPetInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharacterPetInfo
         * @param {ModelsCharacterPetInfo} characterPetInfo CharacterPetInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterPetInfo: async (characterPetInfo: ModelsCharacterPetInfo, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterPetInfo' is not null or undefined
            if (characterPetInfo === null || characterPetInfo === undefined) {
                throw new RequiredError('characterPetInfo','Required parameter characterPetInfo was null or undefined when calling createCharacterPetInfo.');
            }
            const localVarPath = `/character_pet_info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof characterPetInfo !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(characterPetInfo !== undefined ? characterPetInfo : {})
                : (characterPetInfo || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes CharacterPetInfo
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterPetInfo: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteCharacterPetInfo.');
            }
            const localVarPath = `/character_pet_info/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets CharacterPetInfo
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterPetInfo: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getCharacterPetInfo.');
            }
            const localVarPath = `/character_pet_info/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists CharacterPetInfos
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharacterPetInfos: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/character_pet_infos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates CharacterPetInfo
         * @param {number} id Id
         * @param {ModelsCharacterPetInfo} characterPetInfo CharacterPetInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharacterPetInfo: async (id: number, characterPetInfo: ModelsCharacterPetInfo, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateCharacterPetInfo.');
            }
            // verify required parameter 'characterPetInfo' is not null or undefined
            if (characterPetInfo === null || characterPetInfo === undefined) {
                throw new RequiredError('characterPetInfo','Required parameter characterPetInfo was null or undefined when calling updateCharacterPetInfo.');
            }
            const localVarPath = `/character_pet_info/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof characterPetInfo !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(characterPetInfo !== undefined ? characterPetInfo : {})
                : (characterPetInfo || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CharacterPetInfoApi - functional programming interface
 * @export
 */
export const CharacterPetInfoApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharacterPetInfo
         * @param {ModelsCharacterPetInfo} characterPetInfo CharacterPetInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCharacterPetInfo(characterPetInfo: ModelsCharacterPetInfo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterPetInfo>>> {
            const localVarAxiosArgs = await CharacterPetInfoApiAxiosParamCreator(configuration).createCharacterPetInfo(characterPetInfo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes CharacterPetInfo
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCharacterPetInfo(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await CharacterPetInfoApiAxiosParamCreator(configuration).deleteCharacterPetInfo(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets CharacterPetInfo
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharacterPetInfo(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterPetInfo>>> {
            const localVarAxiosArgs = await CharacterPetInfoApiAxiosParamCreator(configuration).getCharacterPetInfo(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists CharacterPetInfos
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCharacterPetInfos(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterPetInfo>>> {
            const localVarAxiosArgs = await CharacterPetInfoApiAxiosParamCreator(configuration).listCharacterPetInfos(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates CharacterPetInfo
         * @param {number} id Id
         * @param {ModelsCharacterPetInfo} characterPetInfo CharacterPetInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCharacterPetInfo(id: number, characterPetInfo: ModelsCharacterPetInfo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterPetInfo>>> {
            const localVarAxiosArgs = await CharacterPetInfoApiAxiosParamCreator(configuration).updateCharacterPetInfo(id, characterPetInfo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CharacterPetInfoApi - factory interface
 * @export
 */
export const CharacterPetInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates CharacterPetInfo
         * @param {ModelsCharacterPetInfo} characterPetInfo CharacterPetInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterPetInfo(characterPetInfo: ModelsCharacterPetInfo, options?: any): AxiosPromise<Array<ModelsCharacterPetInfo>> {
            return CharacterPetInfoApiFp(configuration).createCharacterPetInfo(characterPetInfo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes CharacterPetInfo
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterPetInfo(id: number, options?: any): AxiosPromise<string> {
            return CharacterPetInfoApiFp(configuration).deleteCharacterPetInfo(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets CharacterPetInfo
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterPetInfo(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharacterPetInfo>> {
            return CharacterPetInfoApiFp(configuration).getCharacterPetInfo(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists CharacterPetInfos
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharacterPetInfos(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharacterPetInfo>> {
            return CharacterPetInfoApiFp(configuration).listCharacterPetInfos(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates CharacterPetInfo
         * @param {number} id Id
         * @param {ModelsCharacterPetInfo} characterPetInfo CharacterPetInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharacterPetInfo(id: number, characterPetInfo: ModelsCharacterPetInfo, options?: any): AxiosPromise<Array<ModelsCharacterPetInfo>> {
            return CharacterPetInfoApiFp(configuration).updateCharacterPetInfo(id, characterPetInfo, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCharacterPetInfo operation in CharacterPetInfoApi.
 * @export
 * @interface CharacterPetInfoApiCreateCharacterPetInfoRequest
 */
export interface CharacterPetInfoApiCreateCharacterPetInfoRequest {
    /**
     * CharacterPetInfo
     * @type {ModelsCharacterPetInfo}
     * @memberof CharacterPetInfoApiCreateCharacterPetInfo
     */
    readonly characterPetInfo: ModelsCharacterPetInfo
}

/**
 * Request parameters for deleteCharacterPetInfo operation in CharacterPetInfoApi.
 * @export
 * @interface CharacterPetInfoApiDeleteCharacterPetInfoRequest
 */
export interface CharacterPetInfoApiDeleteCharacterPetInfoRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterPetInfoApiDeleteCharacterPetInfo
     */
    readonly id: number
}

/**
 * Request parameters for getCharacterPetInfo operation in CharacterPetInfoApi.
 * @export
 * @interface CharacterPetInfoApiGetCharacterPetInfoRequest
 */
export interface CharacterPetInfoApiGetCharacterPetInfoRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterPetInfoApiGetCharacterPetInfo
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharacterPetInfoApiGetCharacterPetInfo
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharacterPetInfoApiGetCharacterPetInfo
     */
    readonly select?: string
}

/**
 * Request parameters for listCharacterPetInfos operation in CharacterPetInfoApi.
 * @export
 * @interface CharacterPetInfoApiListCharacterPetInfosRequest
 */
export interface CharacterPetInfoApiListCharacterPetInfosRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharacterPetInfoApiListCharacterPetInfos
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof CharacterPetInfoApiListCharacterPetInfos
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof CharacterPetInfoApiListCharacterPetInfos
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof CharacterPetInfoApiListCharacterPetInfos
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof CharacterPetInfoApiListCharacterPetInfos
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharacterPetInfoApiListCharacterPetInfos
     */
    readonly select?: string
}

/**
 * Request parameters for updateCharacterPetInfo operation in CharacterPetInfoApi.
 * @export
 * @interface CharacterPetInfoApiUpdateCharacterPetInfoRequest
 */
export interface CharacterPetInfoApiUpdateCharacterPetInfoRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterPetInfoApiUpdateCharacterPetInfo
     */
    readonly id: number

    /**
     * CharacterPetInfo
     * @type {ModelsCharacterPetInfo}
     * @memberof CharacterPetInfoApiUpdateCharacterPetInfo
     */
    readonly characterPetInfo: ModelsCharacterPetInfo
}

/**
 * CharacterPetInfoApi - object-oriented interface
 * @export
 * @class CharacterPetInfoApi
 * @extends {BaseAPI}
 */
export class CharacterPetInfoApi extends BaseAPI {
    /**
     * 
     * @summary Creates CharacterPetInfo
     * @param {CharacterPetInfoApiCreateCharacterPetInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterPetInfoApi
     */
    public createCharacterPetInfo(requestParameters: CharacterPetInfoApiCreateCharacterPetInfoRequest, options?: any) {
        return CharacterPetInfoApiFp(this.configuration).createCharacterPetInfo(requestParameters.characterPetInfo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes CharacterPetInfo
     * @param {CharacterPetInfoApiDeleteCharacterPetInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterPetInfoApi
     */
    public deleteCharacterPetInfo(requestParameters: CharacterPetInfoApiDeleteCharacterPetInfoRequest, options?: any) {
        return CharacterPetInfoApiFp(this.configuration).deleteCharacterPetInfo(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets CharacterPetInfo
     * @param {CharacterPetInfoApiGetCharacterPetInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterPetInfoApi
     */
    public getCharacterPetInfo(requestParameters: CharacterPetInfoApiGetCharacterPetInfoRequest, options?: any) {
        return CharacterPetInfoApiFp(this.configuration).getCharacterPetInfo(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists CharacterPetInfos
     * @param {CharacterPetInfoApiListCharacterPetInfosRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterPetInfoApi
     */
    public listCharacterPetInfos(requestParameters: CharacterPetInfoApiListCharacterPetInfosRequest = {}, options?: any) {
        return CharacterPetInfoApiFp(this.configuration).listCharacterPetInfos(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates CharacterPetInfo
     * @param {CharacterPetInfoApiUpdateCharacterPetInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterPetInfoApi
     */
    public updateCharacterPetInfo(requestParameters: CharacterPetInfoApiUpdateCharacterPetInfoRequest, options?: any) {
        return CharacterPetInfoApiFp(this.configuration).updateCharacterPetInfo(requestParameters.id, requestParameters.characterPetInfo, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CharacterPetInventoryApi - axios parameter creator
 * @export
 */
export const CharacterPetInventoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharacterPetInventory
         * @param {ModelsCharacterPetInventory} characterPetInventory CharacterPetInventory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterPetInventory: async (characterPetInventory: ModelsCharacterPetInventory, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterPetInventory' is not null or undefined
            if (characterPetInventory === null || characterPetInventory === undefined) {
                throw new RequiredError('characterPetInventory','Required parameter characterPetInventory was null or undefined when calling createCharacterPetInventory.');
            }
            const localVarPath = `/character_pet_inventory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof characterPetInventory !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(characterPetInventory !== undefined ? characterPetInventory : {})
                : (characterPetInventory || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes CharacterPetInventory
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterPetInventory: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteCharacterPetInventory.');
            }
            const localVarPath = `/character_pet_inventory/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets CharacterPetInventory
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterPetInventory: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getCharacterPetInventory.');
            }
            const localVarPath = `/character_pet_inventory/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists CharacterPetInventories
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharacterPetInventories: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/character_pet_inventories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates CharacterPetInventory
         * @param {number} id Id
         * @param {ModelsCharacterPetInventory} characterPetInventory CharacterPetInventory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharacterPetInventory: async (id: number, characterPetInventory: ModelsCharacterPetInventory, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateCharacterPetInventory.');
            }
            // verify required parameter 'characterPetInventory' is not null or undefined
            if (characterPetInventory === null || characterPetInventory === undefined) {
                throw new RequiredError('characterPetInventory','Required parameter characterPetInventory was null or undefined when calling updateCharacterPetInventory.');
            }
            const localVarPath = `/character_pet_inventory/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof characterPetInventory !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(characterPetInventory !== undefined ? characterPetInventory : {})
                : (characterPetInventory || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CharacterPetInventoryApi - functional programming interface
 * @export
 */
export const CharacterPetInventoryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharacterPetInventory
         * @param {ModelsCharacterPetInventory} characterPetInventory CharacterPetInventory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCharacterPetInventory(characterPetInventory: ModelsCharacterPetInventory, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterPetInventory>>> {
            const localVarAxiosArgs = await CharacterPetInventoryApiAxiosParamCreator(configuration).createCharacterPetInventory(characterPetInventory, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes CharacterPetInventory
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCharacterPetInventory(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await CharacterPetInventoryApiAxiosParamCreator(configuration).deleteCharacterPetInventory(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets CharacterPetInventory
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharacterPetInventory(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterPetInventory>>> {
            const localVarAxiosArgs = await CharacterPetInventoryApiAxiosParamCreator(configuration).getCharacterPetInventory(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists CharacterPetInventories
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCharacterPetInventories(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterPetInventory>>> {
            const localVarAxiosArgs = await CharacterPetInventoryApiAxiosParamCreator(configuration).listCharacterPetInventories(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates CharacterPetInventory
         * @param {number} id Id
         * @param {ModelsCharacterPetInventory} characterPetInventory CharacterPetInventory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCharacterPetInventory(id: number, characterPetInventory: ModelsCharacterPetInventory, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterPetInventory>>> {
            const localVarAxiosArgs = await CharacterPetInventoryApiAxiosParamCreator(configuration).updateCharacterPetInventory(id, characterPetInventory, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CharacterPetInventoryApi - factory interface
 * @export
 */
export const CharacterPetInventoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates CharacterPetInventory
         * @param {ModelsCharacterPetInventory} characterPetInventory CharacterPetInventory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterPetInventory(characterPetInventory: ModelsCharacterPetInventory, options?: any): AxiosPromise<Array<ModelsCharacterPetInventory>> {
            return CharacterPetInventoryApiFp(configuration).createCharacterPetInventory(characterPetInventory, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes CharacterPetInventory
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterPetInventory(id: number, options?: any): AxiosPromise<string> {
            return CharacterPetInventoryApiFp(configuration).deleteCharacterPetInventory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets CharacterPetInventory
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterPetInventory(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharacterPetInventory>> {
            return CharacterPetInventoryApiFp(configuration).getCharacterPetInventory(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists CharacterPetInventories
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharacterPetInventories(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharacterPetInventory>> {
            return CharacterPetInventoryApiFp(configuration).listCharacterPetInventories(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates CharacterPetInventory
         * @param {number} id Id
         * @param {ModelsCharacterPetInventory} characterPetInventory CharacterPetInventory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharacterPetInventory(id: number, characterPetInventory: ModelsCharacterPetInventory, options?: any): AxiosPromise<Array<ModelsCharacterPetInventory>> {
            return CharacterPetInventoryApiFp(configuration).updateCharacterPetInventory(id, characterPetInventory, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCharacterPetInventory operation in CharacterPetInventoryApi.
 * @export
 * @interface CharacterPetInventoryApiCreateCharacterPetInventoryRequest
 */
export interface CharacterPetInventoryApiCreateCharacterPetInventoryRequest {
    /**
     * CharacterPetInventory
     * @type {ModelsCharacterPetInventory}
     * @memberof CharacterPetInventoryApiCreateCharacterPetInventory
     */
    readonly characterPetInventory: ModelsCharacterPetInventory
}

/**
 * Request parameters for deleteCharacterPetInventory operation in CharacterPetInventoryApi.
 * @export
 * @interface CharacterPetInventoryApiDeleteCharacterPetInventoryRequest
 */
export interface CharacterPetInventoryApiDeleteCharacterPetInventoryRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterPetInventoryApiDeleteCharacterPetInventory
     */
    readonly id: number
}

/**
 * Request parameters for getCharacterPetInventory operation in CharacterPetInventoryApi.
 * @export
 * @interface CharacterPetInventoryApiGetCharacterPetInventoryRequest
 */
export interface CharacterPetInventoryApiGetCharacterPetInventoryRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterPetInventoryApiGetCharacterPetInventory
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharacterPetInventoryApiGetCharacterPetInventory
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharacterPetInventoryApiGetCharacterPetInventory
     */
    readonly select?: string
}

/**
 * Request parameters for listCharacterPetInventories operation in CharacterPetInventoryApi.
 * @export
 * @interface CharacterPetInventoryApiListCharacterPetInventoriesRequest
 */
export interface CharacterPetInventoryApiListCharacterPetInventoriesRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharacterPetInventoryApiListCharacterPetInventories
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof CharacterPetInventoryApiListCharacterPetInventories
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof CharacterPetInventoryApiListCharacterPetInventories
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof CharacterPetInventoryApiListCharacterPetInventories
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof CharacterPetInventoryApiListCharacterPetInventories
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharacterPetInventoryApiListCharacterPetInventories
     */
    readonly select?: string
}

/**
 * Request parameters for updateCharacterPetInventory operation in CharacterPetInventoryApi.
 * @export
 * @interface CharacterPetInventoryApiUpdateCharacterPetInventoryRequest
 */
export interface CharacterPetInventoryApiUpdateCharacterPetInventoryRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterPetInventoryApiUpdateCharacterPetInventory
     */
    readonly id: number

    /**
     * CharacterPetInventory
     * @type {ModelsCharacterPetInventory}
     * @memberof CharacterPetInventoryApiUpdateCharacterPetInventory
     */
    readonly characterPetInventory: ModelsCharacterPetInventory
}

/**
 * CharacterPetInventoryApi - object-oriented interface
 * @export
 * @class CharacterPetInventoryApi
 * @extends {BaseAPI}
 */
export class CharacterPetInventoryApi extends BaseAPI {
    /**
     * 
     * @summary Creates CharacterPetInventory
     * @param {CharacterPetInventoryApiCreateCharacterPetInventoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterPetInventoryApi
     */
    public createCharacterPetInventory(requestParameters: CharacterPetInventoryApiCreateCharacterPetInventoryRequest, options?: any) {
        return CharacterPetInventoryApiFp(this.configuration).createCharacterPetInventory(requestParameters.characterPetInventory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes CharacterPetInventory
     * @param {CharacterPetInventoryApiDeleteCharacterPetInventoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterPetInventoryApi
     */
    public deleteCharacterPetInventory(requestParameters: CharacterPetInventoryApiDeleteCharacterPetInventoryRequest, options?: any) {
        return CharacterPetInventoryApiFp(this.configuration).deleteCharacterPetInventory(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets CharacterPetInventory
     * @param {CharacterPetInventoryApiGetCharacterPetInventoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterPetInventoryApi
     */
    public getCharacterPetInventory(requestParameters: CharacterPetInventoryApiGetCharacterPetInventoryRequest, options?: any) {
        return CharacterPetInventoryApiFp(this.configuration).getCharacterPetInventory(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists CharacterPetInventories
     * @param {CharacterPetInventoryApiListCharacterPetInventoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterPetInventoryApi
     */
    public listCharacterPetInventories(requestParameters: CharacterPetInventoryApiListCharacterPetInventoriesRequest = {}, options?: any) {
        return CharacterPetInventoryApiFp(this.configuration).listCharacterPetInventories(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates CharacterPetInventory
     * @param {CharacterPetInventoryApiUpdateCharacterPetInventoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterPetInventoryApi
     */
    public updateCharacterPetInventory(requestParameters: CharacterPetInventoryApiUpdateCharacterPetInventoryRequest, options?: any) {
        return CharacterPetInventoryApiFp(this.configuration).updateCharacterPetInventory(requestParameters.id, requestParameters.characterPetInventory, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CharacterPotionbeltApi - axios parameter creator
 * @export
 */
export const CharacterPotionbeltApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharacterPotionbelt
         * @param {ModelsCharacterPotionbelt} characterPotionbelt CharacterPotionbelt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterPotionbelt: async (characterPotionbelt: ModelsCharacterPotionbelt, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterPotionbelt' is not null or undefined
            if (characterPotionbelt === null || characterPotionbelt === undefined) {
                throw new RequiredError('characterPotionbelt','Required parameter characterPotionbelt was null or undefined when calling createCharacterPotionbelt.');
            }
            const localVarPath = `/character_potionbelt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof characterPotionbelt !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(characterPotionbelt !== undefined ? characterPotionbelt : {})
                : (characterPotionbelt || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes CharacterPotionbelt
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterPotionbelt: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteCharacterPotionbelt.');
            }
            const localVarPath = `/character_potionbelt/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets CharacterPotionbelt
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterPotionbelt: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getCharacterPotionbelt.');
            }
            const localVarPath = `/character_potionbelt/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists CharacterPotionbelts
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharacterPotionbelts: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/character_potionbelts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates CharacterPotionbelt
         * @param {number} id Id
         * @param {ModelsCharacterPotionbelt} characterPotionbelt CharacterPotionbelt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharacterPotionbelt: async (id: number, characterPotionbelt: ModelsCharacterPotionbelt, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateCharacterPotionbelt.');
            }
            // verify required parameter 'characterPotionbelt' is not null or undefined
            if (characterPotionbelt === null || characterPotionbelt === undefined) {
                throw new RequiredError('characterPotionbelt','Required parameter characterPotionbelt was null or undefined when calling updateCharacterPotionbelt.');
            }
            const localVarPath = `/character_potionbelt/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof characterPotionbelt !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(characterPotionbelt !== undefined ? characterPotionbelt : {})
                : (characterPotionbelt || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CharacterPotionbeltApi - functional programming interface
 * @export
 */
export const CharacterPotionbeltApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharacterPotionbelt
         * @param {ModelsCharacterPotionbelt} characterPotionbelt CharacterPotionbelt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCharacterPotionbelt(characterPotionbelt: ModelsCharacterPotionbelt, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterPotionbelt>>> {
            const localVarAxiosArgs = await CharacterPotionbeltApiAxiosParamCreator(configuration).createCharacterPotionbelt(characterPotionbelt, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes CharacterPotionbelt
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCharacterPotionbelt(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await CharacterPotionbeltApiAxiosParamCreator(configuration).deleteCharacterPotionbelt(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets CharacterPotionbelt
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharacterPotionbelt(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterPotionbelt>>> {
            const localVarAxiosArgs = await CharacterPotionbeltApiAxiosParamCreator(configuration).getCharacterPotionbelt(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists CharacterPotionbelts
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCharacterPotionbelts(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterPotionbelt>>> {
            const localVarAxiosArgs = await CharacterPotionbeltApiAxiosParamCreator(configuration).listCharacterPotionbelts(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates CharacterPotionbelt
         * @param {number} id Id
         * @param {ModelsCharacterPotionbelt} characterPotionbelt CharacterPotionbelt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCharacterPotionbelt(id: number, characterPotionbelt: ModelsCharacterPotionbelt, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterPotionbelt>>> {
            const localVarAxiosArgs = await CharacterPotionbeltApiAxiosParamCreator(configuration).updateCharacterPotionbelt(id, characterPotionbelt, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CharacterPotionbeltApi - factory interface
 * @export
 */
export const CharacterPotionbeltApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates CharacterPotionbelt
         * @param {ModelsCharacterPotionbelt} characterPotionbelt CharacterPotionbelt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterPotionbelt(characterPotionbelt: ModelsCharacterPotionbelt, options?: any): AxiosPromise<Array<ModelsCharacterPotionbelt>> {
            return CharacterPotionbeltApiFp(configuration).createCharacterPotionbelt(characterPotionbelt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes CharacterPotionbelt
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterPotionbelt(id: number, options?: any): AxiosPromise<string> {
            return CharacterPotionbeltApiFp(configuration).deleteCharacterPotionbelt(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets CharacterPotionbelt
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterPotionbelt(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharacterPotionbelt>> {
            return CharacterPotionbeltApiFp(configuration).getCharacterPotionbelt(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists CharacterPotionbelts
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharacterPotionbelts(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharacterPotionbelt>> {
            return CharacterPotionbeltApiFp(configuration).listCharacterPotionbelts(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates CharacterPotionbelt
         * @param {number} id Id
         * @param {ModelsCharacterPotionbelt} characterPotionbelt CharacterPotionbelt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharacterPotionbelt(id: number, characterPotionbelt: ModelsCharacterPotionbelt, options?: any): AxiosPromise<Array<ModelsCharacterPotionbelt>> {
            return CharacterPotionbeltApiFp(configuration).updateCharacterPotionbelt(id, characterPotionbelt, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCharacterPotionbelt operation in CharacterPotionbeltApi.
 * @export
 * @interface CharacterPotionbeltApiCreateCharacterPotionbeltRequest
 */
export interface CharacterPotionbeltApiCreateCharacterPotionbeltRequest {
    /**
     * CharacterPotionbelt
     * @type {ModelsCharacterPotionbelt}
     * @memberof CharacterPotionbeltApiCreateCharacterPotionbelt
     */
    readonly characterPotionbelt: ModelsCharacterPotionbelt
}

/**
 * Request parameters for deleteCharacterPotionbelt operation in CharacterPotionbeltApi.
 * @export
 * @interface CharacterPotionbeltApiDeleteCharacterPotionbeltRequest
 */
export interface CharacterPotionbeltApiDeleteCharacterPotionbeltRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterPotionbeltApiDeleteCharacterPotionbelt
     */
    readonly id: number
}

/**
 * Request parameters for getCharacterPotionbelt operation in CharacterPotionbeltApi.
 * @export
 * @interface CharacterPotionbeltApiGetCharacterPotionbeltRequest
 */
export interface CharacterPotionbeltApiGetCharacterPotionbeltRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterPotionbeltApiGetCharacterPotionbelt
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharacterPotionbeltApiGetCharacterPotionbelt
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharacterPotionbeltApiGetCharacterPotionbelt
     */
    readonly select?: string
}

/**
 * Request parameters for listCharacterPotionbelts operation in CharacterPotionbeltApi.
 * @export
 * @interface CharacterPotionbeltApiListCharacterPotionbeltsRequest
 */
export interface CharacterPotionbeltApiListCharacterPotionbeltsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharacterPotionbeltApiListCharacterPotionbelts
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof CharacterPotionbeltApiListCharacterPotionbelts
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof CharacterPotionbeltApiListCharacterPotionbelts
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof CharacterPotionbeltApiListCharacterPotionbelts
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof CharacterPotionbeltApiListCharacterPotionbelts
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharacterPotionbeltApiListCharacterPotionbelts
     */
    readonly select?: string
}

/**
 * Request parameters for updateCharacterPotionbelt operation in CharacterPotionbeltApi.
 * @export
 * @interface CharacterPotionbeltApiUpdateCharacterPotionbeltRequest
 */
export interface CharacterPotionbeltApiUpdateCharacterPotionbeltRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterPotionbeltApiUpdateCharacterPotionbelt
     */
    readonly id: number

    /**
     * CharacterPotionbelt
     * @type {ModelsCharacterPotionbelt}
     * @memberof CharacterPotionbeltApiUpdateCharacterPotionbelt
     */
    readonly characterPotionbelt: ModelsCharacterPotionbelt
}

/**
 * CharacterPotionbeltApi - object-oriented interface
 * @export
 * @class CharacterPotionbeltApi
 * @extends {BaseAPI}
 */
export class CharacterPotionbeltApi extends BaseAPI {
    /**
     * 
     * @summary Creates CharacterPotionbelt
     * @param {CharacterPotionbeltApiCreateCharacterPotionbeltRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterPotionbeltApi
     */
    public createCharacterPotionbelt(requestParameters: CharacterPotionbeltApiCreateCharacterPotionbeltRequest, options?: any) {
        return CharacterPotionbeltApiFp(this.configuration).createCharacterPotionbelt(requestParameters.characterPotionbelt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes CharacterPotionbelt
     * @param {CharacterPotionbeltApiDeleteCharacterPotionbeltRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterPotionbeltApi
     */
    public deleteCharacterPotionbelt(requestParameters: CharacterPotionbeltApiDeleteCharacterPotionbeltRequest, options?: any) {
        return CharacterPotionbeltApiFp(this.configuration).deleteCharacterPotionbelt(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets CharacterPotionbelt
     * @param {CharacterPotionbeltApiGetCharacterPotionbeltRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterPotionbeltApi
     */
    public getCharacterPotionbelt(requestParameters: CharacterPotionbeltApiGetCharacterPotionbeltRequest, options?: any) {
        return CharacterPotionbeltApiFp(this.configuration).getCharacterPotionbelt(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists CharacterPotionbelts
     * @param {CharacterPotionbeltApiListCharacterPotionbeltsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterPotionbeltApi
     */
    public listCharacterPotionbelts(requestParameters: CharacterPotionbeltApiListCharacterPotionbeltsRequest = {}, options?: any) {
        return CharacterPotionbeltApiFp(this.configuration).listCharacterPotionbelts(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates CharacterPotionbelt
     * @param {CharacterPotionbeltApiUpdateCharacterPotionbeltRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterPotionbeltApi
     */
    public updateCharacterPotionbelt(requestParameters: CharacterPotionbeltApiUpdateCharacterPotionbeltRequest, options?: any) {
        return CharacterPotionbeltApiFp(this.configuration).updateCharacterPotionbelt(requestParameters.id, requestParameters.characterPotionbelt, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CharacterSkillApi - axios parameter creator
 * @export
 */
export const CharacterSkillApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharacterSkill
         * @param {ModelsCharacterSkill} characterSkill CharacterSkill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterSkill: async (characterSkill: ModelsCharacterSkill, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterSkill' is not null or undefined
            if (characterSkill === null || characterSkill === undefined) {
                throw new RequiredError('characterSkill','Required parameter characterSkill was null or undefined when calling createCharacterSkill.');
            }
            const localVarPath = `/character_skill`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof characterSkill !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(characterSkill !== undefined ? characterSkill : {})
                : (characterSkill || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes CharacterSkill
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterSkill: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteCharacterSkill.');
            }
            const localVarPath = `/character_skill/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets CharacterSkill
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterSkill: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getCharacterSkill.');
            }
            const localVarPath = `/character_skill/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists CharacterSkills
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharacterSkills: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/character_skills`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates CharacterSkill
         * @param {number} id Id
         * @param {ModelsCharacterSkill} characterSkill CharacterSkill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharacterSkill: async (id: number, characterSkill: ModelsCharacterSkill, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateCharacterSkill.');
            }
            // verify required parameter 'characterSkill' is not null or undefined
            if (characterSkill === null || characterSkill === undefined) {
                throw new RequiredError('characterSkill','Required parameter characterSkill was null or undefined when calling updateCharacterSkill.');
            }
            const localVarPath = `/character_skill/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof characterSkill !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(characterSkill !== undefined ? characterSkill : {})
                : (characterSkill || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CharacterSkillApi - functional programming interface
 * @export
 */
export const CharacterSkillApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharacterSkill
         * @param {ModelsCharacterSkill} characterSkill CharacterSkill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCharacterSkill(characterSkill: ModelsCharacterSkill, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterSkill>>> {
            const localVarAxiosArgs = await CharacterSkillApiAxiosParamCreator(configuration).createCharacterSkill(characterSkill, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes CharacterSkill
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCharacterSkill(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await CharacterSkillApiAxiosParamCreator(configuration).deleteCharacterSkill(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets CharacterSkill
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharacterSkill(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterSkill>>> {
            const localVarAxiosArgs = await CharacterSkillApiAxiosParamCreator(configuration).getCharacterSkill(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists CharacterSkills
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCharacterSkills(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterSkill>>> {
            const localVarAxiosArgs = await CharacterSkillApiAxiosParamCreator(configuration).listCharacterSkills(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates CharacterSkill
         * @param {number} id Id
         * @param {ModelsCharacterSkill} characterSkill CharacterSkill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCharacterSkill(id: number, characterSkill: ModelsCharacterSkill, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterSkill>>> {
            const localVarAxiosArgs = await CharacterSkillApiAxiosParamCreator(configuration).updateCharacterSkill(id, characterSkill, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CharacterSkillApi - factory interface
 * @export
 */
export const CharacterSkillApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates CharacterSkill
         * @param {ModelsCharacterSkill} characterSkill CharacterSkill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterSkill(characterSkill: ModelsCharacterSkill, options?: any): AxiosPromise<Array<ModelsCharacterSkill>> {
            return CharacterSkillApiFp(configuration).createCharacterSkill(characterSkill, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes CharacterSkill
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterSkill(id: number, options?: any): AxiosPromise<string> {
            return CharacterSkillApiFp(configuration).deleteCharacterSkill(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets CharacterSkill
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterSkill(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharacterSkill>> {
            return CharacterSkillApiFp(configuration).getCharacterSkill(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists CharacterSkills
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharacterSkills(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharacterSkill>> {
            return CharacterSkillApiFp(configuration).listCharacterSkills(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates CharacterSkill
         * @param {number} id Id
         * @param {ModelsCharacterSkill} characterSkill CharacterSkill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharacterSkill(id: number, characterSkill: ModelsCharacterSkill, options?: any): AxiosPromise<Array<ModelsCharacterSkill>> {
            return CharacterSkillApiFp(configuration).updateCharacterSkill(id, characterSkill, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCharacterSkill operation in CharacterSkillApi.
 * @export
 * @interface CharacterSkillApiCreateCharacterSkillRequest
 */
export interface CharacterSkillApiCreateCharacterSkillRequest {
    /**
     * CharacterSkill
     * @type {ModelsCharacterSkill}
     * @memberof CharacterSkillApiCreateCharacterSkill
     */
    readonly characterSkill: ModelsCharacterSkill
}

/**
 * Request parameters for deleteCharacterSkill operation in CharacterSkillApi.
 * @export
 * @interface CharacterSkillApiDeleteCharacterSkillRequest
 */
export interface CharacterSkillApiDeleteCharacterSkillRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterSkillApiDeleteCharacterSkill
     */
    readonly id: number
}

/**
 * Request parameters for getCharacterSkill operation in CharacterSkillApi.
 * @export
 * @interface CharacterSkillApiGetCharacterSkillRequest
 */
export interface CharacterSkillApiGetCharacterSkillRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterSkillApiGetCharacterSkill
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharacterSkillApiGetCharacterSkill
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharacterSkillApiGetCharacterSkill
     */
    readonly select?: string
}

/**
 * Request parameters for listCharacterSkills operation in CharacterSkillApi.
 * @export
 * @interface CharacterSkillApiListCharacterSkillsRequest
 */
export interface CharacterSkillApiListCharacterSkillsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharacterSkillApiListCharacterSkills
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof CharacterSkillApiListCharacterSkills
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof CharacterSkillApiListCharacterSkills
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof CharacterSkillApiListCharacterSkills
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof CharacterSkillApiListCharacterSkills
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharacterSkillApiListCharacterSkills
     */
    readonly select?: string
}

/**
 * Request parameters for updateCharacterSkill operation in CharacterSkillApi.
 * @export
 * @interface CharacterSkillApiUpdateCharacterSkillRequest
 */
export interface CharacterSkillApiUpdateCharacterSkillRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterSkillApiUpdateCharacterSkill
     */
    readonly id: number

    /**
     * CharacterSkill
     * @type {ModelsCharacterSkill}
     * @memberof CharacterSkillApiUpdateCharacterSkill
     */
    readonly characterSkill: ModelsCharacterSkill
}

/**
 * CharacterSkillApi - object-oriented interface
 * @export
 * @class CharacterSkillApi
 * @extends {BaseAPI}
 */
export class CharacterSkillApi extends BaseAPI {
    /**
     * 
     * @summary Creates CharacterSkill
     * @param {CharacterSkillApiCreateCharacterSkillRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterSkillApi
     */
    public createCharacterSkill(requestParameters: CharacterSkillApiCreateCharacterSkillRequest, options?: any) {
        return CharacterSkillApiFp(this.configuration).createCharacterSkill(requestParameters.characterSkill, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes CharacterSkill
     * @param {CharacterSkillApiDeleteCharacterSkillRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterSkillApi
     */
    public deleteCharacterSkill(requestParameters: CharacterSkillApiDeleteCharacterSkillRequest, options?: any) {
        return CharacterSkillApiFp(this.configuration).deleteCharacterSkill(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets CharacterSkill
     * @param {CharacterSkillApiGetCharacterSkillRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterSkillApi
     */
    public getCharacterSkill(requestParameters: CharacterSkillApiGetCharacterSkillRequest, options?: any) {
        return CharacterSkillApiFp(this.configuration).getCharacterSkill(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists CharacterSkills
     * @param {CharacterSkillApiListCharacterSkillsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterSkillApi
     */
    public listCharacterSkills(requestParameters: CharacterSkillApiListCharacterSkillsRequest = {}, options?: any) {
        return CharacterSkillApiFp(this.configuration).listCharacterSkills(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates CharacterSkill
     * @param {CharacterSkillApiUpdateCharacterSkillRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterSkillApi
     */
    public updateCharacterSkill(requestParameters: CharacterSkillApiUpdateCharacterSkillRequest, options?: any) {
        return CharacterSkillApiFp(this.configuration).updateCharacterSkill(requestParameters.id, requestParameters.characterSkill, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CharacterSpellApi - axios parameter creator
 * @export
 */
export const CharacterSpellApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharacterSpell
         * @param {ModelsCharacterSpell} characterSpell CharacterSpell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterSpell: async (characterSpell: ModelsCharacterSpell, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterSpell' is not null or undefined
            if (characterSpell === null || characterSpell === undefined) {
                throw new RequiredError('characterSpell','Required parameter characterSpell was null or undefined when calling createCharacterSpell.');
            }
            const localVarPath = `/character_spell`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof characterSpell !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(characterSpell !== undefined ? characterSpell : {})
                : (characterSpell || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes CharacterSpell
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterSpell: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteCharacterSpell.');
            }
            const localVarPath = `/character_spell/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets CharacterSpell
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterSpell: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getCharacterSpell.');
            }
            const localVarPath = `/character_spell/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists CharacterSpells
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharacterSpells: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/character_spells`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates CharacterSpell
         * @param {number} id Id
         * @param {ModelsCharacterSpell} characterSpell CharacterSpell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharacterSpell: async (id: number, characterSpell: ModelsCharacterSpell, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateCharacterSpell.');
            }
            // verify required parameter 'characterSpell' is not null or undefined
            if (characterSpell === null || characterSpell === undefined) {
                throw new RequiredError('characterSpell','Required parameter characterSpell was null or undefined when calling updateCharacterSpell.');
            }
            const localVarPath = `/character_spell/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof characterSpell !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(characterSpell !== undefined ? characterSpell : {})
                : (characterSpell || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CharacterSpellApi - functional programming interface
 * @export
 */
export const CharacterSpellApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharacterSpell
         * @param {ModelsCharacterSpell} characterSpell CharacterSpell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCharacterSpell(characterSpell: ModelsCharacterSpell, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterSpell>>> {
            const localVarAxiosArgs = await CharacterSpellApiAxiosParamCreator(configuration).createCharacterSpell(characterSpell, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes CharacterSpell
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCharacterSpell(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await CharacterSpellApiAxiosParamCreator(configuration).deleteCharacterSpell(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets CharacterSpell
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharacterSpell(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterSpell>>> {
            const localVarAxiosArgs = await CharacterSpellApiAxiosParamCreator(configuration).getCharacterSpell(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists CharacterSpells
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCharacterSpells(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterSpell>>> {
            const localVarAxiosArgs = await CharacterSpellApiAxiosParamCreator(configuration).listCharacterSpells(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates CharacterSpell
         * @param {number} id Id
         * @param {ModelsCharacterSpell} characterSpell CharacterSpell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCharacterSpell(id: number, characterSpell: ModelsCharacterSpell, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterSpell>>> {
            const localVarAxiosArgs = await CharacterSpellApiAxiosParamCreator(configuration).updateCharacterSpell(id, characterSpell, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CharacterSpellApi - factory interface
 * @export
 */
export const CharacterSpellApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates CharacterSpell
         * @param {ModelsCharacterSpell} characterSpell CharacterSpell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterSpell(characterSpell: ModelsCharacterSpell, options?: any): AxiosPromise<Array<ModelsCharacterSpell>> {
            return CharacterSpellApiFp(configuration).createCharacterSpell(characterSpell, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes CharacterSpell
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterSpell(id: number, options?: any): AxiosPromise<string> {
            return CharacterSpellApiFp(configuration).deleteCharacterSpell(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets CharacterSpell
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterSpell(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharacterSpell>> {
            return CharacterSpellApiFp(configuration).getCharacterSpell(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists CharacterSpells
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharacterSpells(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharacterSpell>> {
            return CharacterSpellApiFp(configuration).listCharacterSpells(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates CharacterSpell
         * @param {number} id Id
         * @param {ModelsCharacterSpell} characterSpell CharacterSpell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharacterSpell(id: number, characterSpell: ModelsCharacterSpell, options?: any): AxiosPromise<Array<ModelsCharacterSpell>> {
            return CharacterSpellApiFp(configuration).updateCharacterSpell(id, characterSpell, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCharacterSpell operation in CharacterSpellApi.
 * @export
 * @interface CharacterSpellApiCreateCharacterSpellRequest
 */
export interface CharacterSpellApiCreateCharacterSpellRequest {
    /**
     * CharacterSpell
     * @type {ModelsCharacterSpell}
     * @memberof CharacterSpellApiCreateCharacterSpell
     */
    readonly characterSpell: ModelsCharacterSpell
}

/**
 * Request parameters for deleteCharacterSpell operation in CharacterSpellApi.
 * @export
 * @interface CharacterSpellApiDeleteCharacterSpellRequest
 */
export interface CharacterSpellApiDeleteCharacterSpellRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterSpellApiDeleteCharacterSpell
     */
    readonly id: number
}

/**
 * Request parameters for getCharacterSpell operation in CharacterSpellApi.
 * @export
 * @interface CharacterSpellApiGetCharacterSpellRequest
 */
export interface CharacterSpellApiGetCharacterSpellRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterSpellApiGetCharacterSpell
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharacterSpellApiGetCharacterSpell
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharacterSpellApiGetCharacterSpell
     */
    readonly select?: string
}

/**
 * Request parameters for listCharacterSpells operation in CharacterSpellApi.
 * @export
 * @interface CharacterSpellApiListCharacterSpellsRequest
 */
export interface CharacterSpellApiListCharacterSpellsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharacterSpellApiListCharacterSpells
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof CharacterSpellApiListCharacterSpells
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof CharacterSpellApiListCharacterSpells
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof CharacterSpellApiListCharacterSpells
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof CharacterSpellApiListCharacterSpells
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharacterSpellApiListCharacterSpells
     */
    readonly select?: string
}

/**
 * Request parameters for updateCharacterSpell operation in CharacterSpellApi.
 * @export
 * @interface CharacterSpellApiUpdateCharacterSpellRequest
 */
export interface CharacterSpellApiUpdateCharacterSpellRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterSpellApiUpdateCharacterSpell
     */
    readonly id: number

    /**
     * CharacterSpell
     * @type {ModelsCharacterSpell}
     * @memberof CharacterSpellApiUpdateCharacterSpell
     */
    readonly characterSpell: ModelsCharacterSpell
}

/**
 * CharacterSpellApi - object-oriented interface
 * @export
 * @class CharacterSpellApi
 * @extends {BaseAPI}
 */
export class CharacterSpellApi extends BaseAPI {
    /**
     * 
     * @summary Creates CharacterSpell
     * @param {CharacterSpellApiCreateCharacterSpellRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterSpellApi
     */
    public createCharacterSpell(requestParameters: CharacterSpellApiCreateCharacterSpellRequest, options?: any) {
        return CharacterSpellApiFp(this.configuration).createCharacterSpell(requestParameters.characterSpell, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes CharacterSpell
     * @param {CharacterSpellApiDeleteCharacterSpellRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterSpellApi
     */
    public deleteCharacterSpell(requestParameters: CharacterSpellApiDeleteCharacterSpellRequest, options?: any) {
        return CharacterSpellApiFp(this.configuration).deleteCharacterSpell(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets CharacterSpell
     * @param {CharacterSpellApiGetCharacterSpellRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterSpellApi
     */
    public getCharacterSpell(requestParameters: CharacterSpellApiGetCharacterSpellRequest, options?: any) {
        return CharacterSpellApiFp(this.configuration).getCharacterSpell(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists CharacterSpells
     * @param {CharacterSpellApiListCharacterSpellsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterSpellApi
     */
    public listCharacterSpells(requestParameters: CharacterSpellApiListCharacterSpellsRequest = {}, options?: any) {
        return CharacterSpellApiFp(this.configuration).listCharacterSpells(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates CharacterSpell
     * @param {CharacterSpellApiUpdateCharacterSpellRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterSpellApi
     */
    public updateCharacterSpell(requestParameters: CharacterSpellApiUpdateCharacterSpellRequest, options?: any) {
        return CharacterSpellApiFp(this.configuration).updateCharacterSpell(requestParameters.id, requestParameters.characterSpell, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CharacterTributeApi - axios parameter creator
 * @export
 */
export const CharacterTributeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharacterTribute
         * @param {ModelsCharacterTribute} characterTribute CharacterTribute
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterTribute: async (characterTribute: ModelsCharacterTribute, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterTribute' is not null or undefined
            if (characterTribute === null || characterTribute === undefined) {
                throw new RequiredError('characterTribute','Required parameter characterTribute was null or undefined when calling createCharacterTribute.');
            }
            const localVarPath = `/character_tribute`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof characterTribute !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(characterTribute !== undefined ? characterTribute : {})
                : (characterTribute || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes CharacterTribute
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterTribute: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteCharacterTribute.');
            }
            const localVarPath = `/character_tribute/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets CharacterTribute
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterTribute: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getCharacterTribute.');
            }
            const localVarPath = `/character_tribute/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists CharacterTributes
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharacterTributes: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/character_tributes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates CharacterTribute
         * @param {number} id Id
         * @param {ModelsCharacterTribute} characterTribute CharacterTribute
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharacterTribute: async (id: number, characterTribute: ModelsCharacterTribute, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateCharacterTribute.');
            }
            // verify required parameter 'characterTribute' is not null or undefined
            if (characterTribute === null || characterTribute === undefined) {
                throw new RequiredError('characterTribute','Required parameter characterTribute was null or undefined when calling updateCharacterTribute.');
            }
            const localVarPath = `/character_tribute/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof characterTribute !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(characterTribute !== undefined ? characterTribute : {})
                : (characterTribute || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CharacterTributeApi - functional programming interface
 * @export
 */
export const CharacterTributeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates CharacterTribute
         * @param {ModelsCharacterTribute} characterTribute CharacterTribute
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCharacterTribute(characterTribute: ModelsCharacterTribute, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterTribute>>> {
            const localVarAxiosArgs = await CharacterTributeApiAxiosParamCreator(configuration).createCharacterTribute(characterTribute, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes CharacterTribute
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCharacterTribute(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await CharacterTributeApiAxiosParamCreator(configuration).deleteCharacterTribute(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets CharacterTribute
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharacterTribute(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterTribute>>> {
            const localVarAxiosArgs = await CharacterTributeApiAxiosParamCreator(configuration).getCharacterTribute(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists CharacterTributes
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCharacterTributes(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterTribute>>> {
            const localVarAxiosArgs = await CharacterTributeApiAxiosParamCreator(configuration).listCharacterTributes(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates CharacterTribute
         * @param {number} id Id
         * @param {ModelsCharacterTribute} characterTribute CharacterTribute
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCharacterTribute(id: number, characterTribute: ModelsCharacterTribute, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsCharacterTribute>>> {
            const localVarAxiosArgs = await CharacterTributeApiAxiosParamCreator(configuration).updateCharacterTribute(id, characterTribute, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CharacterTributeApi - factory interface
 * @export
 */
export const CharacterTributeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates CharacterTribute
         * @param {ModelsCharacterTribute} characterTribute CharacterTribute
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterTribute(characterTribute: ModelsCharacterTribute, options?: any): AxiosPromise<Array<ModelsCharacterTribute>> {
            return CharacterTributeApiFp(configuration).createCharacterTribute(characterTribute, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes CharacterTribute
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterTribute(id: number, options?: any): AxiosPromise<string> {
            return CharacterTributeApiFp(configuration).deleteCharacterTribute(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets CharacterTribute
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterTribute(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharacterTribute>> {
            return CharacterTributeApiFp(configuration).getCharacterTribute(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists CharacterTributes
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCharacterTributes(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsCharacterTribute>> {
            return CharacterTributeApiFp(configuration).listCharacterTributes(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates CharacterTribute
         * @param {number} id Id
         * @param {ModelsCharacterTribute} characterTribute CharacterTribute
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCharacterTribute(id: number, characterTribute: ModelsCharacterTribute, options?: any): AxiosPromise<Array<ModelsCharacterTribute>> {
            return CharacterTributeApiFp(configuration).updateCharacterTribute(id, characterTribute, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCharacterTribute operation in CharacterTributeApi.
 * @export
 * @interface CharacterTributeApiCreateCharacterTributeRequest
 */
export interface CharacterTributeApiCreateCharacterTributeRequest {
    /**
     * CharacterTribute
     * @type {ModelsCharacterTribute}
     * @memberof CharacterTributeApiCreateCharacterTribute
     */
    readonly characterTribute: ModelsCharacterTribute
}

/**
 * Request parameters for deleteCharacterTribute operation in CharacterTributeApi.
 * @export
 * @interface CharacterTributeApiDeleteCharacterTributeRequest
 */
export interface CharacterTributeApiDeleteCharacterTributeRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterTributeApiDeleteCharacterTribute
     */
    readonly id: number
}

/**
 * Request parameters for getCharacterTribute operation in CharacterTributeApi.
 * @export
 * @interface CharacterTributeApiGetCharacterTributeRequest
 */
export interface CharacterTributeApiGetCharacterTributeRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterTributeApiGetCharacterTribute
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharacterTributeApiGetCharacterTribute
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharacterTributeApiGetCharacterTribute
     */
    readonly select?: string
}

/**
 * Request parameters for listCharacterTributes operation in CharacterTributeApi.
 * @export
 * @interface CharacterTributeApiListCharacterTributesRequest
 */
export interface CharacterTributeApiListCharacterTributesRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof CharacterTributeApiListCharacterTributes
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof CharacterTributeApiListCharacterTributes
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof CharacterTributeApiListCharacterTributes
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof CharacterTributeApiListCharacterTributes
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof CharacterTributeApiListCharacterTributes
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof CharacterTributeApiListCharacterTributes
     */
    readonly select?: string
}

/**
 * Request parameters for updateCharacterTribute operation in CharacterTributeApi.
 * @export
 * @interface CharacterTributeApiUpdateCharacterTributeRequest
 */
export interface CharacterTributeApiUpdateCharacterTributeRequest {
    /**
     * Id
     * @type {number}
     * @memberof CharacterTributeApiUpdateCharacterTribute
     */
    readonly id: number

    /**
     * CharacterTribute
     * @type {ModelsCharacterTribute}
     * @memberof CharacterTributeApiUpdateCharacterTribute
     */
    readonly characterTribute: ModelsCharacterTribute
}

/**
 * CharacterTributeApi - object-oriented interface
 * @export
 * @class CharacterTributeApi
 * @extends {BaseAPI}
 */
export class CharacterTributeApi extends BaseAPI {
    /**
     * 
     * @summary Creates CharacterTribute
     * @param {CharacterTributeApiCreateCharacterTributeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterTributeApi
     */
    public createCharacterTribute(requestParameters: CharacterTributeApiCreateCharacterTributeRequest, options?: any) {
        return CharacterTributeApiFp(this.configuration).createCharacterTribute(requestParameters.characterTribute, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes CharacterTribute
     * @param {CharacterTributeApiDeleteCharacterTributeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterTributeApi
     */
    public deleteCharacterTribute(requestParameters: CharacterTributeApiDeleteCharacterTributeRequest, options?: any) {
        return CharacterTributeApiFp(this.configuration).deleteCharacterTribute(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets CharacterTribute
     * @param {CharacterTributeApiGetCharacterTributeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterTributeApi
     */
    public getCharacterTribute(requestParameters: CharacterTributeApiGetCharacterTributeRequest, options?: any) {
        return CharacterTributeApiFp(this.configuration).getCharacterTribute(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists CharacterTributes
     * @param {CharacterTributeApiListCharacterTributesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterTributeApi
     */
    public listCharacterTributes(requestParameters: CharacterTributeApiListCharacterTributesRequest = {}, options?: any) {
        return CharacterTributeApiFp(this.configuration).listCharacterTributes(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates CharacterTribute
     * @param {CharacterTributeApiUpdateCharacterTributeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterTributeApi
     */
    public updateCharacterTribute(requestParameters: CharacterTributeApiUpdateCharacterTributeRequest, options?: any) {
        return CharacterTributeApiFp(this.configuration).updateCharacterTribute(requestParameters.id, requestParameters.characterTribute, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContentFlagApi - axios parameter creator
 * @export
 */
export const ContentFlagApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates ContentFlag
         * @param {ModelsContentFlag} contentFlag ContentFlag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContentFlag: async (contentFlag: ModelsContentFlag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentFlag' is not null or undefined
            if (contentFlag === null || contentFlag === undefined) {
                throw new RequiredError('contentFlag','Required parameter contentFlag was null or undefined when calling createContentFlag.');
            }
            const localVarPath = `/content_flag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof contentFlag !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(contentFlag !== undefined ? contentFlag : {})
                : (contentFlag || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes ContentFlag
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContentFlag: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteContentFlag.');
            }
            const localVarPath = `/content_flag/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets ContentFlag
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentFlag: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getContentFlag.');
            }
            const localVarPath = `/content_flag/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists ContentFlags
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContentFlags: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/content_flags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates ContentFlag
         * @param {number} id Id
         * @param {ModelsContentFlag} contentFlag ContentFlag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContentFlag: async (id: number, contentFlag: ModelsContentFlag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateContentFlag.');
            }
            // verify required parameter 'contentFlag' is not null or undefined
            if (contentFlag === null || contentFlag === undefined) {
                throw new RequiredError('contentFlag','Required parameter contentFlag was null or undefined when calling updateContentFlag.');
            }
            const localVarPath = `/content_flag/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof contentFlag !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(contentFlag !== undefined ? contentFlag : {})
                : (contentFlag || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentFlagApi - functional programming interface
 * @export
 */
export const ContentFlagApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates ContentFlag
         * @param {ModelsContentFlag} contentFlag ContentFlag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContentFlag(contentFlag: ModelsContentFlag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsContentFlag>>> {
            const localVarAxiosArgs = await ContentFlagApiAxiosParamCreator(configuration).createContentFlag(contentFlag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes ContentFlag
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContentFlag(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await ContentFlagApiAxiosParamCreator(configuration).deleteContentFlag(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets ContentFlag
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContentFlag(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsContentFlag>>> {
            const localVarAxiosArgs = await ContentFlagApiAxiosParamCreator(configuration).getContentFlag(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists ContentFlags
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContentFlags(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsContentFlag>>> {
            const localVarAxiosArgs = await ContentFlagApiAxiosParamCreator(configuration).listContentFlags(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates ContentFlag
         * @param {number} id Id
         * @param {ModelsContentFlag} contentFlag ContentFlag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContentFlag(id: number, contentFlag: ModelsContentFlag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsContentFlag>>> {
            const localVarAxiosArgs = await ContentFlagApiAxiosParamCreator(configuration).updateContentFlag(id, contentFlag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ContentFlagApi - factory interface
 * @export
 */
export const ContentFlagApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates ContentFlag
         * @param {ModelsContentFlag} contentFlag ContentFlag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContentFlag(contentFlag: ModelsContentFlag, options?: any): AxiosPromise<Array<ModelsContentFlag>> {
            return ContentFlagApiFp(configuration).createContentFlag(contentFlag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes ContentFlag
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContentFlag(id: number, options?: any): AxiosPromise<string> {
            return ContentFlagApiFp(configuration).deleteContentFlag(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets ContentFlag
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentFlag(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsContentFlag>> {
            return ContentFlagApiFp(configuration).getContentFlag(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists ContentFlags
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContentFlags(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsContentFlag>> {
            return ContentFlagApiFp(configuration).listContentFlags(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates ContentFlag
         * @param {number} id Id
         * @param {ModelsContentFlag} contentFlag ContentFlag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContentFlag(id: number, contentFlag: ModelsContentFlag, options?: any): AxiosPromise<Array<ModelsContentFlag>> {
            return ContentFlagApiFp(configuration).updateContentFlag(id, contentFlag, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createContentFlag operation in ContentFlagApi.
 * @export
 * @interface ContentFlagApiCreateContentFlagRequest
 */
export interface ContentFlagApiCreateContentFlagRequest {
    /**
     * ContentFlag
     * @type {ModelsContentFlag}
     * @memberof ContentFlagApiCreateContentFlag
     */
    readonly contentFlag: ModelsContentFlag
}

/**
 * Request parameters for deleteContentFlag operation in ContentFlagApi.
 * @export
 * @interface ContentFlagApiDeleteContentFlagRequest
 */
export interface ContentFlagApiDeleteContentFlagRequest {
    /**
     * Id
     * @type {number}
     * @memberof ContentFlagApiDeleteContentFlag
     */
    readonly id: number
}

/**
 * Request parameters for getContentFlag operation in ContentFlagApi.
 * @export
 * @interface ContentFlagApiGetContentFlagRequest
 */
export interface ContentFlagApiGetContentFlagRequest {
    /**
     * Id
     * @type {number}
     * @memberof ContentFlagApiGetContentFlag
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof ContentFlagApiGetContentFlag
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof ContentFlagApiGetContentFlag
     */
    readonly select?: string
}

/**
 * Request parameters for listContentFlags operation in ContentFlagApi.
 * @export
 * @interface ContentFlagApiListContentFlagsRequest
 */
export interface ContentFlagApiListContentFlagsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof ContentFlagApiListContentFlags
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof ContentFlagApiListContentFlags
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof ContentFlagApiListContentFlags
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof ContentFlagApiListContentFlags
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof ContentFlagApiListContentFlags
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof ContentFlagApiListContentFlags
     */
    readonly select?: string
}

/**
 * Request parameters for updateContentFlag operation in ContentFlagApi.
 * @export
 * @interface ContentFlagApiUpdateContentFlagRequest
 */
export interface ContentFlagApiUpdateContentFlagRequest {
    /**
     * Id
     * @type {number}
     * @memberof ContentFlagApiUpdateContentFlag
     */
    readonly id: number

    /**
     * ContentFlag
     * @type {ModelsContentFlag}
     * @memberof ContentFlagApiUpdateContentFlag
     */
    readonly contentFlag: ModelsContentFlag
}

/**
 * ContentFlagApi - object-oriented interface
 * @export
 * @class ContentFlagApi
 * @extends {BaseAPI}
 */
export class ContentFlagApi extends BaseAPI {
    /**
     * 
     * @summary Creates ContentFlag
     * @param {ContentFlagApiCreateContentFlagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentFlagApi
     */
    public createContentFlag(requestParameters: ContentFlagApiCreateContentFlagRequest, options?: any) {
        return ContentFlagApiFp(this.configuration).createContentFlag(requestParameters.contentFlag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes ContentFlag
     * @param {ContentFlagApiDeleteContentFlagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentFlagApi
     */
    public deleteContentFlag(requestParameters: ContentFlagApiDeleteContentFlagRequest, options?: any) {
        return ContentFlagApiFp(this.configuration).deleteContentFlag(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets ContentFlag
     * @param {ContentFlagApiGetContentFlagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentFlagApi
     */
    public getContentFlag(requestParameters: ContentFlagApiGetContentFlagRequest, options?: any) {
        return ContentFlagApiFp(this.configuration).getContentFlag(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists ContentFlags
     * @param {ContentFlagApiListContentFlagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentFlagApi
     */
    public listContentFlags(requestParameters: ContentFlagApiListContentFlagsRequest = {}, options?: any) {
        return ContentFlagApiFp(this.configuration).listContentFlags(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates ContentFlag
     * @param {ContentFlagApiUpdateContentFlagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentFlagApi
     */
    public updateContentFlag(requestParameters: ContentFlagApiUpdateContentFlagRequest, options?: any) {
        return ContentFlagApiFp(this.configuration).updateContentFlag(requestParameters.id, requestParameters.contentFlag, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DataBucketApi - axios parameter creator
 * @export
 */
export const DataBucketApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates DataBucket
         * @param {ModelsDataBucket} dataBucket DataBucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataBucket: async (dataBucket: ModelsDataBucket, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataBucket' is not null or undefined
            if (dataBucket === null || dataBucket === undefined) {
                throw new RequiredError('dataBucket','Required parameter dataBucket was null or undefined when calling createDataBucket.');
            }
            const localVarPath = `/data_bucket`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof dataBucket !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(dataBucket !== undefined ? dataBucket : {})
                : (dataBucket || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes DataBucket
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDataBucket: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteDataBucket.');
            }
            const localVarPath = `/data_bucket/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets DataBucket
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataBucket: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDataBucket.');
            }
            const localVarPath = `/data_bucket/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists DataBuckets
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDataBuckets: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/data_buckets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates DataBucket
         * @param {number} id Id
         * @param {ModelsDataBucket} dataBucket DataBucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDataBucket: async (id: number, dataBucket: ModelsDataBucket, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateDataBucket.');
            }
            // verify required parameter 'dataBucket' is not null or undefined
            if (dataBucket === null || dataBucket === undefined) {
                throw new RequiredError('dataBucket','Required parameter dataBucket was null or undefined when calling updateDataBucket.');
            }
            const localVarPath = `/data_bucket/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof dataBucket !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(dataBucket !== undefined ? dataBucket : {})
                : (dataBucket || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataBucketApi - functional programming interface
 * @export
 */
export const DataBucketApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates DataBucket
         * @param {ModelsDataBucket} dataBucket DataBucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDataBucket(dataBucket: ModelsDataBucket, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsDataBucket>>> {
            const localVarAxiosArgs = await DataBucketApiAxiosParamCreator(configuration).createDataBucket(dataBucket, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes DataBucket
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDataBucket(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await DataBucketApiAxiosParamCreator(configuration).deleteDataBucket(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets DataBucket
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataBucket(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsDataBucket>>> {
            const localVarAxiosArgs = await DataBucketApiAxiosParamCreator(configuration).getDataBucket(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists DataBuckets
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDataBuckets(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsDataBucket>>> {
            const localVarAxiosArgs = await DataBucketApiAxiosParamCreator(configuration).listDataBuckets(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates DataBucket
         * @param {number} id Id
         * @param {ModelsDataBucket} dataBucket DataBucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDataBucket(id: number, dataBucket: ModelsDataBucket, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsDataBucket>>> {
            const localVarAxiosArgs = await DataBucketApiAxiosParamCreator(configuration).updateDataBucket(id, dataBucket, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DataBucketApi - factory interface
 * @export
 */
export const DataBucketApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates DataBucket
         * @param {ModelsDataBucket} dataBucket DataBucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataBucket(dataBucket: ModelsDataBucket, options?: any): AxiosPromise<Array<ModelsDataBucket>> {
            return DataBucketApiFp(configuration).createDataBucket(dataBucket, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes DataBucket
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDataBucket(id: number, options?: any): AxiosPromise<string> {
            return DataBucketApiFp(configuration).deleteDataBucket(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets DataBucket
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataBucket(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsDataBucket>> {
            return DataBucketApiFp(configuration).getDataBucket(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists DataBuckets
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDataBuckets(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsDataBucket>> {
            return DataBucketApiFp(configuration).listDataBuckets(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates DataBucket
         * @param {number} id Id
         * @param {ModelsDataBucket} dataBucket DataBucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDataBucket(id: number, dataBucket: ModelsDataBucket, options?: any): AxiosPromise<Array<ModelsDataBucket>> {
            return DataBucketApiFp(configuration).updateDataBucket(id, dataBucket, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createDataBucket operation in DataBucketApi.
 * @export
 * @interface DataBucketApiCreateDataBucketRequest
 */
export interface DataBucketApiCreateDataBucketRequest {
    /**
     * DataBucket
     * @type {ModelsDataBucket}
     * @memberof DataBucketApiCreateDataBucket
     */
    readonly dataBucket: ModelsDataBucket
}

/**
 * Request parameters for deleteDataBucket operation in DataBucketApi.
 * @export
 * @interface DataBucketApiDeleteDataBucketRequest
 */
export interface DataBucketApiDeleteDataBucketRequest {
    /**
     * Id
     * @type {number}
     * @memberof DataBucketApiDeleteDataBucket
     */
    readonly id: number
}

/**
 * Request parameters for getDataBucket operation in DataBucketApi.
 * @export
 * @interface DataBucketApiGetDataBucketRequest
 */
export interface DataBucketApiGetDataBucketRequest {
    /**
     * Id
     * @type {number}
     * @memberof DataBucketApiGetDataBucket
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof DataBucketApiGetDataBucket
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof DataBucketApiGetDataBucket
     */
    readonly select?: string
}

/**
 * Request parameters for listDataBuckets operation in DataBucketApi.
 * @export
 * @interface DataBucketApiListDataBucketsRequest
 */
export interface DataBucketApiListDataBucketsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof DataBucketApiListDataBuckets
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof DataBucketApiListDataBuckets
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof DataBucketApiListDataBuckets
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof DataBucketApiListDataBuckets
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof DataBucketApiListDataBuckets
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof DataBucketApiListDataBuckets
     */
    readonly select?: string
}

/**
 * Request parameters for updateDataBucket operation in DataBucketApi.
 * @export
 * @interface DataBucketApiUpdateDataBucketRequest
 */
export interface DataBucketApiUpdateDataBucketRequest {
    /**
     * Id
     * @type {number}
     * @memberof DataBucketApiUpdateDataBucket
     */
    readonly id: number

    /**
     * DataBucket
     * @type {ModelsDataBucket}
     * @memberof DataBucketApiUpdateDataBucket
     */
    readonly dataBucket: ModelsDataBucket
}

/**
 * DataBucketApi - object-oriented interface
 * @export
 * @class DataBucketApi
 * @extends {BaseAPI}
 */
export class DataBucketApi extends BaseAPI {
    /**
     * 
     * @summary Creates DataBucket
     * @param {DataBucketApiCreateDataBucketRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataBucketApi
     */
    public createDataBucket(requestParameters: DataBucketApiCreateDataBucketRequest, options?: any) {
        return DataBucketApiFp(this.configuration).createDataBucket(requestParameters.dataBucket, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes DataBucket
     * @param {DataBucketApiDeleteDataBucketRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataBucketApi
     */
    public deleteDataBucket(requestParameters: DataBucketApiDeleteDataBucketRequest, options?: any) {
        return DataBucketApiFp(this.configuration).deleteDataBucket(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets DataBucket
     * @param {DataBucketApiGetDataBucketRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataBucketApi
     */
    public getDataBucket(requestParameters: DataBucketApiGetDataBucketRequest, options?: any) {
        return DataBucketApiFp(this.configuration).getDataBucket(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists DataBuckets
     * @param {DataBucketApiListDataBucketsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataBucketApi
     */
    public listDataBuckets(requestParameters: DataBucketApiListDataBucketsRequest = {}, options?: any) {
        return DataBucketApiFp(this.configuration).listDataBuckets(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates DataBucket
     * @param {DataBucketApiUpdateDataBucketRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataBucketApi
     */
    public updateDataBucket(requestParameters: DataBucketApiUpdateDataBucketRequest, options?: any) {
        return DataBucketApiFp(this.configuration).updateDataBucket(requestParameters.id, requestParameters.dataBucket, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DbStrApi - axios parameter creator
 * @export
 */
export const DbStrApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates DbStr
         * @param {ModelsDbStr} dbStr DbStr
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDbStr: async (dbStr: ModelsDbStr, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbStr' is not null or undefined
            if (dbStr === null || dbStr === undefined) {
                throw new RequiredError('dbStr','Required parameter dbStr was null or undefined when calling createDbStr.');
            }
            const localVarPath = `/db_str`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof dbStr !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(dbStr !== undefined ? dbStr : {})
                : (dbStr || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes DbStr
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDbStr: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteDbStr.');
            }
            const localVarPath = `/db_str/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets DbStr
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDbStr: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDbStr.');
            }
            const localVarPath = `/db_str/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists DbStrs
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDbStrs: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/db_strs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates DbStr
         * @param {number} id Id
         * @param {ModelsDbStr} dbStr DbStr
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDbStr: async (id: number, dbStr: ModelsDbStr, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateDbStr.');
            }
            // verify required parameter 'dbStr' is not null or undefined
            if (dbStr === null || dbStr === undefined) {
                throw new RequiredError('dbStr','Required parameter dbStr was null or undefined when calling updateDbStr.');
            }
            const localVarPath = `/db_str/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof dbStr !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(dbStr !== undefined ? dbStr : {})
                : (dbStr || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DbStrApi - functional programming interface
 * @export
 */
export const DbStrApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates DbStr
         * @param {ModelsDbStr} dbStr DbStr
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDbStr(dbStr: ModelsDbStr, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsDbStr>>> {
            const localVarAxiosArgs = await DbStrApiAxiosParamCreator(configuration).createDbStr(dbStr, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes DbStr
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDbStr(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await DbStrApiAxiosParamCreator(configuration).deleteDbStr(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets DbStr
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDbStr(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsDbStr>>> {
            const localVarAxiosArgs = await DbStrApiAxiosParamCreator(configuration).getDbStr(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists DbStrs
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDbStrs(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsDbStr>>> {
            const localVarAxiosArgs = await DbStrApiAxiosParamCreator(configuration).listDbStrs(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates DbStr
         * @param {number} id Id
         * @param {ModelsDbStr} dbStr DbStr
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDbStr(id: number, dbStr: ModelsDbStr, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsDbStr>>> {
            const localVarAxiosArgs = await DbStrApiAxiosParamCreator(configuration).updateDbStr(id, dbStr, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DbStrApi - factory interface
 * @export
 */
export const DbStrApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates DbStr
         * @param {ModelsDbStr} dbStr DbStr
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDbStr(dbStr: ModelsDbStr, options?: any): AxiosPromise<Array<ModelsDbStr>> {
            return DbStrApiFp(configuration).createDbStr(dbStr, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes DbStr
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDbStr(id: number, options?: any): AxiosPromise<string> {
            return DbStrApiFp(configuration).deleteDbStr(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets DbStr
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDbStr(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsDbStr>> {
            return DbStrApiFp(configuration).getDbStr(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists DbStrs
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDbStrs(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsDbStr>> {
            return DbStrApiFp(configuration).listDbStrs(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates DbStr
         * @param {number} id Id
         * @param {ModelsDbStr} dbStr DbStr
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDbStr(id: number, dbStr: ModelsDbStr, options?: any): AxiosPromise<Array<ModelsDbStr>> {
            return DbStrApiFp(configuration).updateDbStr(id, dbStr, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createDbStr operation in DbStrApi.
 * @export
 * @interface DbStrApiCreateDbStrRequest
 */
export interface DbStrApiCreateDbStrRequest {
    /**
     * DbStr
     * @type {ModelsDbStr}
     * @memberof DbStrApiCreateDbStr
     */
    readonly dbStr: ModelsDbStr
}

/**
 * Request parameters for deleteDbStr operation in DbStrApi.
 * @export
 * @interface DbStrApiDeleteDbStrRequest
 */
export interface DbStrApiDeleteDbStrRequest {
    /**
     * Id
     * @type {number}
     * @memberof DbStrApiDeleteDbStr
     */
    readonly id: number
}

/**
 * Request parameters for getDbStr operation in DbStrApi.
 * @export
 * @interface DbStrApiGetDbStrRequest
 */
export interface DbStrApiGetDbStrRequest {
    /**
     * Id
     * @type {number}
     * @memberof DbStrApiGetDbStr
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof DbStrApiGetDbStr
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof DbStrApiGetDbStr
     */
    readonly select?: string
}

/**
 * Request parameters for listDbStrs operation in DbStrApi.
 * @export
 * @interface DbStrApiListDbStrsRequest
 */
export interface DbStrApiListDbStrsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof DbStrApiListDbStrs
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof DbStrApiListDbStrs
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof DbStrApiListDbStrs
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof DbStrApiListDbStrs
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof DbStrApiListDbStrs
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof DbStrApiListDbStrs
     */
    readonly select?: string
}

/**
 * Request parameters for updateDbStr operation in DbStrApi.
 * @export
 * @interface DbStrApiUpdateDbStrRequest
 */
export interface DbStrApiUpdateDbStrRequest {
    /**
     * Id
     * @type {number}
     * @memberof DbStrApiUpdateDbStr
     */
    readonly id: number

    /**
     * DbStr
     * @type {ModelsDbStr}
     * @memberof DbStrApiUpdateDbStr
     */
    readonly dbStr: ModelsDbStr
}

/**
 * DbStrApi - object-oriented interface
 * @export
 * @class DbStrApi
 * @extends {BaseAPI}
 */
export class DbStrApi extends BaseAPI {
    /**
     * 
     * @summary Creates DbStr
     * @param {DbStrApiCreateDbStrRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DbStrApi
     */
    public createDbStr(requestParameters: DbStrApiCreateDbStrRequest, options?: any) {
        return DbStrApiFp(this.configuration).createDbStr(requestParameters.dbStr, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes DbStr
     * @param {DbStrApiDeleteDbStrRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DbStrApi
     */
    public deleteDbStr(requestParameters: DbStrApiDeleteDbStrRequest, options?: any) {
        return DbStrApiFp(this.configuration).deleteDbStr(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets DbStr
     * @param {DbStrApiGetDbStrRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DbStrApi
     */
    public getDbStr(requestParameters: DbStrApiGetDbStrRequest, options?: any) {
        return DbStrApiFp(this.configuration).getDbStr(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists DbStrs
     * @param {DbStrApiListDbStrsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DbStrApi
     */
    public listDbStrs(requestParameters: DbStrApiListDbStrsRequest = {}, options?: any) {
        return DbStrApiFp(this.configuration).listDbStrs(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates DbStr
     * @param {DbStrApiUpdateDbStrRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DbStrApi
     */
    public updateDbStr(requestParameters: DbStrApiUpdateDbStrRequest, options?: any) {
        return DbStrApiFp(this.configuration).updateDbStr(requestParameters.id, requestParameters.dbStr, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DoorApi - axios parameter creator
 * @export
 */
export const DoorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Door
         * @param {ModelsDoor} door Door
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDoor: async (door: ModelsDoor, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'door' is not null or undefined
            if (door === null || door === undefined) {
                throw new RequiredError('door','Required parameter door was null or undefined when calling createDoor.');
            }
            const localVarPath = `/door`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof door !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(door !== undefined ? door : {})
                : (door || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes Door
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDoor: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteDoor.');
            }
            const localVarPath = `/door/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Door
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDoor: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDoor.');
            }
            const localVarPath = `/door/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists Doors
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDoors: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/doors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates Door
         * @param {number} id Id
         * @param {ModelsDoor} door Door
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDoor: async (id: number, door: ModelsDoor, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateDoor.');
            }
            // verify required parameter 'door' is not null or undefined
            if (door === null || door === undefined) {
                throw new RequiredError('door','Required parameter door was null or undefined when calling updateDoor.');
            }
            const localVarPath = `/door/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof door !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(door !== undefined ? door : {})
                : (door || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DoorApi - functional programming interface
 * @export
 */
export const DoorApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Door
         * @param {ModelsDoor} door Door
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDoor(door: ModelsDoor, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsDoor>>> {
            const localVarAxiosArgs = await DoorApiAxiosParamCreator(configuration).createDoor(door, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes Door
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDoor(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await DoorApiAxiosParamCreator(configuration).deleteDoor(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Door
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDoor(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsDoor>>> {
            const localVarAxiosArgs = await DoorApiAxiosParamCreator(configuration).getDoor(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists Doors
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDoors(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsDoor>>> {
            const localVarAxiosArgs = await DoorApiAxiosParamCreator(configuration).listDoors(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates Door
         * @param {number} id Id
         * @param {ModelsDoor} door Door
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDoor(id: number, door: ModelsDoor, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsDoor>>> {
            const localVarAxiosArgs = await DoorApiAxiosParamCreator(configuration).updateDoor(id, door, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DoorApi - factory interface
 * @export
 */
export const DoorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates Door
         * @param {ModelsDoor} door Door
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDoor(door: ModelsDoor, options?: any): AxiosPromise<Array<ModelsDoor>> {
            return DoorApiFp(configuration).createDoor(door, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes Door
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDoor(id: number, options?: any): AxiosPromise<string> {
            return DoorApiFp(configuration).deleteDoor(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Door
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDoor(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsDoor>> {
            return DoorApiFp(configuration).getDoor(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists Doors
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDoors(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsDoor>> {
            return DoorApiFp(configuration).listDoors(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates Door
         * @param {number} id Id
         * @param {ModelsDoor} door Door
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDoor(id: number, door: ModelsDoor, options?: any): AxiosPromise<Array<ModelsDoor>> {
            return DoorApiFp(configuration).updateDoor(id, door, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createDoor operation in DoorApi.
 * @export
 * @interface DoorApiCreateDoorRequest
 */
export interface DoorApiCreateDoorRequest {
    /**
     * Door
     * @type {ModelsDoor}
     * @memberof DoorApiCreateDoor
     */
    readonly door: ModelsDoor
}

/**
 * Request parameters for deleteDoor operation in DoorApi.
 * @export
 * @interface DoorApiDeleteDoorRequest
 */
export interface DoorApiDeleteDoorRequest {
    /**
     * Id
     * @type {number}
     * @memberof DoorApiDeleteDoor
     */
    readonly id: number
}

/**
 * Request parameters for getDoor operation in DoorApi.
 * @export
 * @interface DoorApiGetDoorRequest
 */
export interface DoorApiGetDoorRequest {
    /**
     * Id
     * @type {number}
     * @memberof DoorApiGetDoor
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof DoorApiGetDoor
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof DoorApiGetDoor
     */
    readonly select?: string
}

/**
 * Request parameters for listDoors operation in DoorApi.
 * @export
 * @interface DoorApiListDoorsRequest
 */
export interface DoorApiListDoorsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof DoorApiListDoors
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof DoorApiListDoors
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof DoorApiListDoors
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof DoorApiListDoors
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof DoorApiListDoors
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof DoorApiListDoors
     */
    readonly select?: string
}

/**
 * Request parameters for updateDoor operation in DoorApi.
 * @export
 * @interface DoorApiUpdateDoorRequest
 */
export interface DoorApiUpdateDoorRequest {
    /**
     * Id
     * @type {number}
     * @memberof DoorApiUpdateDoor
     */
    readonly id: number

    /**
     * Door
     * @type {ModelsDoor}
     * @memberof DoorApiUpdateDoor
     */
    readonly door: ModelsDoor
}

/**
 * DoorApi - object-oriented interface
 * @export
 * @class DoorApi
 * @extends {BaseAPI}
 */
export class DoorApi extends BaseAPI {
    /**
     * 
     * @summary Creates Door
     * @param {DoorApiCreateDoorRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DoorApi
     */
    public createDoor(requestParameters: DoorApiCreateDoorRequest, options?: any) {
        return DoorApiFp(this.configuration).createDoor(requestParameters.door, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes Door
     * @param {DoorApiDeleteDoorRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DoorApi
     */
    public deleteDoor(requestParameters: DoorApiDeleteDoorRequest, options?: any) {
        return DoorApiFp(this.configuration).deleteDoor(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Door
     * @param {DoorApiGetDoorRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DoorApi
     */
    public getDoor(requestParameters: DoorApiGetDoorRequest, options?: any) {
        return DoorApiFp(this.configuration).getDoor(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists Doors
     * @param {DoorApiListDoorsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DoorApi
     */
    public listDoors(requestParameters: DoorApiListDoorsRequest = {}, options?: any) {
        return DoorApiFp(this.configuration).listDoors(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates Door
     * @param {DoorApiUpdateDoorRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DoorApi
     */
    public updateDoor(requestParameters: DoorApiUpdateDoorRequest, options?: any) {
        return DoorApiFp(this.configuration).updateDoor(requestParameters.id, requestParameters.door, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventlogApi - axios parameter creator
 * @export
 */
export const EventlogApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Eventlog
         * @param {ModelsEventlog} eventlog Eventlog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventlog: async (eventlog: ModelsEventlog, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventlog' is not null or undefined
            if (eventlog === null || eventlog === undefined) {
                throw new RequiredError('eventlog','Required parameter eventlog was null or undefined when calling createEventlog.');
            }
            const localVarPath = `/eventlog`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof eventlog !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(eventlog !== undefined ? eventlog : {})
                : (eventlog || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes Eventlog
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventlog: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteEventlog.');
            }
            const localVarPath = `/eventlog/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Eventlog
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventlog: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getEventlog.');
            }
            const localVarPath = `/eventlog/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists Eventlogs
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventlogs: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/eventlogs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates Eventlog
         * @param {number} id Id
         * @param {ModelsEventlog} eventlog Eventlog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventlog: async (id: number, eventlog: ModelsEventlog, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateEventlog.');
            }
            // verify required parameter 'eventlog' is not null or undefined
            if (eventlog === null || eventlog === undefined) {
                throw new RequiredError('eventlog','Required parameter eventlog was null or undefined when calling updateEventlog.');
            }
            const localVarPath = `/eventlog/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof eventlog !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(eventlog !== undefined ? eventlog : {})
                : (eventlog || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventlogApi - functional programming interface
 * @export
 */
export const EventlogApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Eventlog
         * @param {ModelsEventlog} eventlog Eventlog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEventlog(eventlog: ModelsEventlog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsEventlog>>> {
            const localVarAxiosArgs = await EventlogApiAxiosParamCreator(configuration).createEventlog(eventlog, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes Eventlog
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEventlog(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await EventlogApiAxiosParamCreator(configuration).deleteEventlog(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Eventlog
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventlog(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsEventlog>>> {
            const localVarAxiosArgs = await EventlogApiAxiosParamCreator(configuration).getEventlog(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists Eventlogs
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEventlogs(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsEventlog>>> {
            const localVarAxiosArgs = await EventlogApiAxiosParamCreator(configuration).listEventlogs(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates Eventlog
         * @param {number} id Id
         * @param {ModelsEventlog} eventlog Eventlog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEventlog(id: number, eventlog: ModelsEventlog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsEventlog>>> {
            const localVarAxiosArgs = await EventlogApiAxiosParamCreator(configuration).updateEventlog(id, eventlog, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * EventlogApi - factory interface
 * @export
 */
export const EventlogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates Eventlog
         * @param {ModelsEventlog} eventlog Eventlog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventlog(eventlog: ModelsEventlog, options?: any): AxiosPromise<Array<ModelsEventlog>> {
            return EventlogApiFp(configuration).createEventlog(eventlog, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes Eventlog
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventlog(id: number, options?: any): AxiosPromise<string> {
            return EventlogApiFp(configuration).deleteEventlog(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Eventlog
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventlog(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsEventlog>> {
            return EventlogApiFp(configuration).getEventlog(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists Eventlogs
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventlogs(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsEventlog>> {
            return EventlogApiFp(configuration).listEventlogs(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates Eventlog
         * @param {number} id Id
         * @param {ModelsEventlog} eventlog Eventlog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventlog(id: number, eventlog: ModelsEventlog, options?: any): AxiosPromise<Array<ModelsEventlog>> {
            return EventlogApiFp(configuration).updateEventlog(id, eventlog, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createEventlog operation in EventlogApi.
 * @export
 * @interface EventlogApiCreateEventlogRequest
 */
export interface EventlogApiCreateEventlogRequest {
    /**
     * Eventlog
     * @type {ModelsEventlog}
     * @memberof EventlogApiCreateEventlog
     */
    readonly eventlog: ModelsEventlog
}

/**
 * Request parameters for deleteEventlog operation in EventlogApi.
 * @export
 * @interface EventlogApiDeleteEventlogRequest
 */
export interface EventlogApiDeleteEventlogRequest {
    /**
     * Id
     * @type {number}
     * @memberof EventlogApiDeleteEventlog
     */
    readonly id: number
}

/**
 * Request parameters for getEventlog operation in EventlogApi.
 * @export
 * @interface EventlogApiGetEventlogRequest
 */
export interface EventlogApiGetEventlogRequest {
    /**
     * Id
     * @type {number}
     * @memberof EventlogApiGetEventlog
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof EventlogApiGetEventlog
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof EventlogApiGetEventlog
     */
    readonly select?: string
}

/**
 * Request parameters for listEventlogs operation in EventlogApi.
 * @export
 * @interface EventlogApiListEventlogsRequest
 */
export interface EventlogApiListEventlogsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof EventlogApiListEventlogs
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof EventlogApiListEventlogs
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof EventlogApiListEventlogs
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof EventlogApiListEventlogs
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof EventlogApiListEventlogs
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof EventlogApiListEventlogs
     */
    readonly select?: string
}

/**
 * Request parameters for updateEventlog operation in EventlogApi.
 * @export
 * @interface EventlogApiUpdateEventlogRequest
 */
export interface EventlogApiUpdateEventlogRequest {
    /**
     * Id
     * @type {number}
     * @memberof EventlogApiUpdateEventlog
     */
    readonly id: number

    /**
     * Eventlog
     * @type {ModelsEventlog}
     * @memberof EventlogApiUpdateEventlog
     */
    readonly eventlog: ModelsEventlog
}

/**
 * EventlogApi - object-oriented interface
 * @export
 * @class EventlogApi
 * @extends {BaseAPI}
 */
export class EventlogApi extends BaseAPI {
    /**
     * 
     * @summary Creates Eventlog
     * @param {EventlogApiCreateEventlogRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventlogApi
     */
    public createEventlog(requestParameters: EventlogApiCreateEventlogRequest, options?: any) {
        return EventlogApiFp(this.configuration).createEventlog(requestParameters.eventlog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes Eventlog
     * @param {EventlogApiDeleteEventlogRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventlogApi
     */
    public deleteEventlog(requestParameters: EventlogApiDeleteEventlogRequest, options?: any) {
        return EventlogApiFp(this.configuration).deleteEventlog(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Eventlog
     * @param {EventlogApiGetEventlogRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventlogApi
     */
    public getEventlog(requestParameters: EventlogApiGetEventlogRequest, options?: any) {
        return EventlogApiFp(this.configuration).getEventlog(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists Eventlogs
     * @param {EventlogApiListEventlogsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventlogApi
     */
    public listEventlogs(requestParameters: EventlogApiListEventlogsRequest = {}, options?: any) {
        return EventlogApiFp(this.configuration).listEventlogs(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates Eventlog
     * @param {EventlogApiUpdateEventlogRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventlogApi
     */
    public updateEventlog(requestParameters: EventlogApiUpdateEventlogRequest, options?: any) {
        return EventlogApiFp(this.configuration).updateEventlog(requestParameters.id, requestParameters.eventlog, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FactionBaseDatumApi - axios parameter creator
 * @export
 */
export const FactionBaseDatumApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates FactionBaseDatum
         * @param {ModelsFactionBaseDatum} factionBaseDatum FactionBaseDatum
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFactionBaseDatum: async (factionBaseDatum: ModelsFactionBaseDatum, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'factionBaseDatum' is not null or undefined
            if (factionBaseDatum === null || factionBaseDatum === undefined) {
                throw new RequiredError('factionBaseDatum','Required parameter factionBaseDatum was null or undefined when calling createFactionBaseDatum.');
            }
            const localVarPath = `/faction_base_datum`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof factionBaseDatum !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(factionBaseDatum !== undefined ? factionBaseDatum : {})
                : (factionBaseDatum || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes FactionBaseDatum
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFactionBaseDatum: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteFactionBaseDatum.');
            }
            const localVarPath = `/faction_base_datum/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets FactionBaseDatum
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFactionBaseDatum: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getFactionBaseDatum.');
            }
            const localVarPath = `/faction_base_datum/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists FactionBaseData
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFactionBaseData: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/faction_base_data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates FactionBaseDatum
         * @param {number} id Id
         * @param {ModelsFactionBaseDatum} factionBaseDatum FactionBaseDatum
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFactionBaseDatum: async (id: number, factionBaseDatum: ModelsFactionBaseDatum, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateFactionBaseDatum.');
            }
            // verify required parameter 'factionBaseDatum' is not null or undefined
            if (factionBaseDatum === null || factionBaseDatum === undefined) {
                throw new RequiredError('factionBaseDatum','Required parameter factionBaseDatum was null or undefined when calling updateFactionBaseDatum.');
            }
            const localVarPath = `/faction_base_datum/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof factionBaseDatum !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(factionBaseDatum !== undefined ? factionBaseDatum : {})
                : (factionBaseDatum || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FactionBaseDatumApi - functional programming interface
 * @export
 */
export const FactionBaseDatumApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates FactionBaseDatum
         * @param {ModelsFactionBaseDatum} factionBaseDatum FactionBaseDatum
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFactionBaseDatum(factionBaseDatum: ModelsFactionBaseDatum, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsFactionBaseDatum>>> {
            const localVarAxiosArgs = await FactionBaseDatumApiAxiosParamCreator(configuration).createFactionBaseDatum(factionBaseDatum, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes FactionBaseDatum
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFactionBaseDatum(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await FactionBaseDatumApiAxiosParamCreator(configuration).deleteFactionBaseDatum(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets FactionBaseDatum
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFactionBaseDatum(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsFactionBaseDatum>>> {
            const localVarAxiosArgs = await FactionBaseDatumApiAxiosParamCreator(configuration).getFactionBaseDatum(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists FactionBaseData
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFactionBaseData(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsFactionBaseDatum>>> {
            const localVarAxiosArgs = await FactionBaseDatumApiAxiosParamCreator(configuration).listFactionBaseData(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates FactionBaseDatum
         * @param {number} id Id
         * @param {ModelsFactionBaseDatum} factionBaseDatum FactionBaseDatum
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFactionBaseDatum(id: number, factionBaseDatum: ModelsFactionBaseDatum, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsFactionBaseDatum>>> {
            const localVarAxiosArgs = await FactionBaseDatumApiAxiosParamCreator(configuration).updateFactionBaseDatum(id, factionBaseDatum, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * FactionBaseDatumApi - factory interface
 * @export
 */
export const FactionBaseDatumApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates FactionBaseDatum
         * @param {ModelsFactionBaseDatum} factionBaseDatum FactionBaseDatum
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFactionBaseDatum(factionBaseDatum: ModelsFactionBaseDatum, options?: any): AxiosPromise<Array<ModelsFactionBaseDatum>> {
            return FactionBaseDatumApiFp(configuration).createFactionBaseDatum(factionBaseDatum, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes FactionBaseDatum
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFactionBaseDatum(id: number, options?: any): AxiosPromise<string> {
            return FactionBaseDatumApiFp(configuration).deleteFactionBaseDatum(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets FactionBaseDatum
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFactionBaseDatum(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsFactionBaseDatum>> {
            return FactionBaseDatumApiFp(configuration).getFactionBaseDatum(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists FactionBaseData
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFactionBaseData(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsFactionBaseDatum>> {
            return FactionBaseDatumApiFp(configuration).listFactionBaseData(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates FactionBaseDatum
         * @param {number} id Id
         * @param {ModelsFactionBaseDatum} factionBaseDatum FactionBaseDatum
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFactionBaseDatum(id: number, factionBaseDatum: ModelsFactionBaseDatum, options?: any): AxiosPromise<Array<ModelsFactionBaseDatum>> {
            return FactionBaseDatumApiFp(configuration).updateFactionBaseDatum(id, factionBaseDatum, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createFactionBaseDatum operation in FactionBaseDatumApi.
 * @export
 * @interface FactionBaseDatumApiCreateFactionBaseDatumRequest
 */
export interface FactionBaseDatumApiCreateFactionBaseDatumRequest {
    /**
     * FactionBaseDatum
     * @type {ModelsFactionBaseDatum}
     * @memberof FactionBaseDatumApiCreateFactionBaseDatum
     */
    readonly factionBaseDatum: ModelsFactionBaseDatum
}

/**
 * Request parameters for deleteFactionBaseDatum operation in FactionBaseDatumApi.
 * @export
 * @interface FactionBaseDatumApiDeleteFactionBaseDatumRequest
 */
export interface FactionBaseDatumApiDeleteFactionBaseDatumRequest {
    /**
     * Id
     * @type {number}
     * @memberof FactionBaseDatumApiDeleteFactionBaseDatum
     */
    readonly id: number
}

/**
 * Request parameters for getFactionBaseDatum operation in FactionBaseDatumApi.
 * @export
 * @interface FactionBaseDatumApiGetFactionBaseDatumRequest
 */
export interface FactionBaseDatumApiGetFactionBaseDatumRequest {
    /**
     * Id
     * @type {number}
     * @memberof FactionBaseDatumApiGetFactionBaseDatum
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof FactionBaseDatumApiGetFactionBaseDatum
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof FactionBaseDatumApiGetFactionBaseDatum
     */
    readonly select?: string
}

/**
 * Request parameters for listFactionBaseData operation in FactionBaseDatumApi.
 * @export
 * @interface FactionBaseDatumApiListFactionBaseDataRequest
 */
export interface FactionBaseDatumApiListFactionBaseDataRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof FactionBaseDatumApiListFactionBaseData
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof FactionBaseDatumApiListFactionBaseData
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof FactionBaseDatumApiListFactionBaseData
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof FactionBaseDatumApiListFactionBaseData
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof FactionBaseDatumApiListFactionBaseData
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof FactionBaseDatumApiListFactionBaseData
     */
    readonly select?: string
}

/**
 * Request parameters for updateFactionBaseDatum operation in FactionBaseDatumApi.
 * @export
 * @interface FactionBaseDatumApiUpdateFactionBaseDatumRequest
 */
export interface FactionBaseDatumApiUpdateFactionBaseDatumRequest {
    /**
     * Id
     * @type {number}
     * @memberof FactionBaseDatumApiUpdateFactionBaseDatum
     */
    readonly id: number

    /**
     * FactionBaseDatum
     * @type {ModelsFactionBaseDatum}
     * @memberof FactionBaseDatumApiUpdateFactionBaseDatum
     */
    readonly factionBaseDatum: ModelsFactionBaseDatum
}

/**
 * FactionBaseDatumApi - object-oriented interface
 * @export
 * @class FactionBaseDatumApi
 * @extends {BaseAPI}
 */
export class FactionBaseDatumApi extends BaseAPI {
    /**
     * 
     * @summary Creates FactionBaseDatum
     * @param {FactionBaseDatumApiCreateFactionBaseDatumRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactionBaseDatumApi
     */
    public createFactionBaseDatum(requestParameters: FactionBaseDatumApiCreateFactionBaseDatumRequest, options?: any) {
        return FactionBaseDatumApiFp(this.configuration).createFactionBaseDatum(requestParameters.factionBaseDatum, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes FactionBaseDatum
     * @param {FactionBaseDatumApiDeleteFactionBaseDatumRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactionBaseDatumApi
     */
    public deleteFactionBaseDatum(requestParameters: FactionBaseDatumApiDeleteFactionBaseDatumRequest, options?: any) {
        return FactionBaseDatumApiFp(this.configuration).deleteFactionBaseDatum(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets FactionBaseDatum
     * @param {FactionBaseDatumApiGetFactionBaseDatumRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactionBaseDatumApi
     */
    public getFactionBaseDatum(requestParameters: FactionBaseDatumApiGetFactionBaseDatumRequest, options?: any) {
        return FactionBaseDatumApiFp(this.configuration).getFactionBaseDatum(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists FactionBaseData
     * @param {FactionBaseDatumApiListFactionBaseDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactionBaseDatumApi
     */
    public listFactionBaseData(requestParameters: FactionBaseDatumApiListFactionBaseDataRequest = {}, options?: any) {
        return FactionBaseDatumApiFp(this.configuration).listFactionBaseData(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates FactionBaseDatum
     * @param {FactionBaseDatumApiUpdateFactionBaseDatumRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactionBaseDatumApi
     */
    public updateFactionBaseDatum(requestParameters: FactionBaseDatumApiUpdateFactionBaseDatumRequest, options?: any) {
        return FactionBaseDatumApiFp(this.configuration).updateFactionBaseDatum(requestParameters.id, requestParameters.factionBaseDatum, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FactionListApi - axios parameter creator
 * @export
 */
export const FactionListApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates FactionList
         * @param {ModelsFactionList} factionList FactionList
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFactionList: async (factionList: ModelsFactionList, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'factionList' is not null or undefined
            if (factionList === null || factionList === undefined) {
                throw new RequiredError('factionList','Required parameter factionList was null or undefined when calling createFactionList.');
            }
            const localVarPath = `/faction_list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof factionList !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(factionList !== undefined ? factionList : {})
                : (factionList || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes FactionList
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFactionList: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteFactionList.');
            }
            const localVarPath = `/faction_list/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets FactionList
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFactionList: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getFactionList.');
            }
            const localVarPath = `/faction_list/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists FactionLists
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFactionLists: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/faction_lists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates FactionList
         * @param {number} id Id
         * @param {ModelsFactionList} factionList FactionList
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFactionList: async (id: number, factionList: ModelsFactionList, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateFactionList.');
            }
            // verify required parameter 'factionList' is not null or undefined
            if (factionList === null || factionList === undefined) {
                throw new RequiredError('factionList','Required parameter factionList was null or undefined when calling updateFactionList.');
            }
            const localVarPath = `/faction_list/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof factionList !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(factionList !== undefined ? factionList : {})
                : (factionList || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FactionListApi - functional programming interface
 * @export
 */
export const FactionListApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates FactionList
         * @param {ModelsFactionList} factionList FactionList
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFactionList(factionList: ModelsFactionList, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsFactionList>>> {
            const localVarAxiosArgs = await FactionListApiAxiosParamCreator(configuration).createFactionList(factionList, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes FactionList
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFactionList(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await FactionListApiAxiosParamCreator(configuration).deleteFactionList(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets FactionList
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFactionList(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsFactionList>>> {
            const localVarAxiosArgs = await FactionListApiAxiosParamCreator(configuration).getFactionList(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists FactionLists
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFactionLists(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsFactionList>>> {
            const localVarAxiosArgs = await FactionListApiAxiosParamCreator(configuration).listFactionLists(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates FactionList
         * @param {number} id Id
         * @param {ModelsFactionList} factionList FactionList
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFactionList(id: number, factionList: ModelsFactionList, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsFactionList>>> {
            const localVarAxiosArgs = await FactionListApiAxiosParamCreator(configuration).updateFactionList(id, factionList, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * FactionListApi - factory interface
 * @export
 */
export const FactionListApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates FactionList
         * @param {ModelsFactionList} factionList FactionList
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFactionList(factionList: ModelsFactionList, options?: any): AxiosPromise<Array<ModelsFactionList>> {
            return FactionListApiFp(configuration).createFactionList(factionList, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes FactionList
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFactionList(id: number, options?: any): AxiosPromise<string> {
            return FactionListApiFp(configuration).deleteFactionList(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets FactionList
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFactionList(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsFactionList>> {
            return FactionListApiFp(configuration).getFactionList(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists FactionLists
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFactionLists(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsFactionList>> {
            return FactionListApiFp(configuration).listFactionLists(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates FactionList
         * @param {number} id Id
         * @param {ModelsFactionList} factionList FactionList
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFactionList(id: number, factionList: ModelsFactionList, options?: any): AxiosPromise<Array<ModelsFactionList>> {
            return FactionListApiFp(configuration).updateFactionList(id, factionList, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createFactionList operation in FactionListApi.
 * @export
 * @interface FactionListApiCreateFactionListRequest
 */
export interface FactionListApiCreateFactionListRequest {
    /**
     * FactionList
     * @type {ModelsFactionList}
     * @memberof FactionListApiCreateFactionList
     */
    readonly factionList: ModelsFactionList
}

/**
 * Request parameters for deleteFactionList operation in FactionListApi.
 * @export
 * @interface FactionListApiDeleteFactionListRequest
 */
export interface FactionListApiDeleteFactionListRequest {
    /**
     * Id
     * @type {number}
     * @memberof FactionListApiDeleteFactionList
     */
    readonly id: number
}

/**
 * Request parameters for getFactionList operation in FactionListApi.
 * @export
 * @interface FactionListApiGetFactionListRequest
 */
export interface FactionListApiGetFactionListRequest {
    /**
     * Id
     * @type {number}
     * @memberof FactionListApiGetFactionList
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof FactionListApiGetFactionList
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof FactionListApiGetFactionList
     */
    readonly select?: string
}

/**
 * Request parameters for listFactionLists operation in FactionListApi.
 * @export
 * @interface FactionListApiListFactionListsRequest
 */
export interface FactionListApiListFactionListsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof FactionListApiListFactionLists
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof FactionListApiListFactionLists
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof FactionListApiListFactionLists
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof FactionListApiListFactionLists
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof FactionListApiListFactionLists
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof FactionListApiListFactionLists
     */
    readonly select?: string
}

/**
 * Request parameters for updateFactionList operation in FactionListApi.
 * @export
 * @interface FactionListApiUpdateFactionListRequest
 */
export interface FactionListApiUpdateFactionListRequest {
    /**
     * Id
     * @type {number}
     * @memberof FactionListApiUpdateFactionList
     */
    readonly id: number

    /**
     * FactionList
     * @type {ModelsFactionList}
     * @memberof FactionListApiUpdateFactionList
     */
    readonly factionList: ModelsFactionList
}

/**
 * FactionListApi - object-oriented interface
 * @export
 * @class FactionListApi
 * @extends {BaseAPI}
 */
export class FactionListApi extends BaseAPI {
    /**
     * 
     * @summary Creates FactionList
     * @param {FactionListApiCreateFactionListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactionListApi
     */
    public createFactionList(requestParameters: FactionListApiCreateFactionListRequest, options?: any) {
        return FactionListApiFp(this.configuration).createFactionList(requestParameters.factionList, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes FactionList
     * @param {FactionListApiDeleteFactionListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactionListApi
     */
    public deleteFactionList(requestParameters: FactionListApiDeleteFactionListRequest, options?: any) {
        return FactionListApiFp(this.configuration).deleteFactionList(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets FactionList
     * @param {FactionListApiGetFactionListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactionListApi
     */
    public getFactionList(requestParameters: FactionListApiGetFactionListRequest, options?: any) {
        return FactionListApiFp(this.configuration).getFactionList(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists FactionLists
     * @param {FactionListApiListFactionListsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactionListApi
     */
    public listFactionLists(requestParameters: FactionListApiListFactionListsRequest = {}, options?: any) {
        return FactionListApiFp(this.configuration).listFactionLists(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates FactionList
     * @param {FactionListApiUpdateFactionListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactionListApi
     */
    public updateFactionList(requestParameters: FactionListApiUpdateFactionListRequest, options?: any) {
        return FactionListApiFp(this.configuration).updateFactionList(requestParameters.id, requestParameters.factionList, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FactionListModApi - axios parameter creator
 * @export
 */
export const FactionListModApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates FactionListMod
         * @param {ModelsFactionListMod} factionListMod FactionListMod
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFactionListMod: async (factionListMod: ModelsFactionListMod, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'factionListMod' is not null or undefined
            if (factionListMod === null || factionListMod === undefined) {
                throw new RequiredError('factionListMod','Required parameter factionListMod was null or undefined when calling createFactionListMod.');
            }
            const localVarPath = `/faction_list_mod`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof factionListMod !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(factionListMod !== undefined ? factionListMod : {})
                : (factionListMod || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes FactionListMod
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFactionListMod: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteFactionListMod.');
            }
            const localVarPath = `/faction_list_mod/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets FactionListMod
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFactionListMod: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getFactionListMod.');
            }
            const localVarPath = `/faction_list_mod/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists FactionListMods
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFactionListMods: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/faction_list_mods`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates FactionListMod
         * @param {number} id Id
         * @param {ModelsFactionListMod} factionListMod FactionListMod
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFactionListMod: async (id: number, factionListMod: ModelsFactionListMod, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateFactionListMod.');
            }
            // verify required parameter 'factionListMod' is not null or undefined
            if (factionListMod === null || factionListMod === undefined) {
                throw new RequiredError('factionListMod','Required parameter factionListMod was null or undefined when calling updateFactionListMod.');
            }
            const localVarPath = `/faction_list_mod/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof factionListMod !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(factionListMod !== undefined ? factionListMod : {})
                : (factionListMod || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FactionListModApi - functional programming interface
 * @export
 */
export const FactionListModApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates FactionListMod
         * @param {ModelsFactionListMod} factionListMod FactionListMod
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFactionListMod(factionListMod: ModelsFactionListMod, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsFactionListMod>>> {
            const localVarAxiosArgs = await FactionListModApiAxiosParamCreator(configuration).createFactionListMod(factionListMod, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes FactionListMod
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFactionListMod(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await FactionListModApiAxiosParamCreator(configuration).deleteFactionListMod(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets FactionListMod
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFactionListMod(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsFactionListMod>>> {
            const localVarAxiosArgs = await FactionListModApiAxiosParamCreator(configuration).getFactionListMod(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists FactionListMods
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFactionListMods(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsFactionListMod>>> {
            const localVarAxiosArgs = await FactionListModApiAxiosParamCreator(configuration).listFactionListMods(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates FactionListMod
         * @param {number} id Id
         * @param {ModelsFactionListMod} factionListMod FactionListMod
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFactionListMod(id: number, factionListMod: ModelsFactionListMod, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsFactionListMod>>> {
            const localVarAxiosArgs = await FactionListModApiAxiosParamCreator(configuration).updateFactionListMod(id, factionListMod, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * FactionListModApi - factory interface
 * @export
 */
export const FactionListModApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates FactionListMod
         * @param {ModelsFactionListMod} factionListMod FactionListMod
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFactionListMod(factionListMod: ModelsFactionListMod, options?: any): AxiosPromise<Array<ModelsFactionListMod>> {
            return FactionListModApiFp(configuration).createFactionListMod(factionListMod, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes FactionListMod
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFactionListMod(id: number, options?: any): AxiosPromise<string> {
            return FactionListModApiFp(configuration).deleteFactionListMod(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets FactionListMod
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFactionListMod(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsFactionListMod>> {
            return FactionListModApiFp(configuration).getFactionListMod(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists FactionListMods
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFactionListMods(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsFactionListMod>> {
            return FactionListModApiFp(configuration).listFactionListMods(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates FactionListMod
         * @param {number} id Id
         * @param {ModelsFactionListMod} factionListMod FactionListMod
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFactionListMod(id: number, factionListMod: ModelsFactionListMod, options?: any): AxiosPromise<Array<ModelsFactionListMod>> {
            return FactionListModApiFp(configuration).updateFactionListMod(id, factionListMod, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createFactionListMod operation in FactionListModApi.
 * @export
 * @interface FactionListModApiCreateFactionListModRequest
 */
export interface FactionListModApiCreateFactionListModRequest {
    /**
     * FactionListMod
     * @type {ModelsFactionListMod}
     * @memberof FactionListModApiCreateFactionListMod
     */
    readonly factionListMod: ModelsFactionListMod
}

/**
 * Request parameters for deleteFactionListMod operation in FactionListModApi.
 * @export
 * @interface FactionListModApiDeleteFactionListModRequest
 */
export interface FactionListModApiDeleteFactionListModRequest {
    /**
     * Id
     * @type {number}
     * @memberof FactionListModApiDeleteFactionListMod
     */
    readonly id: number
}

/**
 * Request parameters for getFactionListMod operation in FactionListModApi.
 * @export
 * @interface FactionListModApiGetFactionListModRequest
 */
export interface FactionListModApiGetFactionListModRequest {
    /**
     * Id
     * @type {number}
     * @memberof FactionListModApiGetFactionListMod
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof FactionListModApiGetFactionListMod
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof FactionListModApiGetFactionListMod
     */
    readonly select?: string
}

/**
 * Request parameters for listFactionListMods operation in FactionListModApi.
 * @export
 * @interface FactionListModApiListFactionListModsRequest
 */
export interface FactionListModApiListFactionListModsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof FactionListModApiListFactionListMods
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof FactionListModApiListFactionListMods
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof FactionListModApiListFactionListMods
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof FactionListModApiListFactionListMods
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof FactionListModApiListFactionListMods
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof FactionListModApiListFactionListMods
     */
    readonly select?: string
}

/**
 * Request parameters for updateFactionListMod operation in FactionListModApi.
 * @export
 * @interface FactionListModApiUpdateFactionListModRequest
 */
export interface FactionListModApiUpdateFactionListModRequest {
    /**
     * Id
     * @type {number}
     * @memberof FactionListModApiUpdateFactionListMod
     */
    readonly id: number

    /**
     * FactionListMod
     * @type {ModelsFactionListMod}
     * @memberof FactionListModApiUpdateFactionListMod
     */
    readonly factionListMod: ModelsFactionListMod
}

/**
 * FactionListModApi - object-oriented interface
 * @export
 * @class FactionListModApi
 * @extends {BaseAPI}
 */
export class FactionListModApi extends BaseAPI {
    /**
     * 
     * @summary Creates FactionListMod
     * @param {FactionListModApiCreateFactionListModRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactionListModApi
     */
    public createFactionListMod(requestParameters: FactionListModApiCreateFactionListModRequest, options?: any) {
        return FactionListModApiFp(this.configuration).createFactionListMod(requestParameters.factionListMod, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes FactionListMod
     * @param {FactionListModApiDeleteFactionListModRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactionListModApi
     */
    public deleteFactionListMod(requestParameters: FactionListModApiDeleteFactionListModRequest, options?: any) {
        return FactionListModApiFp(this.configuration).deleteFactionListMod(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets FactionListMod
     * @param {FactionListModApiGetFactionListModRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactionListModApi
     */
    public getFactionListMod(requestParameters: FactionListModApiGetFactionListModRequest, options?: any) {
        return FactionListModApiFp(this.configuration).getFactionListMod(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists FactionListMods
     * @param {FactionListModApiListFactionListModsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactionListModApi
     */
    public listFactionListMods(requestParameters: FactionListModApiListFactionListModsRequest = {}, options?: any) {
        return FactionListModApiFp(this.configuration).listFactionListMods(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates FactionListMod
     * @param {FactionListModApiUpdateFactionListModRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactionListModApi
     */
    public updateFactionListMod(requestParameters: FactionListModApiUpdateFactionListModRequest, options?: any) {
        return FactionListModApiFp(this.configuration).updateFactionListMod(requestParameters.id, requestParameters.factionListMod, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FactionValueApi - axios parameter creator
 * @export
 */
export const FactionValueApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates FactionValue
         * @param {ModelsFactionValue} factionValue FactionValue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFactionValue: async (factionValue: ModelsFactionValue, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'factionValue' is not null or undefined
            if (factionValue === null || factionValue === undefined) {
                throw new RequiredError('factionValue','Required parameter factionValue was null or undefined when calling createFactionValue.');
            }
            const localVarPath = `/faction_value`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof factionValue !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(factionValue !== undefined ? factionValue : {})
                : (factionValue || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes FactionValue
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFactionValue: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteFactionValue.');
            }
            const localVarPath = `/faction_value/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets FactionValue
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFactionValue: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getFactionValue.');
            }
            const localVarPath = `/faction_value/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists FactionValues
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFactionValues: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/faction_values`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates FactionValue
         * @param {number} id Id
         * @param {ModelsFactionValue} factionValue FactionValue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFactionValue: async (id: number, factionValue: ModelsFactionValue, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateFactionValue.');
            }
            // verify required parameter 'factionValue' is not null or undefined
            if (factionValue === null || factionValue === undefined) {
                throw new RequiredError('factionValue','Required parameter factionValue was null or undefined when calling updateFactionValue.');
            }
            const localVarPath = `/faction_value/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof factionValue !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(factionValue !== undefined ? factionValue : {})
                : (factionValue || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FactionValueApi - functional programming interface
 * @export
 */
export const FactionValueApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates FactionValue
         * @param {ModelsFactionValue} factionValue FactionValue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFactionValue(factionValue: ModelsFactionValue, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsFactionValue>>> {
            const localVarAxiosArgs = await FactionValueApiAxiosParamCreator(configuration).createFactionValue(factionValue, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes FactionValue
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFactionValue(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await FactionValueApiAxiosParamCreator(configuration).deleteFactionValue(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets FactionValue
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFactionValue(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsFactionValue>>> {
            const localVarAxiosArgs = await FactionValueApiAxiosParamCreator(configuration).getFactionValue(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists FactionValues
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFactionValues(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsFactionValue>>> {
            const localVarAxiosArgs = await FactionValueApiAxiosParamCreator(configuration).listFactionValues(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates FactionValue
         * @param {number} id Id
         * @param {ModelsFactionValue} factionValue FactionValue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFactionValue(id: number, factionValue: ModelsFactionValue, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsFactionValue>>> {
            const localVarAxiosArgs = await FactionValueApiAxiosParamCreator(configuration).updateFactionValue(id, factionValue, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * FactionValueApi - factory interface
 * @export
 */
export const FactionValueApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates FactionValue
         * @param {ModelsFactionValue} factionValue FactionValue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFactionValue(factionValue: ModelsFactionValue, options?: any): AxiosPromise<Array<ModelsFactionValue>> {
            return FactionValueApiFp(configuration).createFactionValue(factionValue, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes FactionValue
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFactionValue(id: number, options?: any): AxiosPromise<string> {
            return FactionValueApiFp(configuration).deleteFactionValue(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets FactionValue
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFactionValue(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsFactionValue>> {
            return FactionValueApiFp(configuration).getFactionValue(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists FactionValues
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFactionValues(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsFactionValue>> {
            return FactionValueApiFp(configuration).listFactionValues(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates FactionValue
         * @param {number} id Id
         * @param {ModelsFactionValue} factionValue FactionValue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFactionValue(id: number, factionValue: ModelsFactionValue, options?: any): AxiosPromise<Array<ModelsFactionValue>> {
            return FactionValueApiFp(configuration).updateFactionValue(id, factionValue, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createFactionValue operation in FactionValueApi.
 * @export
 * @interface FactionValueApiCreateFactionValueRequest
 */
export interface FactionValueApiCreateFactionValueRequest {
    /**
     * FactionValue
     * @type {ModelsFactionValue}
     * @memberof FactionValueApiCreateFactionValue
     */
    readonly factionValue: ModelsFactionValue
}

/**
 * Request parameters for deleteFactionValue operation in FactionValueApi.
 * @export
 * @interface FactionValueApiDeleteFactionValueRequest
 */
export interface FactionValueApiDeleteFactionValueRequest {
    /**
     * Id
     * @type {number}
     * @memberof FactionValueApiDeleteFactionValue
     */
    readonly id: number
}

/**
 * Request parameters for getFactionValue operation in FactionValueApi.
 * @export
 * @interface FactionValueApiGetFactionValueRequest
 */
export interface FactionValueApiGetFactionValueRequest {
    /**
     * Id
     * @type {number}
     * @memberof FactionValueApiGetFactionValue
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof FactionValueApiGetFactionValue
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof FactionValueApiGetFactionValue
     */
    readonly select?: string
}

/**
 * Request parameters for listFactionValues operation in FactionValueApi.
 * @export
 * @interface FactionValueApiListFactionValuesRequest
 */
export interface FactionValueApiListFactionValuesRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof FactionValueApiListFactionValues
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof FactionValueApiListFactionValues
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof FactionValueApiListFactionValues
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof FactionValueApiListFactionValues
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof FactionValueApiListFactionValues
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof FactionValueApiListFactionValues
     */
    readonly select?: string
}

/**
 * Request parameters for updateFactionValue operation in FactionValueApi.
 * @export
 * @interface FactionValueApiUpdateFactionValueRequest
 */
export interface FactionValueApiUpdateFactionValueRequest {
    /**
     * Id
     * @type {number}
     * @memberof FactionValueApiUpdateFactionValue
     */
    readonly id: number

    /**
     * FactionValue
     * @type {ModelsFactionValue}
     * @memberof FactionValueApiUpdateFactionValue
     */
    readonly factionValue: ModelsFactionValue
}

/**
 * FactionValueApi - object-oriented interface
 * @export
 * @class FactionValueApi
 * @extends {BaseAPI}
 */
export class FactionValueApi extends BaseAPI {
    /**
     * 
     * @summary Creates FactionValue
     * @param {FactionValueApiCreateFactionValueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactionValueApi
     */
    public createFactionValue(requestParameters: FactionValueApiCreateFactionValueRequest, options?: any) {
        return FactionValueApiFp(this.configuration).createFactionValue(requestParameters.factionValue, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes FactionValue
     * @param {FactionValueApiDeleteFactionValueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactionValueApi
     */
    public deleteFactionValue(requestParameters: FactionValueApiDeleteFactionValueRequest, options?: any) {
        return FactionValueApiFp(this.configuration).deleteFactionValue(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets FactionValue
     * @param {FactionValueApiGetFactionValueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactionValueApi
     */
    public getFactionValue(requestParameters: FactionValueApiGetFactionValueRequest, options?: any) {
        return FactionValueApiFp(this.configuration).getFactionValue(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists FactionValues
     * @param {FactionValueApiListFactionValuesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactionValueApi
     */
    public listFactionValues(requestParameters: FactionValueApiListFactionValuesRequest = {}, options?: any) {
        return FactionValueApiFp(this.configuration).listFactionValues(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates FactionValue
     * @param {FactionValueApiUpdateFactionValueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactionValueApi
     */
    public updateFactionValue(requestParameters: FactionValueApiUpdateFactionValueRequest, options?: any) {
        return FactionValueApiFp(this.configuration).updateFactionValue(requestParameters.id, requestParameters.factionValue, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FishingApi - axios parameter creator
 * @export
 */
export const FishingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Fishing
         * @param {ModelsFishing} fishing Fishing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFishing: async (fishing: ModelsFishing, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fishing' is not null or undefined
            if (fishing === null || fishing === undefined) {
                throw new RequiredError('fishing','Required parameter fishing was null or undefined when calling createFishing.');
            }
            const localVarPath = `/fishing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof fishing !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(fishing !== undefined ? fishing : {})
                : (fishing || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes Fishing
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFishing: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteFishing.');
            }
            const localVarPath = `/fishing/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Fishing
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFishing: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getFishing.');
            }
            const localVarPath = `/fishing/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists Fishings
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFishings: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/fishings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates Fishing
         * @param {number} id Id
         * @param {ModelsFishing} fishing Fishing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFishing: async (id: number, fishing: ModelsFishing, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateFishing.');
            }
            // verify required parameter 'fishing' is not null or undefined
            if (fishing === null || fishing === undefined) {
                throw new RequiredError('fishing','Required parameter fishing was null or undefined when calling updateFishing.');
            }
            const localVarPath = `/fishing/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof fishing !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(fishing !== undefined ? fishing : {})
                : (fishing || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FishingApi - functional programming interface
 * @export
 */
export const FishingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Fishing
         * @param {ModelsFishing} fishing Fishing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFishing(fishing: ModelsFishing, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsFishing>>> {
            const localVarAxiosArgs = await FishingApiAxiosParamCreator(configuration).createFishing(fishing, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes Fishing
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFishing(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await FishingApiAxiosParamCreator(configuration).deleteFishing(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Fishing
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFishing(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsFishing>>> {
            const localVarAxiosArgs = await FishingApiAxiosParamCreator(configuration).getFishing(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists Fishings
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFishings(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsFishing>>> {
            const localVarAxiosArgs = await FishingApiAxiosParamCreator(configuration).listFishings(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates Fishing
         * @param {number} id Id
         * @param {ModelsFishing} fishing Fishing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFishing(id: number, fishing: ModelsFishing, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsFishing>>> {
            const localVarAxiosArgs = await FishingApiAxiosParamCreator(configuration).updateFishing(id, fishing, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * FishingApi - factory interface
 * @export
 */
export const FishingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates Fishing
         * @param {ModelsFishing} fishing Fishing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFishing(fishing: ModelsFishing, options?: any): AxiosPromise<Array<ModelsFishing>> {
            return FishingApiFp(configuration).createFishing(fishing, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes Fishing
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFishing(id: number, options?: any): AxiosPromise<string> {
            return FishingApiFp(configuration).deleteFishing(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Fishing
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFishing(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsFishing>> {
            return FishingApiFp(configuration).getFishing(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists Fishings
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFishings(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsFishing>> {
            return FishingApiFp(configuration).listFishings(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates Fishing
         * @param {number} id Id
         * @param {ModelsFishing} fishing Fishing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFishing(id: number, fishing: ModelsFishing, options?: any): AxiosPromise<Array<ModelsFishing>> {
            return FishingApiFp(configuration).updateFishing(id, fishing, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createFishing operation in FishingApi.
 * @export
 * @interface FishingApiCreateFishingRequest
 */
export interface FishingApiCreateFishingRequest {
    /**
     * Fishing
     * @type {ModelsFishing}
     * @memberof FishingApiCreateFishing
     */
    readonly fishing: ModelsFishing
}

/**
 * Request parameters for deleteFishing operation in FishingApi.
 * @export
 * @interface FishingApiDeleteFishingRequest
 */
export interface FishingApiDeleteFishingRequest {
    /**
     * Id
     * @type {number}
     * @memberof FishingApiDeleteFishing
     */
    readonly id: number
}

/**
 * Request parameters for getFishing operation in FishingApi.
 * @export
 * @interface FishingApiGetFishingRequest
 */
export interface FishingApiGetFishingRequest {
    /**
     * Id
     * @type {number}
     * @memberof FishingApiGetFishing
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof FishingApiGetFishing
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof FishingApiGetFishing
     */
    readonly select?: string
}

/**
 * Request parameters for listFishings operation in FishingApi.
 * @export
 * @interface FishingApiListFishingsRequest
 */
export interface FishingApiListFishingsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof FishingApiListFishings
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof FishingApiListFishings
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof FishingApiListFishings
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof FishingApiListFishings
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof FishingApiListFishings
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof FishingApiListFishings
     */
    readonly select?: string
}

/**
 * Request parameters for updateFishing operation in FishingApi.
 * @export
 * @interface FishingApiUpdateFishingRequest
 */
export interface FishingApiUpdateFishingRequest {
    /**
     * Id
     * @type {number}
     * @memberof FishingApiUpdateFishing
     */
    readonly id: number

    /**
     * Fishing
     * @type {ModelsFishing}
     * @memberof FishingApiUpdateFishing
     */
    readonly fishing: ModelsFishing
}

/**
 * FishingApi - object-oriented interface
 * @export
 * @class FishingApi
 * @extends {BaseAPI}
 */
export class FishingApi extends BaseAPI {
    /**
     * 
     * @summary Creates Fishing
     * @param {FishingApiCreateFishingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FishingApi
     */
    public createFishing(requestParameters: FishingApiCreateFishingRequest, options?: any) {
        return FishingApiFp(this.configuration).createFishing(requestParameters.fishing, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes Fishing
     * @param {FishingApiDeleteFishingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FishingApi
     */
    public deleteFishing(requestParameters: FishingApiDeleteFishingRequest, options?: any) {
        return FishingApiFp(this.configuration).deleteFishing(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Fishing
     * @param {FishingApiGetFishingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FishingApi
     */
    public getFishing(requestParameters: FishingApiGetFishingRequest, options?: any) {
        return FishingApiFp(this.configuration).getFishing(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists Fishings
     * @param {FishingApiListFishingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FishingApi
     */
    public listFishings(requestParameters: FishingApiListFishingsRequest = {}, options?: any) {
        return FishingApiFp(this.configuration).listFishings(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates Fishing
     * @param {FishingApiUpdateFishingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FishingApi
     */
    public updateFishing(requestParameters: FishingApiUpdateFishingRequest, options?: any) {
        return FishingApiFp(this.configuration).updateFishing(requestParameters.id, requestParameters.fishing, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ForageApi - axios parameter creator
 * @export
 */
export const ForageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Forage
         * @param {ModelsForage} forage Forage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createForage: async (forage: ModelsForage, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'forage' is not null or undefined
            if (forage === null || forage === undefined) {
                throw new RequiredError('forage','Required parameter forage was null or undefined when calling createForage.');
            }
            const localVarPath = `/forage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof forage !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(forage !== undefined ? forage : {})
                : (forage || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes Forage
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteForage: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteForage.');
            }
            const localVarPath = `/forage/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Forage
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForage: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getForage.');
            }
            const localVarPath = `/forage/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists Forages
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listForages: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/forages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates Forage
         * @param {number} id Id
         * @param {ModelsForage} forage Forage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateForage: async (id: number, forage: ModelsForage, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateForage.');
            }
            // verify required parameter 'forage' is not null or undefined
            if (forage === null || forage === undefined) {
                throw new RequiredError('forage','Required parameter forage was null or undefined when calling updateForage.');
            }
            const localVarPath = `/forage/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof forage !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(forage !== undefined ? forage : {})
                : (forage || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ForageApi - functional programming interface
 * @export
 */
export const ForageApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Forage
         * @param {ModelsForage} forage Forage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createForage(forage: ModelsForage, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsForage>>> {
            const localVarAxiosArgs = await ForageApiAxiosParamCreator(configuration).createForage(forage, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes Forage
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteForage(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await ForageApiAxiosParamCreator(configuration).deleteForage(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Forage
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForage(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsForage>>> {
            const localVarAxiosArgs = await ForageApiAxiosParamCreator(configuration).getForage(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists Forages
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listForages(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsForage>>> {
            const localVarAxiosArgs = await ForageApiAxiosParamCreator(configuration).listForages(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates Forage
         * @param {number} id Id
         * @param {ModelsForage} forage Forage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateForage(id: number, forage: ModelsForage, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsForage>>> {
            const localVarAxiosArgs = await ForageApiAxiosParamCreator(configuration).updateForage(id, forage, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ForageApi - factory interface
 * @export
 */
export const ForageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates Forage
         * @param {ModelsForage} forage Forage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createForage(forage: ModelsForage, options?: any): AxiosPromise<Array<ModelsForage>> {
            return ForageApiFp(configuration).createForage(forage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes Forage
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteForage(id: number, options?: any): AxiosPromise<string> {
            return ForageApiFp(configuration).deleteForage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Forage
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForage(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsForage>> {
            return ForageApiFp(configuration).getForage(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists Forages
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listForages(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsForage>> {
            return ForageApiFp(configuration).listForages(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates Forage
         * @param {number} id Id
         * @param {ModelsForage} forage Forage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateForage(id: number, forage: ModelsForage, options?: any): AxiosPromise<Array<ModelsForage>> {
            return ForageApiFp(configuration).updateForage(id, forage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createForage operation in ForageApi.
 * @export
 * @interface ForageApiCreateForageRequest
 */
export interface ForageApiCreateForageRequest {
    /**
     * Forage
     * @type {ModelsForage}
     * @memberof ForageApiCreateForage
     */
    readonly forage: ModelsForage
}

/**
 * Request parameters for deleteForage operation in ForageApi.
 * @export
 * @interface ForageApiDeleteForageRequest
 */
export interface ForageApiDeleteForageRequest {
    /**
     * Id
     * @type {number}
     * @memberof ForageApiDeleteForage
     */
    readonly id: number
}

/**
 * Request parameters for getForage operation in ForageApi.
 * @export
 * @interface ForageApiGetForageRequest
 */
export interface ForageApiGetForageRequest {
    /**
     * Id
     * @type {number}
     * @memberof ForageApiGetForage
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof ForageApiGetForage
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof ForageApiGetForage
     */
    readonly select?: string
}

/**
 * Request parameters for listForages operation in ForageApi.
 * @export
 * @interface ForageApiListForagesRequest
 */
export interface ForageApiListForagesRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof ForageApiListForages
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof ForageApiListForages
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof ForageApiListForages
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof ForageApiListForages
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof ForageApiListForages
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof ForageApiListForages
     */
    readonly select?: string
}

/**
 * Request parameters for updateForage operation in ForageApi.
 * @export
 * @interface ForageApiUpdateForageRequest
 */
export interface ForageApiUpdateForageRequest {
    /**
     * Id
     * @type {number}
     * @memberof ForageApiUpdateForage
     */
    readonly id: number

    /**
     * Forage
     * @type {ModelsForage}
     * @memberof ForageApiUpdateForage
     */
    readonly forage: ModelsForage
}

/**
 * ForageApi - object-oriented interface
 * @export
 * @class ForageApi
 * @extends {BaseAPI}
 */
export class ForageApi extends BaseAPI {
    /**
     * 
     * @summary Creates Forage
     * @param {ForageApiCreateForageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ForageApi
     */
    public createForage(requestParameters: ForageApiCreateForageRequest, options?: any) {
        return ForageApiFp(this.configuration).createForage(requestParameters.forage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes Forage
     * @param {ForageApiDeleteForageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ForageApi
     */
    public deleteForage(requestParameters: ForageApiDeleteForageRequest, options?: any) {
        return ForageApiFp(this.configuration).deleteForage(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Forage
     * @param {ForageApiGetForageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ForageApi
     */
    public getForage(requestParameters: ForageApiGetForageRequest, options?: any) {
        return ForageApiFp(this.configuration).getForage(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists Forages
     * @param {ForageApiListForagesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ForageApi
     */
    public listForages(requestParameters: ForageApiListForagesRequest = {}, options?: any) {
        return ForageApiFp(this.configuration).listForages(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates Forage
     * @param {ForageApiUpdateForageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ForageApi
     */
    public updateForage(requestParameters: ForageApiUpdateForageRequest, options?: any) {
        return ForageApiFp(this.configuration).updateForage(requestParameters.id, requestParameters.forage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GlobalLootApi - axios parameter creator
 * @export
 */
export const GlobalLootApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates GlobalLoot
         * @param {ModelsGlobalLoot} globalLoot GlobalLoot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGlobalLoot: async (globalLoot: ModelsGlobalLoot, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'globalLoot' is not null or undefined
            if (globalLoot === null || globalLoot === undefined) {
                throw new RequiredError('globalLoot','Required parameter globalLoot was null or undefined when calling createGlobalLoot.');
            }
            const localVarPath = `/global_loot`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof globalLoot !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(globalLoot !== undefined ? globalLoot : {})
                : (globalLoot || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes GlobalLoot
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGlobalLoot: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteGlobalLoot.');
            }
            const localVarPath = `/global_loot/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets GlobalLoot
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGlobalLoot: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getGlobalLoot.');
            }
            const localVarPath = `/global_loot/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists GlobalLoots
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGlobalLoots: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/global_loots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates GlobalLoot
         * @param {number} id Id
         * @param {ModelsGlobalLoot} globalLoot GlobalLoot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGlobalLoot: async (id: number, globalLoot: ModelsGlobalLoot, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateGlobalLoot.');
            }
            // verify required parameter 'globalLoot' is not null or undefined
            if (globalLoot === null || globalLoot === undefined) {
                throw new RequiredError('globalLoot','Required parameter globalLoot was null or undefined when calling updateGlobalLoot.');
            }
            const localVarPath = `/global_loot/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof globalLoot !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(globalLoot !== undefined ? globalLoot : {})
                : (globalLoot || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GlobalLootApi - functional programming interface
 * @export
 */
export const GlobalLootApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates GlobalLoot
         * @param {ModelsGlobalLoot} globalLoot GlobalLoot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGlobalLoot(globalLoot: ModelsGlobalLoot, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsGlobalLoot>>> {
            const localVarAxiosArgs = await GlobalLootApiAxiosParamCreator(configuration).createGlobalLoot(globalLoot, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes GlobalLoot
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGlobalLoot(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await GlobalLootApiAxiosParamCreator(configuration).deleteGlobalLoot(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets GlobalLoot
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGlobalLoot(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsGlobalLoot>>> {
            const localVarAxiosArgs = await GlobalLootApiAxiosParamCreator(configuration).getGlobalLoot(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists GlobalLoots
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGlobalLoots(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsGlobalLoot>>> {
            const localVarAxiosArgs = await GlobalLootApiAxiosParamCreator(configuration).listGlobalLoots(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates GlobalLoot
         * @param {number} id Id
         * @param {ModelsGlobalLoot} globalLoot GlobalLoot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGlobalLoot(id: number, globalLoot: ModelsGlobalLoot, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsGlobalLoot>>> {
            const localVarAxiosArgs = await GlobalLootApiAxiosParamCreator(configuration).updateGlobalLoot(id, globalLoot, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * GlobalLootApi - factory interface
 * @export
 */
export const GlobalLootApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates GlobalLoot
         * @param {ModelsGlobalLoot} globalLoot GlobalLoot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGlobalLoot(globalLoot: ModelsGlobalLoot, options?: any): AxiosPromise<Array<ModelsGlobalLoot>> {
            return GlobalLootApiFp(configuration).createGlobalLoot(globalLoot, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes GlobalLoot
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGlobalLoot(id: number, options?: any): AxiosPromise<string> {
            return GlobalLootApiFp(configuration).deleteGlobalLoot(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets GlobalLoot
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGlobalLoot(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsGlobalLoot>> {
            return GlobalLootApiFp(configuration).getGlobalLoot(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists GlobalLoots
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGlobalLoots(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsGlobalLoot>> {
            return GlobalLootApiFp(configuration).listGlobalLoots(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates GlobalLoot
         * @param {number} id Id
         * @param {ModelsGlobalLoot} globalLoot GlobalLoot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGlobalLoot(id: number, globalLoot: ModelsGlobalLoot, options?: any): AxiosPromise<Array<ModelsGlobalLoot>> {
            return GlobalLootApiFp(configuration).updateGlobalLoot(id, globalLoot, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createGlobalLoot operation in GlobalLootApi.
 * @export
 * @interface GlobalLootApiCreateGlobalLootRequest
 */
export interface GlobalLootApiCreateGlobalLootRequest {
    /**
     * GlobalLoot
     * @type {ModelsGlobalLoot}
     * @memberof GlobalLootApiCreateGlobalLoot
     */
    readonly globalLoot: ModelsGlobalLoot
}

/**
 * Request parameters for deleteGlobalLoot operation in GlobalLootApi.
 * @export
 * @interface GlobalLootApiDeleteGlobalLootRequest
 */
export interface GlobalLootApiDeleteGlobalLootRequest {
    /**
     * Id
     * @type {number}
     * @memberof GlobalLootApiDeleteGlobalLoot
     */
    readonly id: number
}

/**
 * Request parameters for getGlobalLoot operation in GlobalLootApi.
 * @export
 * @interface GlobalLootApiGetGlobalLootRequest
 */
export interface GlobalLootApiGetGlobalLootRequest {
    /**
     * Id
     * @type {number}
     * @memberof GlobalLootApiGetGlobalLoot
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof GlobalLootApiGetGlobalLoot
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof GlobalLootApiGetGlobalLoot
     */
    readonly select?: string
}

/**
 * Request parameters for listGlobalLoots operation in GlobalLootApi.
 * @export
 * @interface GlobalLootApiListGlobalLootsRequest
 */
export interface GlobalLootApiListGlobalLootsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof GlobalLootApiListGlobalLoots
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof GlobalLootApiListGlobalLoots
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof GlobalLootApiListGlobalLoots
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof GlobalLootApiListGlobalLoots
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof GlobalLootApiListGlobalLoots
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof GlobalLootApiListGlobalLoots
     */
    readonly select?: string
}

/**
 * Request parameters for updateGlobalLoot operation in GlobalLootApi.
 * @export
 * @interface GlobalLootApiUpdateGlobalLootRequest
 */
export interface GlobalLootApiUpdateGlobalLootRequest {
    /**
     * Id
     * @type {number}
     * @memberof GlobalLootApiUpdateGlobalLoot
     */
    readonly id: number

    /**
     * GlobalLoot
     * @type {ModelsGlobalLoot}
     * @memberof GlobalLootApiUpdateGlobalLoot
     */
    readonly globalLoot: ModelsGlobalLoot
}

/**
 * GlobalLootApi - object-oriented interface
 * @export
 * @class GlobalLootApi
 * @extends {BaseAPI}
 */
export class GlobalLootApi extends BaseAPI {
    /**
     * 
     * @summary Creates GlobalLoot
     * @param {GlobalLootApiCreateGlobalLootRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalLootApi
     */
    public createGlobalLoot(requestParameters: GlobalLootApiCreateGlobalLootRequest, options?: any) {
        return GlobalLootApiFp(this.configuration).createGlobalLoot(requestParameters.globalLoot, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes GlobalLoot
     * @param {GlobalLootApiDeleteGlobalLootRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalLootApi
     */
    public deleteGlobalLoot(requestParameters: GlobalLootApiDeleteGlobalLootRequest, options?: any) {
        return GlobalLootApiFp(this.configuration).deleteGlobalLoot(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets GlobalLoot
     * @param {GlobalLootApiGetGlobalLootRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalLootApi
     */
    public getGlobalLoot(requestParameters: GlobalLootApiGetGlobalLootRequest, options?: any) {
        return GlobalLootApiFp(this.configuration).getGlobalLoot(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists GlobalLoots
     * @param {GlobalLootApiListGlobalLootsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalLootApi
     */
    public listGlobalLoots(requestParameters: GlobalLootApiListGlobalLootsRequest = {}, options?: any) {
        return GlobalLootApiFp(this.configuration).listGlobalLoots(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates GlobalLoot
     * @param {GlobalLootApiUpdateGlobalLootRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalLootApi
     */
    public updateGlobalLoot(requestParameters: GlobalLootApiUpdateGlobalLootRequest, options?: any) {
        return GlobalLootApiFp(this.configuration).updateGlobalLoot(requestParameters.id, requestParameters.globalLoot, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GraveyardApi - axios parameter creator
 * @export
 */
export const GraveyardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Graveyard
         * @param {ModelsGraveyard} graveyard Graveyard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGraveyard: async (graveyard: ModelsGraveyard, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'graveyard' is not null or undefined
            if (graveyard === null || graveyard === undefined) {
                throw new RequiredError('graveyard','Required parameter graveyard was null or undefined when calling createGraveyard.');
            }
            const localVarPath = `/graveyard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof graveyard !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(graveyard !== undefined ? graveyard : {})
                : (graveyard || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes Graveyard
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGraveyard: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteGraveyard.');
            }
            const localVarPath = `/graveyard/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Graveyard
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGraveyard: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getGraveyard.');
            }
            const localVarPath = `/graveyard/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists Graveyards
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGraveyards: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/graveyards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates Graveyard
         * @param {number} id Id
         * @param {ModelsGraveyard} graveyard Graveyard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGraveyard: async (id: number, graveyard: ModelsGraveyard, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateGraveyard.');
            }
            // verify required parameter 'graveyard' is not null or undefined
            if (graveyard === null || graveyard === undefined) {
                throw new RequiredError('graveyard','Required parameter graveyard was null or undefined when calling updateGraveyard.');
            }
            const localVarPath = `/graveyard/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof graveyard !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(graveyard !== undefined ? graveyard : {})
                : (graveyard || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GraveyardApi - functional programming interface
 * @export
 */
export const GraveyardApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Graveyard
         * @param {ModelsGraveyard} graveyard Graveyard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGraveyard(graveyard: ModelsGraveyard, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsGraveyard>>> {
            const localVarAxiosArgs = await GraveyardApiAxiosParamCreator(configuration).createGraveyard(graveyard, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes Graveyard
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGraveyard(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await GraveyardApiAxiosParamCreator(configuration).deleteGraveyard(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Graveyard
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGraveyard(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsGraveyard>>> {
            const localVarAxiosArgs = await GraveyardApiAxiosParamCreator(configuration).getGraveyard(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists Graveyards
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGraveyards(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsGraveyard>>> {
            const localVarAxiosArgs = await GraveyardApiAxiosParamCreator(configuration).listGraveyards(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates Graveyard
         * @param {number} id Id
         * @param {ModelsGraveyard} graveyard Graveyard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGraveyard(id: number, graveyard: ModelsGraveyard, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsGraveyard>>> {
            const localVarAxiosArgs = await GraveyardApiAxiosParamCreator(configuration).updateGraveyard(id, graveyard, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * GraveyardApi - factory interface
 * @export
 */
export const GraveyardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates Graveyard
         * @param {ModelsGraveyard} graveyard Graveyard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGraveyard(graveyard: ModelsGraveyard, options?: any): AxiosPromise<Array<ModelsGraveyard>> {
            return GraveyardApiFp(configuration).createGraveyard(graveyard, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes Graveyard
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGraveyard(id: number, options?: any): AxiosPromise<string> {
            return GraveyardApiFp(configuration).deleteGraveyard(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Graveyard
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGraveyard(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsGraveyard>> {
            return GraveyardApiFp(configuration).getGraveyard(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists Graveyards
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGraveyards(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsGraveyard>> {
            return GraveyardApiFp(configuration).listGraveyards(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates Graveyard
         * @param {number} id Id
         * @param {ModelsGraveyard} graveyard Graveyard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGraveyard(id: number, graveyard: ModelsGraveyard, options?: any): AxiosPromise<Array<ModelsGraveyard>> {
            return GraveyardApiFp(configuration).updateGraveyard(id, graveyard, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createGraveyard operation in GraveyardApi.
 * @export
 * @interface GraveyardApiCreateGraveyardRequest
 */
export interface GraveyardApiCreateGraveyardRequest {
    /**
     * Graveyard
     * @type {ModelsGraveyard}
     * @memberof GraveyardApiCreateGraveyard
     */
    readonly graveyard: ModelsGraveyard
}

/**
 * Request parameters for deleteGraveyard operation in GraveyardApi.
 * @export
 * @interface GraveyardApiDeleteGraveyardRequest
 */
export interface GraveyardApiDeleteGraveyardRequest {
    /**
     * Id
     * @type {number}
     * @memberof GraveyardApiDeleteGraveyard
     */
    readonly id: number
}

/**
 * Request parameters for getGraveyard operation in GraveyardApi.
 * @export
 * @interface GraveyardApiGetGraveyardRequest
 */
export interface GraveyardApiGetGraveyardRequest {
    /**
     * Id
     * @type {number}
     * @memberof GraveyardApiGetGraveyard
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof GraveyardApiGetGraveyard
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof GraveyardApiGetGraveyard
     */
    readonly select?: string
}

/**
 * Request parameters for listGraveyards operation in GraveyardApi.
 * @export
 * @interface GraveyardApiListGraveyardsRequest
 */
export interface GraveyardApiListGraveyardsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof GraveyardApiListGraveyards
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof GraveyardApiListGraveyards
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof GraveyardApiListGraveyards
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof GraveyardApiListGraveyards
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof GraveyardApiListGraveyards
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof GraveyardApiListGraveyards
     */
    readonly select?: string
}

/**
 * Request parameters for updateGraveyard operation in GraveyardApi.
 * @export
 * @interface GraveyardApiUpdateGraveyardRequest
 */
export interface GraveyardApiUpdateGraveyardRequest {
    /**
     * Id
     * @type {number}
     * @memberof GraveyardApiUpdateGraveyard
     */
    readonly id: number

    /**
     * Graveyard
     * @type {ModelsGraveyard}
     * @memberof GraveyardApiUpdateGraveyard
     */
    readonly graveyard: ModelsGraveyard
}

/**
 * GraveyardApi - object-oriented interface
 * @export
 * @class GraveyardApi
 * @extends {BaseAPI}
 */
export class GraveyardApi extends BaseAPI {
    /**
     * 
     * @summary Creates Graveyard
     * @param {GraveyardApiCreateGraveyardRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraveyardApi
     */
    public createGraveyard(requestParameters: GraveyardApiCreateGraveyardRequest, options?: any) {
        return GraveyardApiFp(this.configuration).createGraveyard(requestParameters.graveyard, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes Graveyard
     * @param {GraveyardApiDeleteGraveyardRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraveyardApi
     */
    public deleteGraveyard(requestParameters: GraveyardApiDeleteGraveyardRequest, options?: any) {
        return GraveyardApiFp(this.configuration).deleteGraveyard(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Graveyard
     * @param {GraveyardApiGetGraveyardRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraveyardApi
     */
    public getGraveyard(requestParameters: GraveyardApiGetGraveyardRequest, options?: any) {
        return GraveyardApiFp(this.configuration).getGraveyard(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists Graveyards
     * @param {GraveyardApiListGraveyardsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraveyardApi
     */
    public listGraveyards(requestParameters: GraveyardApiListGraveyardsRequest = {}, options?: any) {
        return GraveyardApiFp(this.configuration).listGraveyards(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates Graveyard
     * @param {GraveyardApiUpdateGraveyardRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraveyardApi
     */
    public updateGraveyard(requestParameters: GraveyardApiUpdateGraveyardRequest, options?: any) {
        return GraveyardApiFp(this.configuration).updateGraveyard(requestParameters.id, requestParameters.graveyard, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GridApi - axios parameter creator
 * @export
 */
export const GridApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Grid
         * @param {ModelsGrid} grid Grid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGrid: async (grid: ModelsGrid, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'grid' is not null or undefined
            if (grid === null || grid === undefined) {
                throw new RequiredError('grid','Required parameter grid was null or undefined when calling createGrid.');
            }
            const localVarPath = `/grid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof grid !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(grid !== undefined ? grid : {})
                : (grid || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes Grid
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGrid: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteGrid.');
            }
            const localVarPath = `/grid/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Grid
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;GridEntries
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGrid: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getGrid.');
            }
            const localVarPath = `/grid/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists Grids
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;GridEntries
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGrids: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/grids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates Grid
         * @param {number} id Id
         * @param {ModelsGrid} grid Grid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGrid: async (id: number, grid: ModelsGrid, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateGrid.');
            }
            // verify required parameter 'grid' is not null or undefined
            if (grid === null || grid === undefined) {
                throw new RequiredError('grid','Required parameter grid was null or undefined when calling updateGrid.');
            }
            const localVarPath = `/grid/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof grid !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(grid !== undefined ? grid : {})
                : (grid || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GridApi - functional programming interface
 * @export
 */
export const GridApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Grid
         * @param {ModelsGrid} grid Grid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGrid(grid: ModelsGrid, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsGrid>>> {
            const localVarAxiosArgs = await GridApiAxiosParamCreator(configuration).createGrid(grid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes Grid
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGrid(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await GridApiAxiosParamCreator(configuration).deleteGrid(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Grid
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;GridEntries
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGrid(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsGrid>>> {
            const localVarAxiosArgs = await GridApiAxiosParamCreator(configuration).getGrid(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists Grids
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;GridEntries
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGrids(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsGrid>>> {
            const localVarAxiosArgs = await GridApiAxiosParamCreator(configuration).listGrids(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates Grid
         * @param {number} id Id
         * @param {ModelsGrid} grid Grid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGrid(id: number, grid: ModelsGrid, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsGrid>>> {
            const localVarAxiosArgs = await GridApiAxiosParamCreator(configuration).updateGrid(id, grid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * GridApi - factory interface
 * @export
 */
export const GridApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates Grid
         * @param {ModelsGrid} grid Grid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGrid(grid: ModelsGrid, options?: any): AxiosPromise<Array<ModelsGrid>> {
            return GridApiFp(configuration).createGrid(grid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes Grid
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGrid(id: number, options?: any): AxiosPromise<string> {
            return GridApiFp(configuration).deleteGrid(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Grid
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;GridEntries
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGrid(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsGrid>> {
            return GridApiFp(configuration).getGrid(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists Grids
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;GridEntries
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGrids(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsGrid>> {
            return GridApiFp(configuration).listGrids(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates Grid
         * @param {number} id Id
         * @param {ModelsGrid} grid Grid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGrid(id: number, grid: ModelsGrid, options?: any): AxiosPromise<Array<ModelsGrid>> {
            return GridApiFp(configuration).updateGrid(id, grid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createGrid operation in GridApi.
 * @export
 * @interface GridApiCreateGridRequest
 */
export interface GridApiCreateGridRequest {
    /**
     * Grid
     * @type {ModelsGrid}
     * @memberof GridApiCreateGrid
     */
    readonly grid: ModelsGrid
}

/**
 * Request parameters for deleteGrid operation in GridApi.
 * @export
 * @interface GridApiDeleteGridRequest
 */
export interface GridApiDeleteGridRequest {
    /**
     * Id
     * @type {number}
     * @memberof GridApiDeleteGrid
     */
    readonly id: number
}

/**
 * Request parameters for getGrid operation in GridApi.
 * @export
 * @interface GridApiGetGridRequest
 */
export interface GridApiGetGridRequest {
    /**
     * Id
     * @type {number}
     * @memberof GridApiGetGrid
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;GridEntries
     * @type {string}
     * @memberof GridApiGetGrid
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof GridApiGetGrid
     */
    readonly select?: string
}

/**
 * Request parameters for listGrids operation in GridApi.
 * @export
 * @interface GridApiListGridsRequest
 */
export interface GridApiListGridsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;GridEntries
     * @type {string}
     * @memberof GridApiListGrids
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof GridApiListGrids
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof GridApiListGrids
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof GridApiListGrids
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof GridApiListGrids
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof GridApiListGrids
     */
    readonly select?: string
}

/**
 * Request parameters for updateGrid operation in GridApi.
 * @export
 * @interface GridApiUpdateGridRequest
 */
export interface GridApiUpdateGridRequest {
    /**
     * Id
     * @type {number}
     * @memberof GridApiUpdateGrid
     */
    readonly id: number

    /**
     * Grid
     * @type {ModelsGrid}
     * @memberof GridApiUpdateGrid
     */
    readonly grid: ModelsGrid
}

/**
 * GridApi - object-oriented interface
 * @export
 * @class GridApi
 * @extends {BaseAPI}
 */
export class GridApi extends BaseAPI {
    /**
     * 
     * @summary Creates Grid
     * @param {GridApiCreateGridRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GridApi
     */
    public createGrid(requestParameters: GridApiCreateGridRequest, options?: any) {
        return GridApiFp(this.configuration).createGrid(requestParameters.grid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes Grid
     * @param {GridApiDeleteGridRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GridApi
     */
    public deleteGrid(requestParameters: GridApiDeleteGridRequest, options?: any) {
        return GridApiFp(this.configuration).deleteGrid(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Grid
     * @param {GridApiGetGridRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GridApi
     */
    public getGrid(requestParameters: GridApiGetGridRequest, options?: any) {
        return GridApiFp(this.configuration).getGrid(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists Grids
     * @param {GridApiListGridsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GridApi
     */
    public listGrids(requestParameters: GridApiListGridsRequest = {}, options?: any) {
        return GridApiFp(this.configuration).listGrids(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates Grid
     * @param {GridApiUpdateGridRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GridApi
     */
    public updateGrid(requestParameters: GridApiUpdateGridRequest, options?: any) {
        return GridApiFp(this.configuration).updateGrid(requestParameters.id, requestParameters.grid, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GridEntryApi - axios parameter creator
 * @export
 */
export const GridEntryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates GridEntry
         * @param {ModelsGridEntry} gridEntry GridEntry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGridEntry: async (gridEntry: ModelsGridEntry, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'gridEntry' is not null or undefined
            if (gridEntry === null || gridEntry === undefined) {
                throw new RequiredError('gridEntry','Required parameter gridEntry was null or undefined when calling createGridEntry.');
            }
            const localVarPath = `/grid_entry`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof gridEntry !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(gridEntry !== undefined ? gridEntry : {})
                : (gridEntry || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes GridEntry
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGridEntry: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteGridEntry.');
            }
            const localVarPath = `/grid_entry/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets GridEntry
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGridEntry: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getGridEntry.');
            }
            const localVarPath = `/grid_entry/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists GridEntries
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGridEntries: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/grid_entries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates GridEntry
         * @param {number} id Id
         * @param {ModelsGridEntry} gridEntry GridEntry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGridEntry: async (id: number, gridEntry: ModelsGridEntry, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateGridEntry.');
            }
            // verify required parameter 'gridEntry' is not null or undefined
            if (gridEntry === null || gridEntry === undefined) {
                throw new RequiredError('gridEntry','Required parameter gridEntry was null or undefined when calling updateGridEntry.');
            }
            const localVarPath = `/grid_entry/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof gridEntry !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(gridEntry !== undefined ? gridEntry : {})
                : (gridEntry || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GridEntryApi - functional programming interface
 * @export
 */
export const GridEntryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates GridEntry
         * @param {ModelsGridEntry} gridEntry GridEntry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGridEntry(gridEntry: ModelsGridEntry, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsGridEntry>>> {
            const localVarAxiosArgs = await GridEntryApiAxiosParamCreator(configuration).createGridEntry(gridEntry, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes GridEntry
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGridEntry(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await GridEntryApiAxiosParamCreator(configuration).deleteGridEntry(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets GridEntry
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGridEntry(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsGridEntry>>> {
            const localVarAxiosArgs = await GridEntryApiAxiosParamCreator(configuration).getGridEntry(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists GridEntries
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGridEntries(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsGridEntry>>> {
            const localVarAxiosArgs = await GridEntryApiAxiosParamCreator(configuration).listGridEntries(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates GridEntry
         * @param {number} id Id
         * @param {ModelsGridEntry} gridEntry GridEntry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGridEntry(id: number, gridEntry: ModelsGridEntry, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsGridEntry>>> {
            const localVarAxiosArgs = await GridEntryApiAxiosParamCreator(configuration).updateGridEntry(id, gridEntry, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * GridEntryApi - factory interface
 * @export
 */
export const GridEntryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates GridEntry
         * @param {ModelsGridEntry} gridEntry GridEntry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGridEntry(gridEntry: ModelsGridEntry, options?: any): AxiosPromise<Array<ModelsGridEntry>> {
            return GridEntryApiFp(configuration).createGridEntry(gridEntry, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes GridEntry
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGridEntry(id: number, options?: any): AxiosPromise<string> {
            return GridEntryApiFp(configuration).deleteGridEntry(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets GridEntry
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGridEntry(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsGridEntry>> {
            return GridEntryApiFp(configuration).getGridEntry(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists GridEntries
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGridEntries(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsGridEntry>> {
            return GridEntryApiFp(configuration).listGridEntries(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates GridEntry
         * @param {number} id Id
         * @param {ModelsGridEntry} gridEntry GridEntry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGridEntry(id: number, gridEntry: ModelsGridEntry, options?: any): AxiosPromise<Array<ModelsGridEntry>> {
            return GridEntryApiFp(configuration).updateGridEntry(id, gridEntry, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createGridEntry operation in GridEntryApi.
 * @export
 * @interface GridEntryApiCreateGridEntryRequest
 */
export interface GridEntryApiCreateGridEntryRequest {
    /**
     * GridEntry
     * @type {ModelsGridEntry}
     * @memberof GridEntryApiCreateGridEntry
     */
    readonly gridEntry: ModelsGridEntry
}

/**
 * Request parameters for deleteGridEntry operation in GridEntryApi.
 * @export
 * @interface GridEntryApiDeleteGridEntryRequest
 */
export interface GridEntryApiDeleteGridEntryRequest {
    /**
     * Id
     * @type {number}
     * @memberof GridEntryApiDeleteGridEntry
     */
    readonly id: number
}

/**
 * Request parameters for getGridEntry operation in GridEntryApi.
 * @export
 * @interface GridEntryApiGetGridEntryRequest
 */
export interface GridEntryApiGetGridEntryRequest {
    /**
     * Id
     * @type {number}
     * @memberof GridEntryApiGetGridEntry
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof GridEntryApiGetGridEntry
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof GridEntryApiGetGridEntry
     */
    readonly select?: string
}

/**
 * Request parameters for listGridEntries operation in GridEntryApi.
 * @export
 * @interface GridEntryApiListGridEntriesRequest
 */
export interface GridEntryApiListGridEntriesRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof GridEntryApiListGridEntries
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof GridEntryApiListGridEntries
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof GridEntryApiListGridEntries
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof GridEntryApiListGridEntries
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof GridEntryApiListGridEntries
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof GridEntryApiListGridEntries
     */
    readonly select?: string
}

/**
 * Request parameters for updateGridEntry operation in GridEntryApi.
 * @export
 * @interface GridEntryApiUpdateGridEntryRequest
 */
export interface GridEntryApiUpdateGridEntryRequest {
    /**
     * Id
     * @type {number}
     * @memberof GridEntryApiUpdateGridEntry
     */
    readonly id: number

    /**
     * GridEntry
     * @type {ModelsGridEntry}
     * @memberof GridEntryApiUpdateGridEntry
     */
    readonly gridEntry: ModelsGridEntry
}

/**
 * GridEntryApi - object-oriented interface
 * @export
 * @class GridEntryApi
 * @extends {BaseAPI}
 */
export class GridEntryApi extends BaseAPI {
    /**
     * 
     * @summary Creates GridEntry
     * @param {GridEntryApiCreateGridEntryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GridEntryApi
     */
    public createGridEntry(requestParameters: GridEntryApiCreateGridEntryRequest, options?: any) {
        return GridEntryApiFp(this.configuration).createGridEntry(requestParameters.gridEntry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes GridEntry
     * @param {GridEntryApiDeleteGridEntryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GridEntryApi
     */
    public deleteGridEntry(requestParameters: GridEntryApiDeleteGridEntryRequest, options?: any) {
        return GridEntryApiFp(this.configuration).deleteGridEntry(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets GridEntry
     * @param {GridEntryApiGetGridEntryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GridEntryApi
     */
    public getGridEntry(requestParameters: GridEntryApiGetGridEntryRequest, options?: any) {
        return GridEntryApiFp(this.configuration).getGridEntry(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists GridEntries
     * @param {GridEntryApiListGridEntriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GridEntryApi
     */
    public listGridEntries(requestParameters: GridEntryApiListGridEntriesRequest = {}, options?: any) {
        return GridEntryApiFp(this.configuration).listGridEntries(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates GridEntry
     * @param {GridEntryApiUpdateGridEntryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GridEntryApi
     */
    public updateGridEntry(requestParameters: GridEntryApiUpdateGridEntryRequest, options?: any) {
        return GridEntryApiFp(this.configuration).updateGridEntry(requestParameters.id, requestParameters.gridEntry, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GroundSpawnApi - axios parameter creator
 * @export
 */
export const GroundSpawnApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates GroundSpawn
         * @param {ModelsGroundSpawn} groundSpawn GroundSpawn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroundSpawn: async (groundSpawn: ModelsGroundSpawn, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groundSpawn' is not null or undefined
            if (groundSpawn === null || groundSpawn === undefined) {
                throw new RequiredError('groundSpawn','Required parameter groundSpawn was null or undefined when calling createGroundSpawn.');
            }
            const localVarPath = `/ground_spawn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof groundSpawn !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(groundSpawn !== undefined ? groundSpawn : {})
                : (groundSpawn || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes GroundSpawn
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroundSpawn: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteGroundSpawn.');
            }
            const localVarPath = `/ground_spawn/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets GroundSpawn
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroundSpawn: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getGroundSpawn.');
            }
            const localVarPath = `/ground_spawn/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists GroundSpawns
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroundSpawns: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ground_spawns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates GroundSpawn
         * @param {number} id Id
         * @param {ModelsGroundSpawn} groundSpawn GroundSpawn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroundSpawn: async (id: number, groundSpawn: ModelsGroundSpawn, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateGroundSpawn.');
            }
            // verify required parameter 'groundSpawn' is not null or undefined
            if (groundSpawn === null || groundSpawn === undefined) {
                throw new RequiredError('groundSpawn','Required parameter groundSpawn was null or undefined when calling updateGroundSpawn.');
            }
            const localVarPath = `/ground_spawn/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof groundSpawn !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(groundSpawn !== undefined ? groundSpawn : {})
                : (groundSpawn || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroundSpawnApi - functional programming interface
 * @export
 */
export const GroundSpawnApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates GroundSpawn
         * @param {ModelsGroundSpawn} groundSpawn GroundSpawn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroundSpawn(groundSpawn: ModelsGroundSpawn, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsGroundSpawn>>> {
            const localVarAxiosArgs = await GroundSpawnApiAxiosParamCreator(configuration).createGroundSpawn(groundSpawn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes GroundSpawn
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroundSpawn(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await GroundSpawnApiAxiosParamCreator(configuration).deleteGroundSpawn(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets GroundSpawn
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroundSpawn(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsGroundSpawn>>> {
            const localVarAxiosArgs = await GroundSpawnApiAxiosParamCreator(configuration).getGroundSpawn(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists GroundSpawns
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGroundSpawns(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsGroundSpawn>>> {
            const localVarAxiosArgs = await GroundSpawnApiAxiosParamCreator(configuration).listGroundSpawns(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates GroundSpawn
         * @param {number} id Id
         * @param {ModelsGroundSpawn} groundSpawn GroundSpawn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroundSpawn(id: number, groundSpawn: ModelsGroundSpawn, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsGroundSpawn>>> {
            const localVarAxiosArgs = await GroundSpawnApiAxiosParamCreator(configuration).updateGroundSpawn(id, groundSpawn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * GroundSpawnApi - factory interface
 * @export
 */
export const GroundSpawnApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates GroundSpawn
         * @param {ModelsGroundSpawn} groundSpawn GroundSpawn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroundSpawn(groundSpawn: ModelsGroundSpawn, options?: any): AxiosPromise<Array<ModelsGroundSpawn>> {
            return GroundSpawnApiFp(configuration).createGroundSpawn(groundSpawn, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes GroundSpawn
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroundSpawn(id: number, options?: any): AxiosPromise<string> {
            return GroundSpawnApiFp(configuration).deleteGroundSpawn(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets GroundSpawn
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroundSpawn(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsGroundSpawn>> {
            return GroundSpawnApiFp(configuration).getGroundSpawn(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists GroundSpawns
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroundSpawns(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsGroundSpawn>> {
            return GroundSpawnApiFp(configuration).listGroundSpawns(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates GroundSpawn
         * @param {number} id Id
         * @param {ModelsGroundSpawn} groundSpawn GroundSpawn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroundSpawn(id: number, groundSpawn: ModelsGroundSpawn, options?: any): AxiosPromise<Array<ModelsGroundSpawn>> {
            return GroundSpawnApiFp(configuration).updateGroundSpawn(id, groundSpawn, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createGroundSpawn operation in GroundSpawnApi.
 * @export
 * @interface GroundSpawnApiCreateGroundSpawnRequest
 */
export interface GroundSpawnApiCreateGroundSpawnRequest {
    /**
     * GroundSpawn
     * @type {ModelsGroundSpawn}
     * @memberof GroundSpawnApiCreateGroundSpawn
     */
    readonly groundSpawn: ModelsGroundSpawn
}

/**
 * Request parameters for deleteGroundSpawn operation in GroundSpawnApi.
 * @export
 * @interface GroundSpawnApiDeleteGroundSpawnRequest
 */
export interface GroundSpawnApiDeleteGroundSpawnRequest {
    /**
     * Id
     * @type {number}
     * @memberof GroundSpawnApiDeleteGroundSpawn
     */
    readonly id: number
}

/**
 * Request parameters for getGroundSpawn operation in GroundSpawnApi.
 * @export
 * @interface GroundSpawnApiGetGroundSpawnRequest
 */
export interface GroundSpawnApiGetGroundSpawnRequest {
    /**
     * Id
     * @type {number}
     * @memberof GroundSpawnApiGetGroundSpawn
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof GroundSpawnApiGetGroundSpawn
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof GroundSpawnApiGetGroundSpawn
     */
    readonly select?: string
}

/**
 * Request parameters for listGroundSpawns operation in GroundSpawnApi.
 * @export
 * @interface GroundSpawnApiListGroundSpawnsRequest
 */
export interface GroundSpawnApiListGroundSpawnsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof GroundSpawnApiListGroundSpawns
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof GroundSpawnApiListGroundSpawns
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof GroundSpawnApiListGroundSpawns
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof GroundSpawnApiListGroundSpawns
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof GroundSpawnApiListGroundSpawns
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof GroundSpawnApiListGroundSpawns
     */
    readonly select?: string
}

/**
 * Request parameters for updateGroundSpawn operation in GroundSpawnApi.
 * @export
 * @interface GroundSpawnApiUpdateGroundSpawnRequest
 */
export interface GroundSpawnApiUpdateGroundSpawnRequest {
    /**
     * Id
     * @type {number}
     * @memberof GroundSpawnApiUpdateGroundSpawn
     */
    readonly id: number

    /**
     * GroundSpawn
     * @type {ModelsGroundSpawn}
     * @memberof GroundSpawnApiUpdateGroundSpawn
     */
    readonly groundSpawn: ModelsGroundSpawn
}

/**
 * GroundSpawnApi - object-oriented interface
 * @export
 * @class GroundSpawnApi
 * @extends {BaseAPI}
 */
export class GroundSpawnApi extends BaseAPI {
    /**
     * 
     * @summary Creates GroundSpawn
     * @param {GroundSpawnApiCreateGroundSpawnRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroundSpawnApi
     */
    public createGroundSpawn(requestParameters: GroundSpawnApiCreateGroundSpawnRequest, options?: any) {
        return GroundSpawnApiFp(this.configuration).createGroundSpawn(requestParameters.groundSpawn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes GroundSpawn
     * @param {GroundSpawnApiDeleteGroundSpawnRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroundSpawnApi
     */
    public deleteGroundSpawn(requestParameters: GroundSpawnApiDeleteGroundSpawnRequest, options?: any) {
        return GroundSpawnApiFp(this.configuration).deleteGroundSpawn(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets GroundSpawn
     * @param {GroundSpawnApiGetGroundSpawnRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroundSpawnApi
     */
    public getGroundSpawn(requestParameters: GroundSpawnApiGetGroundSpawnRequest, options?: any) {
        return GroundSpawnApiFp(this.configuration).getGroundSpawn(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists GroundSpawns
     * @param {GroundSpawnApiListGroundSpawnsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroundSpawnApi
     */
    public listGroundSpawns(requestParameters: GroundSpawnApiListGroundSpawnsRequest = {}, options?: any) {
        return GroundSpawnApiFp(this.configuration).listGroundSpawns(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates GroundSpawn
     * @param {GroundSpawnApiUpdateGroundSpawnRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroundSpawnApi
     */
    public updateGroundSpawn(requestParameters: GroundSpawnApiUpdateGroundSpawnRequest, options?: any) {
        return GroundSpawnApiFp(this.configuration).updateGroundSpawn(requestParameters.id, requestParameters.groundSpawn, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GroupIdApi - axios parameter creator
 * @export
 */
export const GroupIdApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates GroupId
         * @param {ModelsGroupId} groupId GroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupId: async (groupId: ModelsGroupId, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId','Required parameter groupId was null or undefined when calling createGroupId.');
            }
            const localVarPath = `/group_id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof groupId !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(groupId !== undefined ? groupId : {})
                : (groupId || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes GroupId
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupId: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteGroupId.');
            }
            const localVarPath = `/group_id/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets GroupId
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupId: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getGroupId.');
            }
            const localVarPath = `/group_id/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists GroupIds
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroupIds: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/group_ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates GroupId
         * @param {number} id Id
         * @param {ModelsGroupId} groupId GroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupId: async (id: number, groupId: ModelsGroupId, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateGroupId.');
            }
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId','Required parameter groupId was null or undefined when calling updateGroupId.');
            }
            const localVarPath = `/group_id/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof groupId !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(groupId !== undefined ? groupId : {})
                : (groupId || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupIdApi - functional programming interface
 * @export
 */
export const GroupIdApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates GroupId
         * @param {ModelsGroupId} groupId GroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroupId(groupId: ModelsGroupId, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsGroupId>>> {
            const localVarAxiosArgs = await GroupIdApiAxiosParamCreator(configuration).createGroupId(groupId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes GroupId
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroupId(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await GroupIdApiAxiosParamCreator(configuration).deleteGroupId(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets GroupId
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupId(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsGroupId>>> {
            const localVarAxiosArgs = await GroupIdApiAxiosParamCreator(configuration).getGroupId(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists GroupIds
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGroupIds(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsGroupId>>> {
            const localVarAxiosArgs = await GroupIdApiAxiosParamCreator(configuration).listGroupIds(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates GroupId
         * @param {number} id Id
         * @param {ModelsGroupId} groupId GroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroupId(id: number, groupId: ModelsGroupId, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsGroupId>>> {
            const localVarAxiosArgs = await GroupIdApiAxiosParamCreator(configuration).updateGroupId(id, groupId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * GroupIdApi - factory interface
 * @export
 */
export const GroupIdApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates GroupId
         * @param {ModelsGroupId} groupId GroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupId(groupId: ModelsGroupId, options?: any): AxiosPromise<Array<ModelsGroupId>> {
            return GroupIdApiFp(configuration).createGroupId(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes GroupId
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupId(id: number, options?: any): AxiosPromise<string> {
            return GroupIdApiFp(configuration).deleteGroupId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets GroupId
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupId(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsGroupId>> {
            return GroupIdApiFp(configuration).getGroupId(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists GroupIds
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroupIds(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsGroupId>> {
            return GroupIdApiFp(configuration).listGroupIds(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates GroupId
         * @param {number} id Id
         * @param {ModelsGroupId} groupId GroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupId(id: number, groupId: ModelsGroupId, options?: any): AxiosPromise<Array<ModelsGroupId>> {
            return GroupIdApiFp(configuration).updateGroupId(id, groupId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createGroupId operation in GroupIdApi.
 * @export
 * @interface GroupIdApiCreateGroupIdRequest
 */
export interface GroupIdApiCreateGroupIdRequest {
    /**
     * GroupId
     * @type {ModelsGroupId}
     * @memberof GroupIdApiCreateGroupId
     */
    readonly groupId: ModelsGroupId
}

/**
 * Request parameters for deleteGroupId operation in GroupIdApi.
 * @export
 * @interface GroupIdApiDeleteGroupIdRequest
 */
export interface GroupIdApiDeleteGroupIdRequest {
    /**
     * Id
     * @type {number}
     * @memberof GroupIdApiDeleteGroupId
     */
    readonly id: number
}

/**
 * Request parameters for getGroupId operation in GroupIdApi.
 * @export
 * @interface GroupIdApiGetGroupIdRequest
 */
export interface GroupIdApiGetGroupIdRequest {
    /**
     * Id
     * @type {number}
     * @memberof GroupIdApiGetGroupId
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof GroupIdApiGetGroupId
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof GroupIdApiGetGroupId
     */
    readonly select?: string
}

/**
 * Request parameters for listGroupIds operation in GroupIdApi.
 * @export
 * @interface GroupIdApiListGroupIdsRequest
 */
export interface GroupIdApiListGroupIdsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof GroupIdApiListGroupIds
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof GroupIdApiListGroupIds
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof GroupIdApiListGroupIds
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof GroupIdApiListGroupIds
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof GroupIdApiListGroupIds
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof GroupIdApiListGroupIds
     */
    readonly select?: string
}

/**
 * Request parameters for updateGroupId operation in GroupIdApi.
 * @export
 * @interface GroupIdApiUpdateGroupIdRequest
 */
export interface GroupIdApiUpdateGroupIdRequest {
    /**
     * Id
     * @type {number}
     * @memberof GroupIdApiUpdateGroupId
     */
    readonly id: number

    /**
     * GroupId
     * @type {ModelsGroupId}
     * @memberof GroupIdApiUpdateGroupId
     */
    readonly groupId: ModelsGroupId
}

/**
 * GroupIdApi - object-oriented interface
 * @export
 * @class GroupIdApi
 * @extends {BaseAPI}
 */
export class GroupIdApi extends BaseAPI {
    /**
     * 
     * @summary Creates GroupId
     * @param {GroupIdApiCreateGroupIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupIdApi
     */
    public createGroupId(requestParameters: GroupIdApiCreateGroupIdRequest, options?: any) {
        return GroupIdApiFp(this.configuration).createGroupId(requestParameters.groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes GroupId
     * @param {GroupIdApiDeleteGroupIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupIdApi
     */
    public deleteGroupId(requestParameters: GroupIdApiDeleteGroupIdRequest, options?: any) {
        return GroupIdApiFp(this.configuration).deleteGroupId(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets GroupId
     * @param {GroupIdApiGetGroupIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupIdApi
     */
    public getGroupId(requestParameters: GroupIdApiGetGroupIdRequest, options?: any) {
        return GroupIdApiFp(this.configuration).getGroupId(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists GroupIds
     * @param {GroupIdApiListGroupIdsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupIdApi
     */
    public listGroupIds(requestParameters: GroupIdApiListGroupIdsRequest = {}, options?: any) {
        return GroupIdApiFp(this.configuration).listGroupIds(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates GroupId
     * @param {GroupIdApiUpdateGroupIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupIdApi
     */
    public updateGroupId(requestParameters: GroupIdApiUpdateGroupIdRequest, options?: any) {
        return GroupIdApiFp(this.configuration).updateGroupId(requestParameters.id, requestParameters.groupId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GuildApi - axios parameter creator
 * @export
 */
export const GuildApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Guild
         * @param {ModelsGuild} guild Guild
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGuild: async (guild: ModelsGuild, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guild' is not null or undefined
            if (guild === null || guild === undefined) {
                throw new RequiredError('guild','Required parameter guild was null or undefined when calling createGuild.');
            }
            const localVarPath = `/guild`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof guild !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(guild !== undefined ? guild : {})
                : (guild || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes Guild
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGuild: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteGuild.');
            }
            const localVarPath = `/guild/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Guild
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;GuildBanks&lt;br&gt;GuildMembers&lt;br&gt;GuildRanks
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuild: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getGuild.');
            }
            const localVarPath = `/guild/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists Guilds
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;GuildBanks&lt;br&gt;GuildMembers&lt;br&gt;GuildRanks
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGuilds: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/guilds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates Guild
         * @param {number} id Id
         * @param {ModelsGuild} guild Guild
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGuild: async (id: number, guild: ModelsGuild, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateGuild.');
            }
            // verify required parameter 'guild' is not null or undefined
            if (guild === null || guild === undefined) {
                throw new RequiredError('guild','Required parameter guild was null or undefined when calling updateGuild.');
            }
            const localVarPath = `/guild/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof guild !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(guild !== undefined ? guild : {})
                : (guild || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GuildApi - functional programming interface
 * @export
 */
export const GuildApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Guild
         * @param {ModelsGuild} guild Guild
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGuild(guild: ModelsGuild, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsGuild>>> {
            const localVarAxiosArgs = await GuildApiAxiosParamCreator(configuration).createGuild(guild, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes Guild
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGuild(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await GuildApiAxiosParamCreator(configuration).deleteGuild(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Guild
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;GuildBanks&lt;br&gt;GuildMembers&lt;br&gt;GuildRanks
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGuild(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsGuild>>> {
            const localVarAxiosArgs = await GuildApiAxiosParamCreator(configuration).getGuild(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists Guilds
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;GuildBanks&lt;br&gt;GuildMembers&lt;br&gt;GuildRanks
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGuilds(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsGuild>>> {
            const localVarAxiosArgs = await GuildApiAxiosParamCreator(configuration).listGuilds(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates Guild
         * @param {number} id Id
         * @param {ModelsGuild} guild Guild
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGuild(id: number, guild: ModelsGuild, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsGuild>>> {
            const localVarAxiosArgs = await GuildApiAxiosParamCreator(configuration).updateGuild(id, guild, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * GuildApi - factory interface
 * @export
 */
export const GuildApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates Guild
         * @param {ModelsGuild} guild Guild
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGuild(guild: ModelsGuild, options?: any): AxiosPromise<Array<ModelsGuild>> {
            return GuildApiFp(configuration).createGuild(guild, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes Guild
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGuild(id: number, options?: any): AxiosPromise<string> {
            return GuildApiFp(configuration).deleteGuild(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Guild
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;GuildBanks&lt;br&gt;GuildMembers&lt;br&gt;GuildRanks
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuild(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsGuild>> {
            return GuildApiFp(configuration).getGuild(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists Guilds
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;GuildBanks&lt;br&gt;GuildMembers&lt;br&gt;GuildRanks
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGuilds(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsGuild>> {
            return GuildApiFp(configuration).listGuilds(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates Guild
         * @param {number} id Id
         * @param {ModelsGuild} guild Guild
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGuild(id: number, guild: ModelsGuild, options?: any): AxiosPromise<Array<ModelsGuild>> {
            return GuildApiFp(configuration).updateGuild(id, guild, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createGuild operation in GuildApi.
 * @export
 * @interface GuildApiCreateGuildRequest
 */
export interface GuildApiCreateGuildRequest {
    /**
     * Guild
     * @type {ModelsGuild}
     * @memberof GuildApiCreateGuild
     */
    readonly guild: ModelsGuild
}

/**
 * Request parameters for deleteGuild operation in GuildApi.
 * @export
 * @interface GuildApiDeleteGuildRequest
 */
export interface GuildApiDeleteGuildRequest {
    /**
     * Id
     * @type {number}
     * @memberof GuildApiDeleteGuild
     */
    readonly id: number
}

/**
 * Request parameters for getGuild operation in GuildApi.
 * @export
 * @interface GuildApiGetGuildRequest
 */
export interface GuildApiGetGuildRequest {
    /**
     * Id
     * @type {number}
     * @memberof GuildApiGetGuild
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;GuildBanks&lt;br&gt;GuildMembers&lt;br&gt;GuildRanks
     * @type {string}
     * @memberof GuildApiGetGuild
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof GuildApiGetGuild
     */
    readonly select?: string
}

/**
 * Request parameters for listGuilds operation in GuildApi.
 * @export
 * @interface GuildApiListGuildsRequest
 */
export interface GuildApiListGuildsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;GuildBanks&lt;br&gt;GuildMembers&lt;br&gt;GuildRanks
     * @type {string}
     * @memberof GuildApiListGuilds
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof GuildApiListGuilds
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof GuildApiListGuilds
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof GuildApiListGuilds
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof GuildApiListGuilds
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof GuildApiListGuilds
     */
    readonly select?: string
}

/**
 * Request parameters for updateGuild operation in GuildApi.
 * @export
 * @interface GuildApiUpdateGuildRequest
 */
export interface GuildApiUpdateGuildRequest {
    /**
     * Id
     * @type {number}
     * @memberof GuildApiUpdateGuild
     */
    readonly id: number

    /**
     * Guild
     * @type {ModelsGuild}
     * @memberof GuildApiUpdateGuild
     */
    readonly guild: ModelsGuild
}

/**
 * GuildApi - object-oriented interface
 * @export
 * @class GuildApi
 * @extends {BaseAPI}
 */
export class GuildApi extends BaseAPI {
    /**
     * 
     * @summary Creates Guild
     * @param {GuildApiCreateGuildRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuildApi
     */
    public createGuild(requestParameters: GuildApiCreateGuildRequest, options?: any) {
        return GuildApiFp(this.configuration).createGuild(requestParameters.guild, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes Guild
     * @param {GuildApiDeleteGuildRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuildApi
     */
    public deleteGuild(requestParameters: GuildApiDeleteGuildRequest, options?: any) {
        return GuildApiFp(this.configuration).deleteGuild(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Guild
     * @param {GuildApiGetGuildRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuildApi
     */
    public getGuild(requestParameters: GuildApiGetGuildRequest, options?: any) {
        return GuildApiFp(this.configuration).getGuild(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists Guilds
     * @param {GuildApiListGuildsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuildApi
     */
    public listGuilds(requestParameters: GuildApiListGuildsRequest = {}, options?: any) {
        return GuildApiFp(this.configuration).listGuilds(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates Guild
     * @param {GuildApiUpdateGuildRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuildApi
     */
    public updateGuild(requestParameters: GuildApiUpdateGuildRequest, options?: any) {
        return GuildApiFp(this.configuration).updateGuild(requestParameters.id, requestParameters.guild, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GuildMemberApi - axios parameter creator
 * @export
 */
export const GuildMemberApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates GuildMember
         * @param {ModelsGuildMember} guildMember GuildMember
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGuildMember: async (guildMember: ModelsGuildMember, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildMember' is not null or undefined
            if (guildMember === null || guildMember === undefined) {
                throw new RequiredError('guildMember','Required parameter guildMember was null or undefined when calling createGuildMember.');
            }
            const localVarPath = `/guild_member`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof guildMember !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(guildMember !== undefined ? guildMember : {})
                : (guildMember || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes GuildMember
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGuildMember: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteGuildMember.');
            }
            const localVarPath = `/guild_member/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets GuildMember
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuildMember: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getGuildMember.');
            }
            const localVarPath = `/guild_member/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists GuildMembers
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGuildMembers: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/guild_members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates GuildMember
         * @param {number} id Id
         * @param {ModelsGuildMember} guildMember GuildMember
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGuildMember: async (id: number, guildMember: ModelsGuildMember, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateGuildMember.');
            }
            // verify required parameter 'guildMember' is not null or undefined
            if (guildMember === null || guildMember === undefined) {
                throw new RequiredError('guildMember','Required parameter guildMember was null or undefined when calling updateGuildMember.');
            }
            const localVarPath = `/guild_member/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof guildMember !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(guildMember !== undefined ? guildMember : {})
                : (guildMember || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GuildMemberApi - functional programming interface
 * @export
 */
export const GuildMemberApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates GuildMember
         * @param {ModelsGuildMember} guildMember GuildMember
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGuildMember(guildMember: ModelsGuildMember, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsGuildMember>>> {
            const localVarAxiosArgs = await GuildMemberApiAxiosParamCreator(configuration).createGuildMember(guildMember, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes GuildMember
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGuildMember(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await GuildMemberApiAxiosParamCreator(configuration).deleteGuildMember(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets GuildMember
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGuildMember(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsGuildMember>>> {
            const localVarAxiosArgs = await GuildMemberApiAxiosParamCreator(configuration).getGuildMember(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists GuildMembers
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGuildMembers(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsGuildMember>>> {
            const localVarAxiosArgs = await GuildMemberApiAxiosParamCreator(configuration).listGuildMembers(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates GuildMember
         * @param {number} id Id
         * @param {ModelsGuildMember} guildMember GuildMember
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGuildMember(id: number, guildMember: ModelsGuildMember, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsGuildMember>>> {
            const localVarAxiosArgs = await GuildMemberApiAxiosParamCreator(configuration).updateGuildMember(id, guildMember, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * GuildMemberApi - factory interface
 * @export
 */
export const GuildMemberApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates GuildMember
         * @param {ModelsGuildMember} guildMember GuildMember
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGuildMember(guildMember: ModelsGuildMember, options?: any): AxiosPromise<Array<ModelsGuildMember>> {
            return GuildMemberApiFp(configuration).createGuildMember(guildMember, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes GuildMember
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGuildMember(id: number, options?: any): AxiosPromise<string> {
            return GuildMemberApiFp(configuration).deleteGuildMember(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets GuildMember
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuildMember(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsGuildMember>> {
            return GuildMemberApiFp(configuration).getGuildMember(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists GuildMembers
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGuildMembers(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsGuildMember>> {
            return GuildMemberApiFp(configuration).listGuildMembers(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates GuildMember
         * @param {number} id Id
         * @param {ModelsGuildMember} guildMember GuildMember
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGuildMember(id: number, guildMember: ModelsGuildMember, options?: any): AxiosPromise<Array<ModelsGuildMember>> {
            return GuildMemberApiFp(configuration).updateGuildMember(id, guildMember, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createGuildMember operation in GuildMemberApi.
 * @export
 * @interface GuildMemberApiCreateGuildMemberRequest
 */
export interface GuildMemberApiCreateGuildMemberRequest {
    /**
     * GuildMember
     * @type {ModelsGuildMember}
     * @memberof GuildMemberApiCreateGuildMember
     */
    readonly guildMember: ModelsGuildMember
}

/**
 * Request parameters for deleteGuildMember operation in GuildMemberApi.
 * @export
 * @interface GuildMemberApiDeleteGuildMemberRequest
 */
export interface GuildMemberApiDeleteGuildMemberRequest {
    /**
     * Id
     * @type {number}
     * @memberof GuildMemberApiDeleteGuildMember
     */
    readonly id: number
}

/**
 * Request parameters for getGuildMember operation in GuildMemberApi.
 * @export
 * @interface GuildMemberApiGetGuildMemberRequest
 */
export interface GuildMemberApiGetGuildMemberRequest {
    /**
     * Id
     * @type {number}
     * @memberof GuildMemberApiGetGuildMember
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof GuildMemberApiGetGuildMember
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof GuildMemberApiGetGuildMember
     */
    readonly select?: string
}

/**
 * Request parameters for listGuildMembers operation in GuildMemberApi.
 * @export
 * @interface GuildMemberApiListGuildMembersRequest
 */
export interface GuildMemberApiListGuildMembersRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof GuildMemberApiListGuildMembers
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof GuildMemberApiListGuildMembers
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof GuildMemberApiListGuildMembers
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof GuildMemberApiListGuildMembers
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof GuildMemberApiListGuildMembers
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof GuildMemberApiListGuildMembers
     */
    readonly select?: string
}

/**
 * Request parameters for updateGuildMember operation in GuildMemberApi.
 * @export
 * @interface GuildMemberApiUpdateGuildMemberRequest
 */
export interface GuildMemberApiUpdateGuildMemberRequest {
    /**
     * Id
     * @type {number}
     * @memberof GuildMemberApiUpdateGuildMember
     */
    readonly id: number

    /**
     * GuildMember
     * @type {ModelsGuildMember}
     * @memberof GuildMemberApiUpdateGuildMember
     */
    readonly guildMember: ModelsGuildMember
}

/**
 * GuildMemberApi - object-oriented interface
 * @export
 * @class GuildMemberApi
 * @extends {BaseAPI}
 */
export class GuildMemberApi extends BaseAPI {
    /**
     * 
     * @summary Creates GuildMember
     * @param {GuildMemberApiCreateGuildMemberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuildMemberApi
     */
    public createGuildMember(requestParameters: GuildMemberApiCreateGuildMemberRequest, options?: any) {
        return GuildMemberApiFp(this.configuration).createGuildMember(requestParameters.guildMember, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes GuildMember
     * @param {GuildMemberApiDeleteGuildMemberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuildMemberApi
     */
    public deleteGuildMember(requestParameters: GuildMemberApiDeleteGuildMemberRequest, options?: any) {
        return GuildMemberApiFp(this.configuration).deleteGuildMember(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets GuildMember
     * @param {GuildMemberApiGetGuildMemberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuildMemberApi
     */
    public getGuildMember(requestParameters: GuildMemberApiGetGuildMemberRequest, options?: any) {
        return GuildMemberApiFp(this.configuration).getGuildMember(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists GuildMembers
     * @param {GuildMemberApiListGuildMembersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuildMemberApi
     */
    public listGuildMembers(requestParameters: GuildMemberApiListGuildMembersRequest = {}, options?: any) {
        return GuildMemberApiFp(this.configuration).listGuildMembers(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates GuildMember
     * @param {GuildMemberApiUpdateGuildMemberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuildMemberApi
     */
    public updateGuildMember(requestParameters: GuildMemberApiUpdateGuildMemberRequest, options?: any) {
        return GuildMemberApiFp(this.configuration).updateGuildMember(requestParameters.id, requestParameters.guildMember, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HackerApi - axios parameter creator
 * @export
 */
export const HackerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Hacker
         * @param {ModelsHacker} hacker Hacker
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHacker: async (hacker: ModelsHacker, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hacker' is not null or undefined
            if (hacker === null || hacker === undefined) {
                throw new RequiredError('hacker','Required parameter hacker was null or undefined when calling createHacker.');
            }
            const localVarPath = `/hacker`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof hacker !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(hacker !== undefined ? hacker : {})
                : (hacker || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes Hacker
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHacker: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteHacker.');
            }
            const localVarPath = `/hacker/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Hacker
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHacker: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getHacker.');
            }
            const localVarPath = `/hacker/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists Hackers
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHackers: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/hackers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates Hacker
         * @param {number} id Id
         * @param {ModelsHacker} hacker Hacker
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHacker: async (id: number, hacker: ModelsHacker, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateHacker.');
            }
            // verify required parameter 'hacker' is not null or undefined
            if (hacker === null || hacker === undefined) {
                throw new RequiredError('hacker','Required parameter hacker was null or undefined when calling updateHacker.');
            }
            const localVarPath = `/hacker/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof hacker !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(hacker !== undefined ? hacker : {})
                : (hacker || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HackerApi - functional programming interface
 * @export
 */
export const HackerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Hacker
         * @param {ModelsHacker} hacker Hacker
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHacker(hacker: ModelsHacker, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsHacker>>> {
            const localVarAxiosArgs = await HackerApiAxiosParamCreator(configuration).createHacker(hacker, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes Hacker
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteHacker(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await HackerApiAxiosParamCreator(configuration).deleteHacker(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Hacker
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHacker(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsHacker>>> {
            const localVarAxiosArgs = await HackerApiAxiosParamCreator(configuration).getHacker(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists Hackers
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listHackers(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsHacker>>> {
            const localVarAxiosArgs = await HackerApiAxiosParamCreator(configuration).listHackers(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates Hacker
         * @param {number} id Id
         * @param {ModelsHacker} hacker Hacker
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateHacker(id: number, hacker: ModelsHacker, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsHacker>>> {
            const localVarAxiosArgs = await HackerApiAxiosParamCreator(configuration).updateHacker(id, hacker, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * HackerApi - factory interface
 * @export
 */
export const HackerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates Hacker
         * @param {ModelsHacker} hacker Hacker
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHacker(hacker: ModelsHacker, options?: any): AxiosPromise<Array<ModelsHacker>> {
            return HackerApiFp(configuration).createHacker(hacker, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes Hacker
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHacker(id: number, options?: any): AxiosPromise<string> {
            return HackerApiFp(configuration).deleteHacker(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Hacker
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHacker(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsHacker>> {
            return HackerApiFp(configuration).getHacker(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists Hackers
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHackers(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsHacker>> {
            return HackerApiFp(configuration).listHackers(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates Hacker
         * @param {number} id Id
         * @param {ModelsHacker} hacker Hacker
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHacker(id: number, hacker: ModelsHacker, options?: any): AxiosPromise<Array<ModelsHacker>> {
            return HackerApiFp(configuration).updateHacker(id, hacker, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createHacker operation in HackerApi.
 * @export
 * @interface HackerApiCreateHackerRequest
 */
export interface HackerApiCreateHackerRequest {
    /**
     * Hacker
     * @type {ModelsHacker}
     * @memberof HackerApiCreateHacker
     */
    readonly hacker: ModelsHacker
}

/**
 * Request parameters for deleteHacker operation in HackerApi.
 * @export
 * @interface HackerApiDeleteHackerRequest
 */
export interface HackerApiDeleteHackerRequest {
    /**
     * Id
     * @type {number}
     * @memberof HackerApiDeleteHacker
     */
    readonly id: number
}

/**
 * Request parameters for getHacker operation in HackerApi.
 * @export
 * @interface HackerApiGetHackerRequest
 */
export interface HackerApiGetHackerRequest {
    /**
     * Id
     * @type {number}
     * @memberof HackerApiGetHacker
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof HackerApiGetHacker
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof HackerApiGetHacker
     */
    readonly select?: string
}

/**
 * Request parameters for listHackers operation in HackerApi.
 * @export
 * @interface HackerApiListHackersRequest
 */
export interface HackerApiListHackersRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof HackerApiListHackers
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof HackerApiListHackers
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof HackerApiListHackers
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof HackerApiListHackers
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof HackerApiListHackers
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof HackerApiListHackers
     */
    readonly select?: string
}

/**
 * Request parameters for updateHacker operation in HackerApi.
 * @export
 * @interface HackerApiUpdateHackerRequest
 */
export interface HackerApiUpdateHackerRequest {
    /**
     * Id
     * @type {number}
     * @memberof HackerApiUpdateHacker
     */
    readonly id: number

    /**
     * Hacker
     * @type {ModelsHacker}
     * @memberof HackerApiUpdateHacker
     */
    readonly hacker: ModelsHacker
}

/**
 * HackerApi - object-oriented interface
 * @export
 * @class HackerApi
 * @extends {BaseAPI}
 */
export class HackerApi extends BaseAPI {
    /**
     * 
     * @summary Creates Hacker
     * @param {HackerApiCreateHackerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HackerApi
     */
    public createHacker(requestParameters: HackerApiCreateHackerRequest, options?: any) {
        return HackerApiFp(this.configuration).createHacker(requestParameters.hacker, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes Hacker
     * @param {HackerApiDeleteHackerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HackerApi
     */
    public deleteHacker(requestParameters: HackerApiDeleteHackerRequest, options?: any) {
        return HackerApiFp(this.configuration).deleteHacker(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Hacker
     * @param {HackerApiGetHackerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HackerApi
     */
    public getHacker(requestParameters: HackerApiGetHackerRequest, options?: any) {
        return HackerApiFp(this.configuration).getHacker(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists Hackers
     * @param {HackerApiListHackersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HackerApi
     */
    public listHackers(requestParameters: HackerApiListHackersRequest = {}, options?: any) {
        return HackerApiFp(this.configuration).listHackers(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates Hacker
     * @param {HackerApiUpdateHackerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HackerApi
     */
    public updateHacker(requestParameters: HackerApiUpdateHackerRequest, options?: any) {
        return HackerApiFp(this.configuration).updateHacker(requestParameters.id, requestParameters.hacker, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InstanceListApi - axios parameter creator
 * @export
 */
export const InstanceListApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates InstanceList
         * @param {ModelsInstanceList} instanceList InstanceList
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInstanceList: async (instanceList: ModelsInstanceList, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceList' is not null or undefined
            if (instanceList === null || instanceList === undefined) {
                throw new RequiredError('instanceList','Required parameter instanceList was null or undefined when calling createInstanceList.');
            }
            const localVarPath = `/instance_list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof instanceList !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(instanceList !== undefined ? instanceList : {})
                : (instanceList || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes InstanceList
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInstanceList: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteInstanceList.');
            }
            const localVarPath = `/instance_list/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets InstanceList
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;InstanceListPlayers&lt;br&gt;Zones
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceList: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getInstanceList.');
            }
            const localVarPath = `/instance_list/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists InstanceLists
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;InstanceListPlayers&lt;br&gt;Zones
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInstanceLists: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/instance_lists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates InstanceList
         * @param {number} id Id
         * @param {ModelsInstanceList} instanceList InstanceList
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInstanceList: async (id: number, instanceList: ModelsInstanceList, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateInstanceList.');
            }
            // verify required parameter 'instanceList' is not null or undefined
            if (instanceList === null || instanceList === undefined) {
                throw new RequiredError('instanceList','Required parameter instanceList was null or undefined when calling updateInstanceList.');
            }
            const localVarPath = `/instance_list/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof instanceList !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(instanceList !== undefined ? instanceList : {})
                : (instanceList || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InstanceListApi - functional programming interface
 * @export
 */
export const InstanceListApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates InstanceList
         * @param {ModelsInstanceList} instanceList InstanceList
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInstanceList(instanceList: ModelsInstanceList, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsInstanceList>>> {
            const localVarAxiosArgs = await InstanceListApiAxiosParamCreator(configuration).createInstanceList(instanceList, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes InstanceList
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInstanceList(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await InstanceListApiAxiosParamCreator(configuration).deleteInstanceList(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets InstanceList
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;InstanceListPlayers&lt;br&gt;Zones
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstanceList(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsInstanceList>>> {
            const localVarAxiosArgs = await InstanceListApiAxiosParamCreator(configuration).getInstanceList(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists InstanceLists
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;InstanceListPlayers&lt;br&gt;Zones
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInstanceLists(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsInstanceList>>> {
            const localVarAxiosArgs = await InstanceListApiAxiosParamCreator(configuration).listInstanceLists(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates InstanceList
         * @param {number} id Id
         * @param {ModelsInstanceList} instanceList InstanceList
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateInstanceList(id: number, instanceList: ModelsInstanceList, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsInstanceList>>> {
            const localVarAxiosArgs = await InstanceListApiAxiosParamCreator(configuration).updateInstanceList(id, instanceList, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * InstanceListApi - factory interface
 * @export
 */
export const InstanceListApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates InstanceList
         * @param {ModelsInstanceList} instanceList InstanceList
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInstanceList(instanceList: ModelsInstanceList, options?: any): AxiosPromise<Array<ModelsInstanceList>> {
            return InstanceListApiFp(configuration).createInstanceList(instanceList, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes InstanceList
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInstanceList(id: number, options?: any): AxiosPromise<string> {
            return InstanceListApiFp(configuration).deleteInstanceList(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets InstanceList
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;InstanceListPlayers&lt;br&gt;Zones
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceList(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsInstanceList>> {
            return InstanceListApiFp(configuration).getInstanceList(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists InstanceLists
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;InstanceListPlayers&lt;br&gt;Zones
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInstanceLists(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsInstanceList>> {
            return InstanceListApiFp(configuration).listInstanceLists(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates InstanceList
         * @param {number} id Id
         * @param {ModelsInstanceList} instanceList InstanceList
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInstanceList(id: number, instanceList: ModelsInstanceList, options?: any): AxiosPromise<Array<ModelsInstanceList>> {
            return InstanceListApiFp(configuration).updateInstanceList(id, instanceList, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createInstanceList operation in InstanceListApi.
 * @export
 * @interface InstanceListApiCreateInstanceListRequest
 */
export interface InstanceListApiCreateInstanceListRequest {
    /**
     * InstanceList
     * @type {ModelsInstanceList}
     * @memberof InstanceListApiCreateInstanceList
     */
    readonly instanceList: ModelsInstanceList
}

/**
 * Request parameters for deleteInstanceList operation in InstanceListApi.
 * @export
 * @interface InstanceListApiDeleteInstanceListRequest
 */
export interface InstanceListApiDeleteInstanceListRequest {
    /**
     * Id
     * @type {number}
     * @memberof InstanceListApiDeleteInstanceList
     */
    readonly id: number
}

/**
 * Request parameters for getInstanceList operation in InstanceListApi.
 * @export
 * @interface InstanceListApiGetInstanceListRequest
 */
export interface InstanceListApiGetInstanceListRequest {
    /**
     * Id
     * @type {number}
     * @memberof InstanceListApiGetInstanceList
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;InstanceListPlayers&lt;br&gt;Zones
     * @type {string}
     * @memberof InstanceListApiGetInstanceList
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof InstanceListApiGetInstanceList
     */
    readonly select?: string
}

/**
 * Request parameters for listInstanceLists operation in InstanceListApi.
 * @export
 * @interface InstanceListApiListInstanceListsRequest
 */
export interface InstanceListApiListInstanceListsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;InstanceListPlayers&lt;br&gt;Zones
     * @type {string}
     * @memberof InstanceListApiListInstanceLists
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof InstanceListApiListInstanceLists
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof InstanceListApiListInstanceLists
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof InstanceListApiListInstanceLists
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof InstanceListApiListInstanceLists
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof InstanceListApiListInstanceLists
     */
    readonly select?: string
}

/**
 * Request parameters for updateInstanceList operation in InstanceListApi.
 * @export
 * @interface InstanceListApiUpdateInstanceListRequest
 */
export interface InstanceListApiUpdateInstanceListRequest {
    /**
     * Id
     * @type {number}
     * @memberof InstanceListApiUpdateInstanceList
     */
    readonly id: number

    /**
     * InstanceList
     * @type {ModelsInstanceList}
     * @memberof InstanceListApiUpdateInstanceList
     */
    readonly instanceList: ModelsInstanceList
}

/**
 * InstanceListApi - object-oriented interface
 * @export
 * @class InstanceListApi
 * @extends {BaseAPI}
 */
export class InstanceListApi extends BaseAPI {
    /**
     * 
     * @summary Creates InstanceList
     * @param {InstanceListApiCreateInstanceListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstanceListApi
     */
    public createInstanceList(requestParameters: InstanceListApiCreateInstanceListRequest, options?: any) {
        return InstanceListApiFp(this.configuration).createInstanceList(requestParameters.instanceList, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes InstanceList
     * @param {InstanceListApiDeleteInstanceListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstanceListApi
     */
    public deleteInstanceList(requestParameters: InstanceListApiDeleteInstanceListRequest, options?: any) {
        return InstanceListApiFp(this.configuration).deleteInstanceList(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets InstanceList
     * @param {InstanceListApiGetInstanceListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstanceListApi
     */
    public getInstanceList(requestParameters: InstanceListApiGetInstanceListRequest, options?: any) {
        return InstanceListApiFp(this.configuration).getInstanceList(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists InstanceLists
     * @param {InstanceListApiListInstanceListsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstanceListApi
     */
    public listInstanceLists(requestParameters: InstanceListApiListInstanceListsRequest = {}, options?: any) {
        return InstanceListApiFp(this.configuration).listInstanceLists(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates InstanceList
     * @param {InstanceListApiUpdateInstanceListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstanceListApi
     */
    public updateInstanceList(requestParameters: InstanceListApiUpdateInstanceListRequest, options?: any) {
        return InstanceListApiFp(this.configuration).updateInstanceList(requestParameters.id, requestParameters.instanceList, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InstanceListPlayerApi - axios parameter creator
 * @export
 */
export const InstanceListPlayerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates InstanceListPlayer
         * @param {ModelsInstanceListPlayer} instanceListPlayer InstanceListPlayer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInstanceListPlayer: async (instanceListPlayer: ModelsInstanceListPlayer, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceListPlayer' is not null or undefined
            if (instanceListPlayer === null || instanceListPlayer === undefined) {
                throw new RequiredError('instanceListPlayer','Required parameter instanceListPlayer was null or undefined when calling createInstanceListPlayer.');
            }
            const localVarPath = `/instance_list_player`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof instanceListPlayer !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(instanceListPlayer !== undefined ? instanceListPlayer : {})
                : (instanceListPlayer || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes InstanceListPlayer
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInstanceListPlayer: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteInstanceListPlayer.');
            }
            const localVarPath = `/instance_list_player/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets InstanceListPlayer
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceListPlayer: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getInstanceListPlayer.');
            }
            const localVarPath = `/instance_list_player/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists InstanceListPlayers
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInstanceListPlayers: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/instance_list_players`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates InstanceListPlayer
         * @param {number} id Id
         * @param {ModelsInstanceListPlayer} instanceListPlayer InstanceListPlayer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInstanceListPlayer: async (id: number, instanceListPlayer: ModelsInstanceListPlayer, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateInstanceListPlayer.');
            }
            // verify required parameter 'instanceListPlayer' is not null or undefined
            if (instanceListPlayer === null || instanceListPlayer === undefined) {
                throw new RequiredError('instanceListPlayer','Required parameter instanceListPlayer was null or undefined when calling updateInstanceListPlayer.');
            }
            const localVarPath = `/instance_list_player/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof instanceListPlayer !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(instanceListPlayer !== undefined ? instanceListPlayer : {})
                : (instanceListPlayer || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InstanceListPlayerApi - functional programming interface
 * @export
 */
export const InstanceListPlayerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates InstanceListPlayer
         * @param {ModelsInstanceListPlayer} instanceListPlayer InstanceListPlayer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInstanceListPlayer(instanceListPlayer: ModelsInstanceListPlayer, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsInstanceListPlayer>>> {
            const localVarAxiosArgs = await InstanceListPlayerApiAxiosParamCreator(configuration).createInstanceListPlayer(instanceListPlayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes InstanceListPlayer
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInstanceListPlayer(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await InstanceListPlayerApiAxiosParamCreator(configuration).deleteInstanceListPlayer(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets InstanceListPlayer
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstanceListPlayer(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsInstanceListPlayer>>> {
            const localVarAxiosArgs = await InstanceListPlayerApiAxiosParamCreator(configuration).getInstanceListPlayer(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists InstanceListPlayers
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInstanceListPlayers(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsInstanceListPlayer>>> {
            const localVarAxiosArgs = await InstanceListPlayerApiAxiosParamCreator(configuration).listInstanceListPlayers(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates InstanceListPlayer
         * @param {number} id Id
         * @param {ModelsInstanceListPlayer} instanceListPlayer InstanceListPlayer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateInstanceListPlayer(id: number, instanceListPlayer: ModelsInstanceListPlayer, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsInstanceListPlayer>>> {
            const localVarAxiosArgs = await InstanceListPlayerApiAxiosParamCreator(configuration).updateInstanceListPlayer(id, instanceListPlayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * InstanceListPlayerApi - factory interface
 * @export
 */
export const InstanceListPlayerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates InstanceListPlayer
         * @param {ModelsInstanceListPlayer} instanceListPlayer InstanceListPlayer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInstanceListPlayer(instanceListPlayer: ModelsInstanceListPlayer, options?: any): AxiosPromise<Array<ModelsInstanceListPlayer>> {
            return InstanceListPlayerApiFp(configuration).createInstanceListPlayer(instanceListPlayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes InstanceListPlayer
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInstanceListPlayer(id: number, options?: any): AxiosPromise<string> {
            return InstanceListPlayerApiFp(configuration).deleteInstanceListPlayer(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets InstanceListPlayer
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceListPlayer(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsInstanceListPlayer>> {
            return InstanceListPlayerApiFp(configuration).getInstanceListPlayer(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists InstanceListPlayers
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInstanceListPlayers(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsInstanceListPlayer>> {
            return InstanceListPlayerApiFp(configuration).listInstanceListPlayers(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates InstanceListPlayer
         * @param {number} id Id
         * @param {ModelsInstanceListPlayer} instanceListPlayer InstanceListPlayer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInstanceListPlayer(id: number, instanceListPlayer: ModelsInstanceListPlayer, options?: any): AxiosPromise<Array<ModelsInstanceListPlayer>> {
            return InstanceListPlayerApiFp(configuration).updateInstanceListPlayer(id, instanceListPlayer, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createInstanceListPlayer operation in InstanceListPlayerApi.
 * @export
 * @interface InstanceListPlayerApiCreateInstanceListPlayerRequest
 */
export interface InstanceListPlayerApiCreateInstanceListPlayerRequest {
    /**
     * InstanceListPlayer
     * @type {ModelsInstanceListPlayer}
     * @memberof InstanceListPlayerApiCreateInstanceListPlayer
     */
    readonly instanceListPlayer: ModelsInstanceListPlayer
}

/**
 * Request parameters for deleteInstanceListPlayer operation in InstanceListPlayerApi.
 * @export
 * @interface InstanceListPlayerApiDeleteInstanceListPlayerRequest
 */
export interface InstanceListPlayerApiDeleteInstanceListPlayerRequest {
    /**
     * Id
     * @type {number}
     * @memberof InstanceListPlayerApiDeleteInstanceListPlayer
     */
    readonly id: number
}

/**
 * Request parameters for getInstanceListPlayer operation in InstanceListPlayerApi.
 * @export
 * @interface InstanceListPlayerApiGetInstanceListPlayerRequest
 */
export interface InstanceListPlayerApiGetInstanceListPlayerRequest {
    /**
     * Id
     * @type {number}
     * @memberof InstanceListPlayerApiGetInstanceListPlayer
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof InstanceListPlayerApiGetInstanceListPlayer
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof InstanceListPlayerApiGetInstanceListPlayer
     */
    readonly select?: string
}

/**
 * Request parameters for listInstanceListPlayers operation in InstanceListPlayerApi.
 * @export
 * @interface InstanceListPlayerApiListInstanceListPlayersRequest
 */
export interface InstanceListPlayerApiListInstanceListPlayersRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof InstanceListPlayerApiListInstanceListPlayers
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof InstanceListPlayerApiListInstanceListPlayers
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof InstanceListPlayerApiListInstanceListPlayers
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof InstanceListPlayerApiListInstanceListPlayers
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof InstanceListPlayerApiListInstanceListPlayers
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof InstanceListPlayerApiListInstanceListPlayers
     */
    readonly select?: string
}

/**
 * Request parameters for updateInstanceListPlayer operation in InstanceListPlayerApi.
 * @export
 * @interface InstanceListPlayerApiUpdateInstanceListPlayerRequest
 */
export interface InstanceListPlayerApiUpdateInstanceListPlayerRequest {
    /**
     * Id
     * @type {number}
     * @memberof InstanceListPlayerApiUpdateInstanceListPlayer
     */
    readonly id: number

    /**
     * InstanceListPlayer
     * @type {ModelsInstanceListPlayer}
     * @memberof InstanceListPlayerApiUpdateInstanceListPlayer
     */
    readonly instanceListPlayer: ModelsInstanceListPlayer
}

/**
 * InstanceListPlayerApi - object-oriented interface
 * @export
 * @class InstanceListPlayerApi
 * @extends {BaseAPI}
 */
export class InstanceListPlayerApi extends BaseAPI {
    /**
     * 
     * @summary Creates InstanceListPlayer
     * @param {InstanceListPlayerApiCreateInstanceListPlayerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstanceListPlayerApi
     */
    public createInstanceListPlayer(requestParameters: InstanceListPlayerApiCreateInstanceListPlayerRequest, options?: any) {
        return InstanceListPlayerApiFp(this.configuration).createInstanceListPlayer(requestParameters.instanceListPlayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes InstanceListPlayer
     * @param {InstanceListPlayerApiDeleteInstanceListPlayerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstanceListPlayerApi
     */
    public deleteInstanceListPlayer(requestParameters: InstanceListPlayerApiDeleteInstanceListPlayerRequest, options?: any) {
        return InstanceListPlayerApiFp(this.configuration).deleteInstanceListPlayer(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets InstanceListPlayer
     * @param {InstanceListPlayerApiGetInstanceListPlayerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstanceListPlayerApi
     */
    public getInstanceListPlayer(requestParameters: InstanceListPlayerApiGetInstanceListPlayerRequest, options?: any) {
        return InstanceListPlayerApiFp(this.configuration).getInstanceListPlayer(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists InstanceListPlayers
     * @param {InstanceListPlayerApiListInstanceListPlayersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstanceListPlayerApi
     */
    public listInstanceListPlayers(requestParameters: InstanceListPlayerApiListInstanceListPlayersRequest = {}, options?: any) {
        return InstanceListPlayerApiFp(this.configuration).listInstanceListPlayers(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates InstanceListPlayer
     * @param {InstanceListPlayerApiUpdateInstanceListPlayerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstanceListPlayerApi
     */
    public updateInstanceListPlayer(requestParameters: InstanceListPlayerApiUpdateInstanceListPlayerRequest, options?: any) {
        return InstanceListPlayerApiFp(this.configuration).updateInstanceListPlayer(requestParameters.id, requestParameters.instanceListPlayer, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IpExemptionApi - axios parameter creator
 * @export
 */
export const IpExemptionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates IpExemption
         * @param {ModelsIpExemption} ipExemption IpExemption
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIpExemption: async (ipExemption: ModelsIpExemption, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ipExemption' is not null or undefined
            if (ipExemption === null || ipExemption === undefined) {
                throw new RequiredError('ipExemption','Required parameter ipExemption was null or undefined when calling createIpExemption.');
            }
            const localVarPath = `/ip_exemption`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof ipExemption !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(ipExemption !== undefined ? ipExemption : {})
                : (ipExemption || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes IpExemption
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIpExemption: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteIpExemption.');
            }
            const localVarPath = `/ip_exemption/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets IpExemption
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIpExemption: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getIpExemption.');
            }
            const localVarPath = `/ip_exemption/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists IpExemptions
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIpExemptions: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ip_exemptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates IpExemption
         * @param {number} id Id
         * @param {ModelsIpExemption} ipExemption IpExemption
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIpExemption: async (id: number, ipExemption: ModelsIpExemption, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateIpExemption.');
            }
            // verify required parameter 'ipExemption' is not null or undefined
            if (ipExemption === null || ipExemption === undefined) {
                throw new RequiredError('ipExemption','Required parameter ipExemption was null or undefined when calling updateIpExemption.');
            }
            const localVarPath = `/ip_exemption/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof ipExemption !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(ipExemption !== undefined ? ipExemption : {})
                : (ipExemption || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IpExemptionApi - functional programming interface
 * @export
 */
export const IpExemptionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates IpExemption
         * @param {ModelsIpExemption} ipExemption IpExemption
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createIpExemption(ipExemption: ModelsIpExemption, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsIpExemption>>> {
            const localVarAxiosArgs = await IpExemptionApiAxiosParamCreator(configuration).createIpExemption(ipExemption, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes IpExemption
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteIpExemption(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await IpExemptionApiAxiosParamCreator(configuration).deleteIpExemption(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets IpExemption
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIpExemption(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsIpExemption>>> {
            const localVarAxiosArgs = await IpExemptionApiAxiosParamCreator(configuration).getIpExemption(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists IpExemptions
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listIpExemptions(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsIpExemption>>> {
            const localVarAxiosArgs = await IpExemptionApiAxiosParamCreator(configuration).listIpExemptions(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates IpExemption
         * @param {number} id Id
         * @param {ModelsIpExemption} ipExemption IpExemption
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateIpExemption(id: number, ipExemption: ModelsIpExemption, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsIpExemption>>> {
            const localVarAxiosArgs = await IpExemptionApiAxiosParamCreator(configuration).updateIpExemption(id, ipExemption, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * IpExemptionApi - factory interface
 * @export
 */
export const IpExemptionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates IpExemption
         * @param {ModelsIpExemption} ipExemption IpExemption
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIpExemption(ipExemption: ModelsIpExemption, options?: any): AxiosPromise<Array<ModelsIpExemption>> {
            return IpExemptionApiFp(configuration).createIpExemption(ipExemption, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes IpExemption
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIpExemption(id: number, options?: any): AxiosPromise<string> {
            return IpExemptionApiFp(configuration).deleteIpExemption(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets IpExemption
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIpExemption(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsIpExemption>> {
            return IpExemptionApiFp(configuration).getIpExemption(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists IpExemptions
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIpExemptions(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsIpExemption>> {
            return IpExemptionApiFp(configuration).listIpExemptions(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates IpExemption
         * @param {number} id Id
         * @param {ModelsIpExemption} ipExemption IpExemption
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIpExemption(id: number, ipExemption: ModelsIpExemption, options?: any): AxiosPromise<Array<ModelsIpExemption>> {
            return IpExemptionApiFp(configuration).updateIpExemption(id, ipExemption, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createIpExemption operation in IpExemptionApi.
 * @export
 * @interface IpExemptionApiCreateIpExemptionRequest
 */
export interface IpExemptionApiCreateIpExemptionRequest {
    /**
     * IpExemption
     * @type {ModelsIpExemption}
     * @memberof IpExemptionApiCreateIpExemption
     */
    readonly ipExemption: ModelsIpExemption
}

/**
 * Request parameters for deleteIpExemption operation in IpExemptionApi.
 * @export
 * @interface IpExemptionApiDeleteIpExemptionRequest
 */
export interface IpExemptionApiDeleteIpExemptionRequest {
    /**
     * Id
     * @type {number}
     * @memberof IpExemptionApiDeleteIpExemption
     */
    readonly id: number
}

/**
 * Request parameters for getIpExemption operation in IpExemptionApi.
 * @export
 * @interface IpExemptionApiGetIpExemptionRequest
 */
export interface IpExemptionApiGetIpExemptionRequest {
    /**
     * Id
     * @type {number}
     * @memberof IpExemptionApiGetIpExemption
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof IpExemptionApiGetIpExemption
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof IpExemptionApiGetIpExemption
     */
    readonly select?: string
}

/**
 * Request parameters for listIpExemptions operation in IpExemptionApi.
 * @export
 * @interface IpExemptionApiListIpExemptionsRequest
 */
export interface IpExemptionApiListIpExemptionsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof IpExemptionApiListIpExemptions
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof IpExemptionApiListIpExemptions
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof IpExemptionApiListIpExemptions
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof IpExemptionApiListIpExemptions
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof IpExemptionApiListIpExemptions
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof IpExemptionApiListIpExemptions
     */
    readonly select?: string
}

/**
 * Request parameters for updateIpExemption operation in IpExemptionApi.
 * @export
 * @interface IpExemptionApiUpdateIpExemptionRequest
 */
export interface IpExemptionApiUpdateIpExemptionRequest {
    /**
     * Id
     * @type {number}
     * @memberof IpExemptionApiUpdateIpExemption
     */
    readonly id: number

    /**
     * IpExemption
     * @type {ModelsIpExemption}
     * @memberof IpExemptionApiUpdateIpExemption
     */
    readonly ipExemption: ModelsIpExemption
}

/**
 * IpExemptionApi - object-oriented interface
 * @export
 * @class IpExemptionApi
 * @extends {BaseAPI}
 */
export class IpExemptionApi extends BaseAPI {
    /**
     * 
     * @summary Creates IpExemption
     * @param {IpExemptionApiCreateIpExemptionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpExemptionApi
     */
    public createIpExemption(requestParameters: IpExemptionApiCreateIpExemptionRequest, options?: any) {
        return IpExemptionApiFp(this.configuration).createIpExemption(requestParameters.ipExemption, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes IpExemption
     * @param {IpExemptionApiDeleteIpExemptionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpExemptionApi
     */
    public deleteIpExemption(requestParameters: IpExemptionApiDeleteIpExemptionRequest, options?: any) {
        return IpExemptionApiFp(this.configuration).deleteIpExemption(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets IpExemption
     * @param {IpExemptionApiGetIpExemptionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpExemptionApi
     */
    public getIpExemption(requestParameters: IpExemptionApiGetIpExemptionRequest, options?: any) {
        return IpExemptionApiFp(this.configuration).getIpExemption(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists IpExemptions
     * @param {IpExemptionApiListIpExemptionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpExemptionApi
     */
    public listIpExemptions(requestParameters: IpExemptionApiListIpExemptionsRequest = {}, options?: any) {
        return IpExemptionApiFp(this.configuration).listIpExemptions(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates IpExemption
     * @param {IpExemptionApiUpdateIpExemptionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpExemptionApi
     */
    public updateIpExemption(requestParameters: IpExemptionApiUpdateIpExemptionRequest, options?: any) {
        return IpExemptionApiFp(this.configuration).updateIpExemption(requestParameters.id, requestParameters.ipExemption, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemApi - axios parameter creator
 * @export
 */
export const ItemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Item
         * @param {ModelsItem} item Item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItem: async (item: ModelsItem, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            if (item === null || item === undefined) {
                throw new RequiredError('item','Required parameter item was null or undefined when calling createItem.');
            }
            const localVarPath = `/item`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof item !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(item !== undefined ? item : {})
                : (item || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes Item
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteItem.');
            }
            const localVarPath = `/item/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Item
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;DiscoveredItems
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItem: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getItem.');
            }
            const localVarPath = `/item/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists Items
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;DiscoveredItems
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItems: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates Item
         * @param {number} id Id
         * @param {ModelsItem} item Item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem: async (id: number, item: ModelsItem, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateItem.');
            }
            // verify required parameter 'item' is not null or undefined
            if (item === null || item === undefined) {
                throw new RequiredError('item','Required parameter item was null or undefined when calling updateItem.');
            }
            const localVarPath = `/item/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof item !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(item !== undefined ? item : {})
                : (item || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemApi - functional programming interface
 * @export
 */
export const ItemApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Item
         * @param {ModelsItem} item Item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItem(item: ModelsItem, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsItem>>> {
            const localVarAxiosArgs = await ItemApiAxiosParamCreator(configuration).createItem(item, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes Item
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItem(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await ItemApiAxiosParamCreator(configuration).deleteItem(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Item
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;DiscoveredItems
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItem(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsItem>>> {
            const localVarAxiosArgs = await ItemApiAxiosParamCreator(configuration).getItem(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists Items
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;DiscoveredItems
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listItems(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsItem>>> {
            const localVarAxiosArgs = await ItemApiAxiosParamCreator(configuration).listItems(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates Item
         * @param {number} id Id
         * @param {ModelsItem} item Item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateItem(id: number, item: ModelsItem, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsItem>>> {
            const localVarAxiosArgs = await ItemApiAxiosParamCreator(configuration).updateItem(id, item, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ItemApi - factory interface
 * @export
 */
export const ItemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates Item
         * @param {ModelsItem} item Item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItem(item: ModelsItem, options?: any): AxiosPromise<Array<ModelsItem>> {
            return ItemApiFp(configuration).createItem(item, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes Item
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem(id: number, options?: any): AxiosPromise<string> {
            return ItemApiFp(configuration).deleteItem(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Item
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;DiscoveredItems
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItem(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsItem>> {
            return ItemApiFp(configuration).getItem(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists Items
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;DiscoveredItems
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItems(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsItem>> {
            return ItemApiFp(configuration).listItems(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates Item
         * @param {number} id Id
         * @param {ModelsItem} item Item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem(id: number, item: ModelsItem, options?: any): AxiosPromise<Array<ModelsItem>> {
            return ItemApiFp(configuration).updateItem(id, item, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createItem operation in ItemApi.
 * @export
 * @interface ItemApiCreateItemRequest
 */
export interface ItemApiCreateItemRequest {
    /**
     * Item
     * @type {ModelsItem}
     * @memberof ItemApiCreateItem
     */
    readonly item: ModelsItem
}

/**
 * Request parameters for deleteItem operation in ItemApi.
 * @export
 * @interface ItemApiDeleteItemRequest
 */
export interface ItemApiDeleteItemRequest {
    /**
     * Id
     * @type {number}
     * @memberof ItemApiDeleteItem
     */
    readonly id: number
}

/**
 * Request parameters for getItem operation in ItemApi.
 * @export
 * @interface ItemApiGetItemRequest
 */
export interface ItemApiGetItemRequest {
    /**
     * Id
     * @type {number}
     * @memberof ItemApiGetItem
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;DiscoveredItems
     * @type {string}
     * @memberof ItemApiGetItem
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof ItemApiGetItem
     */
    readonly select?: string
}

/**
 * Request parameters for listItems operation in ItemApi.
 * @export
 * @interface ItemApiListItemsRequest
 */
export interface ItemApiListItemsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;DiscoveredItems
     * @type {string}
     * @memberof ItemApiListItems
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof ItemApiListItems
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof ItemApiListItems
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof ItemApiListItems
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof ItemApiListItems
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof ItemApiListItems
     */
    readonly select?: string
}

/**
 * Request parameters for updateItem operation in ItemApi.
 * @export
 * @interface ItemApiUpdateItemRequest
 */
export interface ItemApiUpdateItemRequest {
    /**
     * Id
     * @type {number}
     * @memberof ItemApiUpdateItem
     */
    readonly id: number

    /**
     * Item
     * @type {ModelsItem}
     * @memberof ItemApiUpdateItem
     */
    readonly item: ModelsItem
}

/**
 * ItemApi - object-oriented interface
 * @export
 * @class ItemApi
 * @extends {BaseAPI}
 */
export class ItemApi extends BaseAPI {
    /**
     * 
     * @summary Creates Item
     * @param {ItemApiCreateItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public createItem(requestParameters: ItemApiCreateItemRequest, options?: any) {
        return ItemApiFp(this.configuration).createItem(requestParameters.item, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes Item
     * @param {ItemApiDeleteItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public deleteItem(requestParameters: ItemApiDeleteItemRequest, options?: any) {
        return ItemApiFp(this.configuration).deleteItem(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Item
     * @param {ItemApiGetItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public getItem(requestParameters: ItemApiGetItemRequest, options?: any) {
        return ItemApiFp(this.configuration).getItem(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists Items
     * @param {ItemApiListItemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public listItems(requestParameters: ItemApiListItemsRequest = {}, options?: any) {
        return ItemApiFp(this.configuration).listItems(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates Item
     * @param {ItemApiUpdateItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public updateItem(requestParameters: ItemApiUpdateItemRequest, options?: any) {
        return ItemApiFp(this.configuration).updateItem(requestParameters.id, requestParameters.item, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LdonTrapEntryApi - axios parameter creator
 * @export
 */
export const LdonTrapEntryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates LdonTrapEntry
         * @param {ModelsLdonTrapEntry} ldonTrapEntry LdonTrapEntry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLdonTrapEntry: async (ldonTrapEntry: ModelsLdonTrapEntry, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ldonTrapEntry' is not null or undefined
            if (ldonTrapEntry === null || ldonTrapEntry === undefined) {
                throw new RequiredError('ldonTrapEntry','Required parameter ldonTrapEntry was null or undefined when calling createLdonTrapEntry.');
            }
            const localVarPath = `/ldon_trap_entry`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof ldonTrapEntry !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(ldonTrapEntry !== undefined ? ldonTrapEntry : {})
                : (ldonTrapEntry || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes LdonTrapEntry
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLdonTrapEntry: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteLdonTrapEntry.');
            }
            const localVarPath = `/ldon_trap_entry/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets LdonTrapEntry
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLdonTrapEntry: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getLdonTrapEntry.');
            }
            const localVarPath = `/ldon_trap_entry/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists LdonTrapEntries
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLdonTrapEntries: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ldon_trap_entries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates LdonTrapEntry
         * @param {number} id Id
         * @param {ModelsLdonTrapEntry} ldonTrapEntry LdonTrapEntry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLdonTrapEntry: async (id: number, ldonTrapEntry: ModelsLdonTrapEntry, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateLdonTrapEntry.');
            }
            // verify required parameter 'ldonTrapEntry' is not null or undefined
            if (ldonTrapEntry === null || ldonTrapEntry === undefined) {
                throw new RequiredError('ldonTrapEntry','Required parameter ldonTrapEntry was null or undefined when calling updateLdonTrapEntry.');
            }
            const localVarPath = `/ldon_trap_entry/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof ldonTrapEntry !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(ldonTrapEntry !== undefined ? ldonTrapEntry : {})
                : (ldonTrapEntry || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LdonTrapEntryApi - functional programming interface
 * @export
 */
export const LdonTrapEntryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates LdonTrapEntry
         * @param {ModelsLdonTrapEntry} ldonTrapEntry LdonTrapEntry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLdonTrapEntry(ldonTrapEntry: ModelsLdonTrapEntry, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLdonTrapEntry>>> {
            const localVarAxiosArgs = await LdonTrapEntryApiAxiosParamCreator(configuration).createLdonTrapEntry(ldonTrapEntry, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes LdonTrapEntry
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLdonTrapEntry(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await LdonTrapEntryApiAxiosParamCreator(configuration).deleteLdonTrapEntry(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets LdonTrapEntry
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLdonTrapEntry(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLdonTrapEntry>>> {
            const localVarAxiosArgs = await LdonTrapEntryApiAxiosParamCreator(configuration).getLdonTrapEntry(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists LdonTrapEntries
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLdonTrapEntries(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLdonTrapEntry>>> {
            const localVarAxiosArgs = await LdonTrapEntryApiAxiosParamCreator(configuration).listLdonTrapEntries(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates LdonTrapEntry
         * @param {number} id Id
         * @param {ModelsLdonTrapEntry} ldonTrapEntry LdonTrapEntry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLdonTrapEntry(id: number, ldonTrapEntry: ModelsLdonTrapEntry, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLdonTrapEntry>>> {
            const localVarAxiosArgs = await LdonTrapEntryApiAxiosParamCreator(configuration).updateLdonTrapEntry(id, ldonTrapEntry, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LdonTrapEntryApi - factory interface
 * @export
 */
export const LdonTrapEntryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates LdonTrapEntry
         * @param {ModelsLdonTrapEntry} ldonTrapEntry LdonTrapEntry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLdonTrapEntry(ldonTrapEntry: ModelsLdonTrapEntry, options?: any): AxiosPromise<Array<ModelsLdonTrapEntry>> {
            return LdonTrapEntryApiFp(configuration).createLdonTrapEntry(ldonTrapEntry, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes LdonTrapEntry
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLdonTrapEntry(id: number, options?: any): AxiosPromise<string> {
            return LdonTrapEntryApiFp(configuration).deleteLdonTrapEntry(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets LdonTrapEntry
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLdonTrapEntry(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsLdonTrapEntry>> {
            return LdonTrapEntryApiFp(configuration).getLdonTrapEntry(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists LdonTrapEntries
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLdonTrapEntries(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsLdonTrapEntry>> {
            return LdonTrapEntryApiFp(configuration).listLdonTrapEntries(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates LdonTrapEntry
         * @param {number} id Id
         * @param {ModelsLdonTrapEntry} ldonTrapEntry LdonTrapEntry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLdonTrapEntry(id: number, ldonTrapEntry: ModelsLdonTrapEntry, options?: any): AxiosPromise<Array<ModelsLdonTrapEntry>> {
            return LdonTrapEntryApiFp(configuration).updateLdonTrapEntry(id, ldonTrapEntry, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createLdonTrapEntry operation in LdonTrapEntryApi.
 * @export
 * @interface LdonTrapEntryApiCreateLdonTrapEntryRequest
 */
export interface LdonTrapEntryApiCreateLdonTrapEntryRequest {
    /**
     * LdonTrapEntry
     * @type {ModelsLdonTrapEntry}
     * @memberof LdonTrapEntryApiCreateLdonTrapEntry
     */
    readonly ldonTrapEntry: ModelsLdonTrapEntry
}

/**
 * Request parameters for deleteLdonTrapEntry operation in LdonTrapEntryApi.
 * @export
 * @interface LdonTrapEntryApiDeleteLdonTrapEntryRequest
 */
export interface LdonTrapEntryApiDeleteLdonTrapEntryRequest {
    /**
     * Id
     * @type {number}
     * @memberof LdonTrapEntryApiDeleteLdonTrapEntry
     */
    readonly id: number
}

/**
 * Request parameters for getLdonTrapEntry operation in LdonTrapEntryApi.
 * @export
 * @interface LdonTrapEntryApiGetLdonTrapEntryRequest
 */
export interface LdonTrapEntryApiGetLdonTrapEntryRequest {
    /**
     * Id
     * @type {number}
     * @memberof LdonTrapEntryApiGetLdonTrapEntry
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof LdonTrapEntryApiGetLdonTrapEntry
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof LdonTrapEntryApiGetLdonTrapEntry
     */
    readonly select?: string
}

/**
 * Request parameters for listLdonTrapEntries operation in LdonTrapEntryApi.
 * @export
 * @interface LdonTrapEntryApiListLdonTrapEntriesRequest
 */
export interface LdonTrapEntryApiListLdonTrapEntriesRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof LdonTrapEntryApiListLdonTrapEntries
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof LdonTrapEntryApiListLdonTrapEntries
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof LdonTrapEntryApiListLdonTrapEntries
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof LdonTrapEntryApiListLdonTrapEntries
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof LdonTrapEntryApiListLdonTrapEntries
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof LdonTrapEntryApiListLdonTrapEntries
     */
    readonly select?: string
}

/**
 * Request parameters for updateLdonTrapEntry operation in LdonTrapEntryApi.
 * @export
 * @interface LdonTrapEntryApiUpdateLdonTrapEntryRequest
 */
export interface LdonTrapEntryApiUpdateLdonTrapEntryRequest {
    /**
     * Id
     * @type {number}
     * @memberof LdonTrapEntryApiUpdateLdonTrapEntry
     */
    readonly id: number

    /**
     * LdonTrapEntry
     * @type {ModelsLdonTrapEntry}
     * @memberof LdonTrapEntryApiUpdateLdonTrapEntry
     */
    readonly ldonTrapEntry: ModelsLdonTrapEntry
}

/**
 * LdonTrapEntryApi - object-oriented interface
 * @export
 * @class LdonTrapEntryApi
 * @extends {BaseAPI}
 */
export class LdonTrapEntryApi extends BaseAPI {
    /**
     * 
     * @summary Creates LdonTrapEntry
     * @param {LdonTrapEntryApiCreateLdonTrapEntryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LdonTrapEntryApi
     */
    public createLdonTrapEntry(requestParameters: LdonTrapEntryApiCreateLdonTrapEntryRequest, options?: any) {
        return LdonTrapEntryApiFp(this.configuration).createLdonTrapEntry(requestParameters.ldonTrapEntry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes LdonTrapEntry
     * @param {LdonTrapEntryApiDeleteLdonTrapEntryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LdonTrapEntryApi
     */
    public deleteLdonTrapEntry(requestParameters: LdonTrapEntryApiDeleteLdonTrapEntryRequest, options?: any) {
        return LdonTrapEntryApiFp(this.configuration).deleteLdonTrapEntry(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets LdonTrapEntry
     * @param {LdonTrapEntryApiGetLdonTrapEntryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LdonTrapEntryApi
     */
    public getLdonTrapEntry(requestParameters: LdonTrapEntryApiGetLdonTrapEntryRequest, options?: any) {
        return LdonTrapEntryApiFp(this.configuration).getLdonTrapEntry(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists LdonTrapEntries
     * @param {LdonTrapEntryApiListLdonTrapEntriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LdonTrapEntryApi
     */
    public listLdonTrapEntries(requestParameters: LdonTrapEntryApiListLdonTrapEntriesRequest = {}, options?: any) {
        return LdonTrapEntryApiFp(this.configuration).listLdonTrapEntries(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates LdonTrapEntry
     * @param {LdonTrapEntryApiUpdateLdonTrapEntryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LdonTrapEntryApi
     */
    public updateLdonTrapEntry(requestParameters: LdonTrapEntryApiUpdateLdonTrapEntryRequest, options?: any) {
        return LdonTrapEntryApiFp(this.configuration).updateLdonTrapEntry(requestParameters.id, requestParameters.ldonTrapEntry, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LdonTrapTemplateApi - axios parameter creator
 * @export
 */
export const LdonTrapTemplateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates LdonTrapTemplate
         * @param {ModelsLdonTrapTemplate} ldonTrapTemplate LdonTrapTemplate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLdonTrapTemplate: async (ldonTrapTemplate: ModelsLdonTrapTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ldonTrapTemplate' is not null or undefined
            if (ldonTrapTemplate === null || ldonTrapTemplate === undefined) {
                throw new RequiredError('ldonTrapTemplate','Required parameter ldonTrapTemplate was null or undefined when calling createLdonTrapTemplate.');
            }
            const localVarPath = `/ldon_trap_template`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof ldonTrapTemplate !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(ldonTrapTemplate !== undefined ? ldonTrapTemplate : {})
                : (ldonTrapTemplate || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes LdonTrapTemplate
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLdonTrapTemplate: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteLdonTrapTemplate.');
            }
            const localVarPath = `/ldon_trap_template/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets LdonTrapTemplate
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLdonTrapTemplate: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getLdonTrapTemplate.');
            }
            const localVarPath = `/ldon_trap_template/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists LdonTrapTemplates
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLdonTrapTemplates: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ldon_trap_templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates LdonTrapTemplate
         * @param {number} id Id
         * @param {ModelsLdonTrapTemplate} ldonTrapTemplate LdonTrapTemplate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLdonTrapTemplate: async (id: number, ldonTrapTemplate: ModelsLdonTrapTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateLdonTrapTemplate.');
            }
            // verify required parameter 'ldonTrapTemplate' is not null or undefined
            if (ldonTrapTemplate === null || ldonTrapTemplate === undefined) {
                throw new RequiredError('ldonTrapTemplate','Required parameter ldonTrapTemplate was null or undefined when calling updateLdonTrapTemplate.');
            }
            const localVarPath = `/ldon_trap_template/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof ldonTrapTemplate !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(ldonTrapTemplate !== undefined ? ldonTrapTemplate : {})
                : (ldonTrapTemplate || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LdonTrapTemplateApi - functional programming interface
 * @export
 */
export const LdonTrapTemplateApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates LdonTrapTemplate
         * @param {ModelsLdonTrapTemplate} ldonTrapTemplate LdonTrapTemplate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLdonTrapTemplate(ldonTrapTemplate: ModelsLdonTrapTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLdonTrapTemplate>>> {
            const localVarAxiosArgs = await LdonTrapTemplateApiAxiosParamCreator(configuration).createLdonTrapTemplate(ldonTrapTemplate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes LdonTrapTemplate
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLdonTrapTemplate(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await LdonTrapTemplateApiAxiosParamCreator(configuration).deleteLdonTrapTemplate(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets LdonTrapTemplate
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLdonTrapTemplate(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLdonTrapTemplate>>> {
            const localVarAxiosArgs = await LdonTrapTemplateApiAxiosParamCreator(configuration).getLdonTrapTemplate(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists LdonTrapTemplates
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLdonTrapTemplates(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLdonTrapTemplate>>> {
            const localVarAxiosArgs = await LdonTrapTemplateApiAxiosParamCreator(configuration).listLdonTrapTemplates(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates LdonTrapTemplate
         * @param {number} id Id
         * @param {ModelsLdonTrapTemplate} ldonTrapTemplate LdonTrapTemplate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLdonTrapTemplate(id: number, ldonTrapTemplate: ModelsLdonTrapTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLdonTrapTemplate>>> {
            const localVarAxiosArgs = await LdonTrapTemplateApiAxiosParamCreator(configuration).updateLdonTrapTemplate(id, ldonTrapTemplate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LdonTrapTemplateApi - factory interface
 * @export
 */
export const LdonTrapTemplateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates LdonTrapTemplate
         * @param {ModelsLdonTrapTemplate} ldonTrapTemplate LdonTrapTemplate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLdonTrapTemplate(ldonTrapTemplate: ModelsLdonTrapTemplate, options?: any): AxiosPromise<Array<ModelsLdonTrapTemplate>> {
            return LdonTrapTemplateApiFp(configuration).createLdonTrapTemplate(ldonTrapTemplate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes LdonTrapTemplate
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLdonTrapTemplate(id: number, options?: any): AxiosPromise<string> {
            return LdonTrapTemplateApiFp(configuration).deleteLdonTrapTemplate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets LdonTrapTemplate
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLdonTrapTemplate(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsLdonTrapTemplate>> {
            return LdonTrapTemplateApiFp(configuration).getLdonTrapTemplate(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists LdonTrapTemplates
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLdonTrapTemplates(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsLdonTrapTemplate>> {
            return LdonTrapTemplateApiFp(configuration).listLdonTrapTemplates(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates LdonTrapTemplate
         * @param {number} id Id
         * @param {ModelsLdonTrapTemplate} ldonTrapTemplate LdonTrapTemplate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLdonTrapTemplate(id: number, ldonTrapTemplate: ModelsLdonTrapTemplate, options?: any): AxiosPromise<Array<ModelsLdonTrapTemplate>> {
            return LdonTrapTemplateApiFp(configuration).updateLdonTrapTemplate(id, ldonTrapTemplate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createLdonTrapTemplate operation in LdonTrapTemplateApi.
 * @export
 * @interface LdonTrapTemplateApiCreateLdonTrapTemplateRequest
 */
export interface LdonTrapTemplateApiCreateLdonTrapTemplateRequest {
    /**
     * LdonTrapTemplate
     * @type {ModelsLdonTrapTemplate}
     * @memberof LdonTrapTemplateApiCreateLdonTrapTemplate
     */
    readonly ldonTrapTemplate: ModelsLdonTrapTemplate
}

/**
 * Request parameters for deleteLdonTrapTemplate operation in LdonTrapTemplateApi.
 * @export
 * @interface LdonTrapTemplateApiDeleteLdonTrapTemplateRequest
 */
export interface LdonTrapTemplateApiDeleteLdonTrapTemplateRequest {
    /**
     * Id
     * @type {number}
     * @memberof LdonTrapTemplateApiDeleteLdonTrapTemplate
     */
    readonly id: number
}

/**
 * Request parameters for getLdonTrapTemplate operation in LdonTrapTemplateApi.
 * @export
 * @interface LdonTrapTemplateApiGetLdonTrapTemplateRequest
 */
export interface LdonTrapTemplateApiGetLdonTrapTemplateRequest {
    /**
     * Id
     * @type {number}
     * @memberof LdonTrapTemplateApiGetLdonTrapTemplate
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof LdonTrapTemplateApiGetLdonTrapTemplate
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof LdonTrapTemplateApiGetLdonTrapTemplate
     */
    readonly select?: string
}

/**
 * Request parameters for listLdonTrapTemplates operation in LdonTrapTemplateApi.
 * @export
 * @interface LdonTrapTemplateApiListLdonTrapTemplatesRequest
 */
export interface LdonTrapTemplateApiListLdonTrapTemplatesRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof LdonTrapTemplateApiListLdonTrapTemplates
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof LdonTrapTemplateApiListLdonTrapTemplates
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof LdonTrapTemplateApiListLdonTrapTemplates
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof LdonTrapTemplateApiListLdonTrapTemplates
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof LdonTrapTemplateApiListLdonTrapTemplates
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof LdonTrapTemplateApiListLdonTrapTemplates
     */
    readonly select?: string
}

/**
 * Request parameters for updateLdonTrapTemplate operation in LdonTrapTemplateApi.
 * @export
 * @interface LdonTrapTemplateApiUpdateLdonTrapTemplateRequest
 */
export interface LdonTrapTemplateApiUpdateLdonTrapTemplateRequest {
    /**
     * Id
     * @type {number}
     * @memberof LdonTrapTemplateApiUpdateLdonTrapTemplate
     */
    readonly id: number

    /**
     * LdonTrapTemplate
     * @type {ModelsLdonTrapTemplate}
     * @memberof LdonTrapTemplateApiUpdateLdonTrapTemplate
     */
    readonly ldonTrapTemplate: ModelsLdonTrapTemplate
}

/**
 * LdonTrapTemplateApi - object-oriented interface
 * @export
 * @class LdonTrapTemplateApi
 * @extends {BaseAPI}
 */
export class LdonTrapTemplateApi extends BaseAPI {
    /**
     * 
     * @summary Creates LdonTrapTemplate
     * @param {LdonTrapTemplateApiCreateLdonTrapTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LdonTrapTemplateApi
     */
    public createLdonTrapTemplate(requestParameters: LdonTrapTemplateApiCreateLdonTrapTemplateRequest, options?: any) {
        return LdonTrapTemplateApiFp(this.configuration).createLdonTrapTemplate(requestParameters.ldonTrapTemplate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes LdonTrapTemplate
     * @param {LdonTrapTemplateApiDeleteLdonTrapTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LdonTrapTemplateApi
     */
    public deleteLdonTrapTemplate(requestParameters: LdonTrapTemplateApiDeleteLdonTrapTemplateRequest, options?: any) {
        return LdonTrapTemplateApiFp(this.configuration).deleteLdonTrapTemplate(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets LdonTrapTemplate
     * @param {LdonTrapTemplateApiGetLdonTrapTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LdonTrapTemplateApi
     */
    public getLdonTrapTemplate(requestParameters: LdonTrapTemplateApiGetLdonTrapTemplateRequest, options?: any) {
        return LdonTrapTemplateApiFp(this.configuration).getLdonTrapTemplate(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists LdonTrapTemplates
     * @param {LdonTrapTemplateApiListLdonTrapTemplatesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LdonTrapTemplateApi
     */
    public listLdonTrapTemplates(requestParameters: LdonTrapTemplateApiListLdonTrapTemplatesRequest = {}, options?: any) {
        return LdonTrapTemplateApiFp(this.configuration).listLdonTrapTemplates(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates LdonTrapTemplate
     * @param {LdonTrapTemplateApiUpdateLdonTrapTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LdonTrapTemplateApi
     */
    public updateLdonTrapTemplate(requestParameters: LdonTrapTemplateApiUpdateLdonTrapTemplateRequest, options?: any) {
        return LdonTrapTemplateApiFp(this.configuration).updateLdonTrapTemplate(requestParameters.id, requestParameters.ldonTrapTemplate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LevelExpModApi - axios parameter creator
 * @export
 */
export const LevelExpModApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates LevelExpMod
         * @param {ModelsLevelExpMod} levelExpMod LevelExpMod
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLevelExpMod: async (levelExpMod: ModelsLevelExpMod, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'levelExpMod' is not null or undefined
            if (levelExpMod === null || levelExpMod === undefined) {
                throw new RequiredError('levelExpMod','Required parameter levelExpMod was null or undefined when calling createLevelExpMod.');
            }
            const localVarPath = `/level_exp_mod`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof levelExpMod !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(levelExpMod !== undefined ? levelExpMod : {})
                : (levelExpMod || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes LevelExpMod
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLevelExpMod: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteLevelExpMod.');
            }
            const localVarPath = `/level_exp_mod/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets LevelExpMod
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLevelExpMod: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getLevelExpMod.');
            }
            const localVarPath = `/level_exp_mod/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists LevelExpMods
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLevelExpMods: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/level_exp_mods`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates LevelExpMod
         * @param {number} id Id
         * @param {ModelsLevelExpMod} levelExpMod LevelExpMod
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLevelExpMod: async (id: number, levelExpMod: ModelsLevelExpMod, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateLevelExpMod.');
            }
            // verify required parameter 'levelExpMod' is not null or undefined
            if (levelExpMod === null || levelExpMod === undefined) {
                throw new RequiredError('levelExpMod','Required parameter levelExpMod was null or undefined when calling updateLevelExpMod.');
            }
            const localVarPath = `/level_exp_mod/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof levelExpMod !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(levelExpMod !== undefined ? levelExpMod : {})
                : (levelExpMod || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LevelExpModApi - functional programming interface
 * @export
 */
export const LevelExpModApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates LevelExpMod
         * @param {ModelsLevelExpMod} levelExpMod LevelExpMod
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLevelExpMod(levelExpMod: ModelsLevelExpMod, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLevelExpMod>>> {
            const localVarAxiosArgs = await LevelExpModApiAxiosParamCreator(configuration).createLevelExpMod(levelExpMod, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes LevelExpMod
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLevelExpMod(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await LevelExpModApiAxiosParamCreator(configuration).deleteLevelExpMod(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets LevelExpMod
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLevelExpMod(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLevelExpMod>>> {
            const localVarAxiosArgs = await LevelExpModApiAxiosParamCreator(configuration).getLevelExpMod(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists LevelExpMods
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLevelExpMods(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLevelExpMod>>> {
            const localVarAxiosArgs = await LevelExpModApiAxiosParamCreator(configuration).listLevelExpMods(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates LevelExpMod
         * @param {number} id Id
         * @param {ModelsLevelExpMod} levelExpMod LevelExpMod
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLevelExpMod(id: number, levelExpMod: ModelsLevelExpMod, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLevelExpMod>>> {
            const localVarAxiosArgs = await LevelExpModApiAxiosParamCreator(configuration).updateLevelExpMod(id, levelExpMod, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LevelExpModApi - factory interface
 * @export
 */
export const LevelExpModApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates LevelExpMod
         * @param {ModelsLevelExpMod} levelExpMod LevelExpMod
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLevelExpMod(levelExpMod: ModelsLevelExpMod, options?: any): AxiosPromise<Array<ModelsLevelExpMod>> {
            return LevelExpModApiFp(configuration).createLevelExpMod(levelExpMod, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes LevelExpMod
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLevelExpMod(id: number, options?: any): AxiosPromise<string> {
            return LevelExpModApiFp(configuration).deleteLevelExpMod(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets LevelExpMod
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLevelExpMod(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsLevelExpMod>> {
            return LevelExpModApiFp(configuration).getLevelExpMod(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists LevelExpMods
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLevelExpMods(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsLevelExpMod>> {
            return LevelExpModApiFp(configuration).listLevelExpMods(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates LevelExpMod
         * @param {number} id Id
         * @param {ModelsLevelExpMod} levelExpMod LevelExpMod
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLevelExpMod(id: number, levelExpMod: ModelsLevelExpMod, options?: any): AxiosPromise<Array<ModelsLevelExpMod>> {
            return LevelExpModApiFp(configuration).updateLevelExpMod(id, levelExpMod, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createLevelExpMod operation in LevelExpModApi.
 * @export
 * @interface LevelExpModApiCreateLevelExpModRequest
 */
export interface LevelExpModApiCreateLevelExpModRequest {
    /**
     * LevelExpMod
     * @type {ModelsLevelExpMod}
     * @memberof LevelExpModApiCreateLevelExpMod
     */
    readonly levelExpMod: ModelsLevelExpMod
}

/**
 * Request parameters for deleteLevelExpMod operation in LevelExpModApi.
 * @export
 * @interface LevelExpModApiDeleteLevelExpModRequest
 */
export interface LevelExpModApiDeleteLevelExpModRequest {
    /**
     * Id
     * @type {number}
     * @memberof LevelExpModApiDeleteLevelExpMod
     */
    readonly id: number
}

/**
 * Request parameters for getLevelExpMod operation in LevelExpModApi.
 * @export
 * @interface LevelExpModApiGetLevelExpModRequest
 */
export interface LevelExpModApiGetLevelExpModRequest {
    /**
     * Id
     * @type {number}
     * @memberof LevelExpModApiGetLevelExpMod
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof LevelExpModApiGetLevelExpMod
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof LevelExpModApiGetLevelExpMod
     */
    readonly select?: string
}

/**
 * Request parameters for listLevelExpMods operation in LevelExpModApi.
 * @export
 * @interface LevelExpModApiListLevelExpModsRequest
 */
export interface LevelExpModApiListLevelExpModsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof LevelExpModApiListLevelExpMods
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof LevelExpModApiListLevelExpMods
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof LevelExpModApiListLevelExpMods
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof LevelExpModApiListLevelExpMods
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof LevelExpModApiListLevelExpMods
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof LevelExpModApiListLevelExpMods
     */
    readonly select?: string
}

/**
 * Request parameters for updateLevelExpMod operation in LevelExpModApi.
 * @export
 * @interface LevelExpModApiUpdateLevelExpModRequest
 */
export interface LevelExpModApiUpdateLevelExpModRequest {
    /**
     * Id
     * @type {number}
     * @memberof LevelExpModApiUpdateLevelExpMod
     */
    readonly id: number

    /**
     * LevelExpMod
     * @type {ModelsLevelExpMod}
     * @memberof LevelExpModApiUpdateLevelExpMod
     */
    readonly levelExpMod: ModelsLevelExpMod
}

/**
 * LevelExpModApi - object-oriented interface
 * @export
 * @class LevelExpModApi
 * @extends {BaseAPI}
 */
export class LevelExpModApi extends BaseAPI {
    /**
     * 
     * @summary Creates LevelExpMod
     * @param {LevelExpModApiCreateLevelExpModRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LevelExpModApi
     */
    public createLevelExpMod(requestParameters: LevelExpModApiCreateLevelExpModRequest, options?: any) {
        return LevelExpModApiFp(this.configuration).createLevelExpMod(requestParameters.levelExpMod, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes LevelExpMod
     * @param {LevelExpModApiDeleteLevelExpModRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LevelExpModApi
     */
    public deleteLevelExpMod(requestParameters: LevelExpModApiDeleteLevelExpModRequest, options?: any) {
        return LevelExpModApiFp(this.configuration).deleteLevelExpMod(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets LevelExpMod
     * @param {LevelExpModApiGetLevelExpModRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LevelExpModApi
     */
    public getLevelExpMod(requestParameters: LevelExpModApiGetLevelExpModRequest, options?: any) {
        return LevelExpModApiFp(this.configuration).getLevelExpMod(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists LevelExpMods
     * @param {LevelExpModApiListLevelExpModsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LevelExpModApi
     */
    public listLevelExpMods(requestParameters: LevelExpModApiListLevelExpModsRequest = {}, options?: any) {
        return LevelExpModApiFp(this.configuration).listLevelExpMods(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates LevelExpMod
     * @param {LevelExpModApiUpdateLevelExpModRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LevelExpModApi
     */
    public updateLevelExpMod(requestParameters: LevelExpModApiUpdateLevelExpModRequest, options?: any) {
        return LevelExpModApiFp(this.configuration).updateLevelExpMod(requestParameters.id, requestParameters.levelExpMod, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LoginAccountApi - axios parameter creator
 * @export
 */
export const LoginAccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates LoginAccount
         * @param {ModelsLoginAccount} loginAccount LoginAccount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLoginAccount: async (loginAccount: ModelsLoginAccount, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginAccount' is not null or undefined
            if (loginAccount === null || loginAccount === undefined) {
                throw new RequiredError('loginAccount','Required parameter loginAccount was null or undefined when calling createLoginAccount.');
            }
            const localVarPath = `/login_account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof loginAccount !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(loginAccount !== undefined ? loginAccount : {})
                : (loginAccount || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes LoginAccount
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLoginAccount: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteLoginAccount.');
            }
            const localVarPath = `/login_account/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets LoginAccount
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginAccount: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getLoginAccount.');
            }
            const localVarPath = `/login_account/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists LoginAccounts
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLoginAccounts: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/login_accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates LoginAccount
         * @param {number} id Id
         * @param {ModelsLoginAccount} loginAccount LoginAccount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLoginAccount: async (id: number, loginAccount: ModelsLoginAccount, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateLoginAccount.');
            }
            // verify required parameter 'loginAccount' is not null or undefined
            if (loginAccount === null || loginAccount === undefined) {
                throw new RequiredError('loginAccount','Required parameter loginAccount was null or undefined when calling updateLoginAccount.');
            }
            const localVarPath = `/login_account/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof loginAccount !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(loginAccount !== undefined ? loginAccount : {})
                : (loginAccount || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LoginAccountApi - functional programming interface
 * @export
 */
export const LoginAccountApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates LoginAccount
         * @param {ModelsLoginAccount} loginAccount LoginAccount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLoginAccount(loginAccount: ModelsLoginAccount, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLoginAccount>>> {
            const localVarAxiosArgs = await LoginAccountApiAxiosParamCreator(configuration).createLoginAccount(loginAccount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes LoginAccount
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLoginAccount(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await LoginAccountApiAxiosParamCreator(configuration).deleteLoginAccount(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets LoginAccount
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLoginAccount(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLoginAccount>>> {
            const localVarAxiosArgs = await LoginAccountApiAxiosParamCreator(configuration).getLoginAccount(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists LoginAccounts
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLoginAccounts(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLoginAccount>>> {
            const localVarAxiosArgs = await LoginAccountApiAxiosParamCreator(configuration).listLoginAccounts(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates LoginAccount
         * @param {number} id Id
         * @param {ModelsLoginAccount} loginAccount LoginAccount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLoginAccount(id: number, loginAccount: ModelsLoginAccount, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLoginAccount>>> {
            const localVarAxiosArgs = await LoginAccountApiAxiosParamCreator(configuration).updateLoginAccount(id, loginAccount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LoginAccountApi - factory interface
 * @export
 */
export const LoginAccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates LoginAccount
         * @param {ModelsLoginAccount} loginAccount LoginAccount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLoginAccount(loginAccount: ModelsLoginAccount, options?: any): AxiosPromise<Array<ModelsLoginAccount>> {
            return LoginAccountApiFp(configuration).createLoginAccount(loginAccount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes LoginAccount
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLoginAccount(id: number, options?: any): AxiosPromise<string> {
            return LoginAccountApiFp(configuration).deleteLoginAccount(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets LoginAccount
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginAccount(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsLoginAccount>> {
            return LoginAccountApiFp(configuration).getLoginAccount(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists LoginAccounts
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLoginAccounts(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsLoginAccount>> {
            return LoginAccountApiFp(configuration).listLoginAccounts(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates LoginAccount
         * @param {number} id Id
         * @param {ModelsLoginAccount} loginAccount LoginAccount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLoginAccount(id: number, loginAccount: ModelsLoginAccount, options?: any): AxiosPromise<Array<ModelsLoginAccount>> {
            return LoginAccountApiFp(configuration).updateLoginAccount(id, loginAccount, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createLoginAccount operation in LoginAccountApi.
 * @export
 * @interface LoginAccountApiCreateLoginAccountRequest
 */
export interface LoginAccountApiCreateLoginAccountRequest {
    /**
     * LoginAccount
     * @type {ModelsLoginAccount}
     * @memberof LoginAccountApiCreateLoginAccount
     */
    readonly loginAccount: ModelsLoginAccount
}

/**
 * Request parameters for deleteLoginAccount operation in LoginAccountApi.
 * @export
 * @interface LoginAccountApiDeleteLoginAccountRequest
 */
export interface LoginAccountApiDeleteLoginAccountRequest {
    /**
     * Id
     * @type {number}
     * @memberof LoginAccountApiDeleteLoginAccount
     */
    readonly id: number
}

/**
 * Request parameters for getLoginAccount operation in LoginAccountApi.
 * @export
 * @interface LoginAccountApiGetLoginAccountRequest
 */
export interface LoginAccountApiGetLoginAccountRequest {
    /**
     * Id
     * @type {number}
     * @memberof LoginAccountApiGetLoginAccount
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof LoginAccountApiGetLoginAccount
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof LoginAccountApiGetLoginAccount
     */
    readonly select?: string
}

/**
 * Request parameters for listLoginAccounts operation in LoginAccountApi.
 * @export
 * @interface LoginAccountApiListLoginAccountsRequest
 */
export interface LoginAccountApiListLoginAccountsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof LoginAccountApiListLoginAccounts
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof LoginAccountApiListLoginAccounts
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof LoginAccountApiListLoginAccounts
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof LoginAccountApiListLoginAccounts
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof LoginAccountApiListLoginAccounts
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof LoginAccountApiListLoginAccounts
     */
    readonly select?: string
}

/**
 * Request parameters for updateLoginAccount operation in LoginAccountApi.
 * @export
 * @interface LoginAccountApiUpdateLoginAccountRequest
 */
export interface LoginAccountApiUpdateLoginAccountRequest {
    /**
     * Id
     * @type {number}
     * @memberof LoginAccountApiUpdateLoginAccount
     */
    readonly id: number

    /**
     * LoginAccount
     * @type {ModelsLoginAccount}
     * @memberof LoginAccountApiUpdateLoginAccount
     */
    readonly loginAccount: ModelsLoginAccount
}

/**
 * LoginAccountApi - object-oriented interface
 * @export
 * @class LoginAccountApi
 * @extends {BaseAPI}
 */
export class LoginAccountApi extends BaseAPI {
    /**
     * 
     * @summary Creates LoginAccount
     * @param {LoginAccountApiCreateLoginAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginAccountApi
     */
    public createLoginAccount(requestParameters: LoginAccountApiCreateLoginAccountRequest, options?: any) {
        return LoginAccountApiFp(this.configuration).createLoginAccount(requestParameters.loginAccount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes LoginAccount
     * @param {LoginAccountApiDeleteLoginAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginAccountApi
     */
    public deleteLoginAccount(requestParameters: LoginAccountApiDeleteLoginAccountRequest, options?: any) {
        return LoginAccountApiFp(this.configuration).deleteLoginAccount(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets LoginAccount
     * @param {LoginAccountApiGetLoginAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginAccountApi
     */
    public getLoginAccount(requestParameters: LoginAccountApiGetLoginAccountRequest, options?: any) {
        return LoginAccountApiFp(this.configuration).getLoginAccount(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists LoginAccounts
     * @param {LoginAccountApiListLoginAccountsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginAccountApi
     */
    public listLoginAccounts(requestParameters: LoginAccountApiListLoginAccountsRequest = {}, options?: any) {
        return LoginAccountApiFp(this.configuration).listLoginAccounts(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates LoginAccount
     * @param {LoginAccountApiUpdateLoginAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginAccountApi
     */
    public updateLoginAccount(requestParameters: LoginAccountApiUpdateLoginAccountRequest, options?: any) {
        return LoginAccountApiFp(this.configuration).updateLoginAccount(requestParameters.id, requestParameters.loginAccount, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LoginApiTokenApi - axios parameter creator
 * @export
 */
export const LoginApiTokenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates LoginApiToken
         * @param {ModelsLoginApiToken} loginApiToken LoginApiToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLoginApiToken: async (loginApiToken: ModelsLoginApiToken, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginApiToken' is not null or undefined
            if (loginApiToken === null || loginApiToken === undefined) {
                throw new RequiredError('loginApiToken','Required parameter loginApiToken was null or undefined when calling createLoginApiToken.');
            }
            const localVarPath = `/login_api_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof loginApiToken !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(loginApiToken !== undefined ? loginApiToken : {})
                : (loginApiToken || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes LoginApiToken
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLoginApiToken: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteLoginApiToken.');
            }
            const localVarPath = `/login_api_token/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets LoginApiToken
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginApiToken: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getLoginApiToken.');
            }
            const localVarPath = `/login_api_token/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists LoginApiTokens
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLoginApiTokens: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/login_api_tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates LoginApiToken
         * @param {number} id Id
         * @param {ModelsLoginApiToken} loginApiToken LoginApiToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLoginApiToken: async (id: number, loginApiToken: ModelsLoginApiToken, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateLoginApiToken.');
            }
            // verify required parameter 'loginApiToken' is not null or undefined
            if (loginApiToken === null || loginApiToken === undefined) {
                throw new RequiredError('loginApiToken','Required parameter loginApiToken was null or undefined when calling updateLoginApiToken.');
            }
            const localVarPath = `/login_api_token/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof loginApiToken !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(loginApiToken !== undefined ? loginApiToken : {})
                : (loginApiToken || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LoginApiTokenApi - functional programming interface
 * @export
 */
export const LoginApiTokenApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates LoginApiToken
         * @param {ModelsLoginApiToken} loginApiToken LoginApiToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLoginApiToken(loginApiToken: ModelsLoginApiToken, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLoginApiToken>>> {
            const localVarAxiosArgs = await LoginApiTokenApiAxiosParamCreator(configuration).createLoginApiToken(loginApiToken, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes LoginApiToken
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLoginApiToken(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await LoginApiTokenApiAxiosParamCreator(configuration).deleteLoginApiToken(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets LoginApiToken
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLoginApiToken(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLoginApiToken>>> {
            const localVarAxiosArgs = await LoginApiTokenApiAxiosParamCreator(configuration).getLoginApiToken(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists LoginApiTokens
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLoginApiTokens(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLoginApiToken>>> {
            const localVarAxiosArgs = await LoginApiTokenApiAxiosParamCreator(configuration).listLoginApiTokens(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates LoginApiToken
         * @param {number} id Id
         * @param {ModelsLoginApiToken} loginApiToken LoginApiToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLoginApiToken(id: number, loginApiToken: ModelsLoginApiToken, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLoginApiToken>>> {
            const localVarAxiosArgs = await LoginApiTokenApiAxiosParamCreator(configuration).updateLoginApiToken(id, loginApiToken, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LoginApiTokenApi - factory interface
 * @export
 */
export const LoginApiTokenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates LoginApiToken
         * @param {ModelsLoginApiToken} loginApiToken LoginApiToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLoginApiToken(loginApiToken: ModelsLoginApiToken, options?: any): AxiosPromise<Array<ModelsLoginApiToken>> {
            return LoginApiTokenApiFp(configuration).createLoginApiToken(loginApiToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes LoginApiToken
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLoginApiToken(id: number, options?: any): AxiosPromise<string> {
            return LoginApiTokenApiFp(configuration).deleteLoginApiToken(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets LoginApiToken
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginApiToken(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsLoginApiToken>> {
            return LoginApiTokenApiFp(configuration).getLoginApiToken(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists LoginApiTokens
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLoginApiTokens(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsLoginApiToken>> {
            return LoginApiTokenApiFp(configuration).listLoginApiTokens(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates LoginApiToken
         * @param {number} id Id
         * @param {ModelsLoginApiToken} loginApiToken LoginApiToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLoginApiToken(id: number, loginApiToken: ModelsLoginApiToken, options?: any): AxiosPromise<Array<ModelsLoginApiToken>> {
            return LoginApiTokenApiFp(configuration).updateLoginApiToken(id, loginApiToken, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createLoginApiToken operation in LoginApiTokenApi.
 * @export
 * @interface LoginApiTokenApiCreateLoginApiTokenRequest
 */
export interface LoginApiTokenApiCreateLoginApiTokenRequest {
    /**
     * LoginApiToken
     * @type {ModelsLoginApiToken}
     * @memberof LoginApiTokenApiCreateLoginApiToken
     */
    readonly loginApiToken: ModelsLoginApiToken
}

/**
 * Request parameters for deleteLoginApiToken operation in LoginApiTokenApi.
 * @export
 * @interface LoginApiTokenApiDeleteLoginApiTokenRequest
 */
export interface LoginApiTokenApiDeleteLoginApiTokenRequest {
    /**
     * Id
     * @type {number}
     * @memberof LoginApiTokenApiDeleteLoginApiToken
     */
    readonly id: number
}

/**
 * Request parameters for getLoginApiToken operation in LoginApiTokenApi.
 * @export
 * @interface LoginApiTokenApiGetLoginApiTokenRequest
 */
export interface LoginApiTokenApiGetLoginApiTokenRequest {
    /**
     * Id
     * @type {number}
     * @memberof LoginApiTokenApiGetLoginApiToken
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof LoginApiTokenApiGetLoginApiToken
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof LoginApiTokenApiGetLoginApiToken
     */
    readonly select?: string
}

/**
 * Request parameters for listLoginApiTokens operation in LoginApiTokenApi.
 * @export
 * @interface LoginApiTokenApiListLoginApiTokensRequest
 */
export interface LoginApiTokenApiListLoginApiTokensRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof LoginApiTokenApiListLoginApiTokens
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof LoginApiTokenApiListLoginApiTokens
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof LoginApiTokenApiListLoginApiTokens
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof LoginApiTokenApiListLoginApiTokens
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof LoginApiTokenApiListLoginApiTokens
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof LoginApiTokenApiListLoginApiTokens
     */
    readonly select?: string
}

/**
 * Request parameters for updateLoginApiToken operation in LoginApiTokenApi.
 * @export
 * @interface LoginApiTokenApiUpdateLoginApiTokenRequest
 */
export interface LoginApiTokenApiUpdateLoginApiTokenRequest {
    /**
     * Id
     * @type {number}
     * @memberof LoginApiTokenApiUpdateLoginApiToken
     */
    readonly id: number

    /**
     * LoginApiToken
     * @type {ModelsLoginApiToken}
     * @memberof LoginApiTokenApiUpdateLoginApiToken
     */
    readonly loginApiToken: ModelsLoginApiToken
}

/**
 * LoginApiTokenApi - object-oriented interface
 * @export
 * @class LoginApiTokenApi
 * @extends {BaseAPI}
 */
export class LoginApiTokenApi extends BaseAPI {
    /**
     * 
     * @summary Creates LoginApiToken
     * @param {LoginApiTokenApiCreateLoginApiTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApiTokenApi
     */
    public createLoginApiToken(requestParameters: LoginApiTokenApiCreateLoginApiTokenRequest, options?: any) {
        return LoginApiTokenApiFp(this.configuration).createLoginApiToken(requestParameters.loginApiToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes LoginApiToken
     * @param {LoginApiTokenApiDeleteLoginApiTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApiTokenApi
     */
    public deleteLoginApiToken(requestParameters: LoginApiTokenApiDeleteLoginApiTokenRequest, options?: any) {
        return LoginApiTokenApiFp(this.configuration).deleteLoginApiToken(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets LoginApiToken
     * @param {LoginApiTokenApiGetLoginApiTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApiTokenApi
     */
    public getLoginApiToken(requestParameters: LoginApiTokenApiGetLoginApiTokenRequest, options?: any) {
        return LoginApiTokenApiFp(this.configuration).getLoginApiToken(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists LoginApiTokens
     * @param {LoginApiTokenApiListLoginApiTokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApiTokenApi
     */
    public listLoginApiTokens(requestParameters: LoginApiTokenApiListLoginApiTokensRequest = {}, options?: any) {
        return LoginApiTokenApiFp(this.configuration).listLoginApiTokens(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates LoginApiToken
     * @param {LoginApiTokenApiUpdateLoginApiTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApiTokenApi
     */
    public updateLoginApiToken(requestParameters: LoginApiTokenApiUpdateLoginApiTokenRequest, options?: any) {
        return LoginApiTokenApiFp(this.configuration).updateLoginApiToken(requestParameters.id, requestParameters.loginApiToken, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LoginServerAdminApi - axios parameter creator
 * @export
 */
export const LoginServerAdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates LoginServerAdmin
         * @param {ModelsLoginServerAdmin} loginServerAdmin LoginServerAdmin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLoginServerAdmin: async (loginServerAdmin: ModelsLoginServerAdmin, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginServerAdmin' is not null or undefined
            if (loginServerAdmin === null || loginServerAdmin === undefined) {
                throw new RequiredError('loginServerAdmin','Required parameter loginServerAdmin was null or undefined when calling createLoginServerAdmin.');
            }
            const localVarPath = `/login_server_admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof loginServerAdmin !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(loginServerAdmin !== undefined ? loginServerAdmin : {})
                : (loginServerAdmin || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes LoginServerAdmin
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLoginServerAdmin: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteLoginServerAdmin.');
            }
            const localVarPath = `/login_server_admin/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets LoginServerAdmin
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginServerAdmin: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getLoginServerAdmin.');
            }
            const localVarPath = `/login_server_admin/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists LoginServerAdmins
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLoginServerAdmins: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/login_server_admins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates LoginServerAdmin
         * @param {number} id Id
         * @param {ModelsLoginServerAdmin} loginServerAdmin LoginServerAdmin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLoginServerAdmin: async (id: number, loginServerAdmin: ModelsLoginServerAdmin, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateLoginServerAdmin.');
            }
            // verify required parameter 'loginServerAdmin' is not null or undefined
            if (loginServerAdmin === null || loginServerAdmin === undefined) {
                throw new RequiredError('loginServerAdmin','Required parameter loginServerAdmin was null or undefined when calling updateLoginServerAdmin.');
            }
            const localVarPath = `/login_server_admin/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof loginServerAdmin !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(loginServerAdmin !== undefined ? loginServerAdmin : {})
                : (loginServerAdmin || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LoginServerAdminApi - functional programming interface
 * @export
 */
export const LoginServerAdminApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates LoginServerAdmin
         * @param {ModelsLoginServerAdmin} loginServerAdmin LoginServerAdmin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLoginServerAdmin(loginServerAdmin: ModelsLoginServerAdmin, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLoginServerAdmin>>> {
            const localVarAxiosArgs = await LoginServerAdminApiAxiosParamCreator(configuration).createLoginServerAdmin(loginServerAdmin, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes LoginServerAdmin
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLoginServerAdmin(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await LoginServerAdminApiAxiosParamCreator(configuration).deleteLoginServerAdmin(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets LoginServerAdmin
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLoginServerAdmin(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLoginServerAdmin>>> {
            const localVarAxiosArgs = await LoginServerAdminApiAxiosParamCreator(configuration).getLoginServerAdmin(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists LoginServerAdmins
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLoginServerAdmins(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLoginServerAdmin>>> {
            const localVarAxiosArgs = await LoginServerAdminApiAxiosParamCreator(configuration).listLoginServerAdmins(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates LoginServerAdmin
         * @param {number} id Id
         * @param {ModelsLoginServerAdmin} loginServerAdmin LoginServerAdmin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLoginServerAdmin(id: number, loginServerAdmin: ModelsLoginServerAdmin, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLoginServerAdmin>>> {
            const localVarAxiosArgs = await LoginServerAdminApiAxiosParamCreator(configuration).updateLoginServerAdmin(id, loginServerAdmin, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LoginServerAdminApi - factory interface
 * @export
 */
export const LoginServerAdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates LoginServerAdmin
         * @param {ModelsLoginServerAdmin} loginServerAdmin LoginServerAdmin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLoginServerAdmin(loginServerAdmin: ModelsLoginServerAdmin, options?: any): AxiosPromise<Array<ModelsLoginServerAdmin>> {
            return LoginServerAdminApiFp(configuration).createLoginServerAdmin(loginServerAdmin, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes LoginServerAdmin
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLoginServerAdmin(id: number, options?: any): AxiosPromise<string> {
            return LoginServerAdminApiFp(configuration).deleteLoginServerAdmin(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets LoginServerAdmin
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginServerAdmin(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsLoginServerAdmin>> {
            return LoginServerAdminApiFp(configuration).getLoginServerAdmin(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists LoginServerAdmins
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLoginServerAdmins(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsLoginServerAdmin>> {
            return LoginServerAdminApiFp(configuration).listLoginServerAdmins(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates LoginServerAdmin
         * @param {number} id Id
         * @param {ModelsLoginServerAdmin} loginServerAdmin LoginServerAdmin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLoginServerAdmin(id: number, loginServerAdmin: ModelsLoginServerAdmin, options?: any): AxiosPromise<Array<ModelsLoginServerAdmin>> {
            return LoginServerAdminApiFp(configuration).updateLoginServerAdmin(id, loginServerAdmin, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createLoginServerAdmin operation in LoginServerAdminApi.
 * @export
 * @interface LoginServerAdminApiCreateLoginServerAdminRequest
 */
export interface LoginServerAdminApiCreateLoginServerAdminRequest {
    /**
     * LoginServerAdmin
     * @type {ModelsLoginServerAdmin}
     * @memberof LoginServerAdminApiCreateLoginServerAdmin
     */
    readonly loginServerAdmin: ModelsLoginServerAdmin
}

/**
 * Request parameters for deleteLoginServerAdmin operation in LoginServerAdminApi.
 * @export
 * @interface LoginServerAdminApiDeleteLoginServerAdminRequest
 */
export interface LoginServerAdminApiDeleteLoginServerAdminRequest {
    /**
     * Id
     * @type {number}
     * @memberof LoginServerAdminApiDeleteLoginServerAdmin
     */
    readonly id: number
}

/**
 * Request parameters for getLoginServerAdmin operation in LoginServerAdminApi.
 * @export
 * @interface LoginServerAdminApiGetLoginServerAdminRequest
 */
export interface LoginServerAdminApiGetLoginServerAdminRequest {
    /**
     * Id
     * @type {number}
     * @memberof LoginServerAdminApiGetLoginServerAdmin
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof LoginServerAdminApiGetLoginServerAdmin
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof LoginServerAdminApiGetLoginServerAdmin
     */
    readonly select?: string
}

/**
 * Request parameters for listLoginServerAdmins operation in LoginServerAdminApi.
 * @export
 * @interface LoginServerAdminApiListLoginServerAdminsRequest
 */
export interface LoginServerAdminApiListLoginServerAdminsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof LoginServerAdminApiListLoginServerAdmins
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof LoginServerAdminApiListLoginServerAdmins
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof LoginServerAdminApiListLoginServerAdmins
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof LoginServerAdminApiListLoginServerAdmins
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof LoginServerAdminApiListLoginServerAdmins
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof LoginServerAdminApiListLoginServerAdmins
     */
    readonly select?: string
}

/**
 * Request parameters for updateLoginServerAdmin operation in LoginServerAdminApi.
 * @export
 * @interface LoginServerAdminApiUpdateLoginServerAdminRequest
 */
export interface LoginServerAdminApiUpdateLoginServerAdminRequest {
    /**
     * Id
     * @type {number}
     * @memberof LoginServerAdminApiUpdateLoginServerAdmin
     */
    readonly id: number

    /**
     * LoginServerAdmin
     * @type {ModelsLoginServerAdmin}
     * @memberof LoginServerAdminApiUpdateLoginServerAdmin
     */
    readonly loginServerAdmin: ModelsLoginServerAdmin
}

/**
 * LoginServerAdminApi - object-oriented interface
 * @export
 * @class LoginServerAdminApi
 * @extends {BaseAPI}
 */
export class LoginServerAdminApi extends BaseAPI {
    /**
     * 
     * @summary Creates LoginServerAdmin
     * @param {LoginServerAdminApiCreateLoginServerAdminRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginServerAdminApi
     */
    public createLoginServerAdmin(requestParameters: LoginServerAdminApiCreateLoginServerAdminRequest, options?: any) {
        return LoginServerAdminApiFp(this.configuration).createLoginServerAdmin(requestParameters.loginServerAdmin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes LoginServerAdmin
     * @param {LoginServerAdminApiDeleteLoginServerAdminRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginServerAdminApi
     */
    public deleteLoginServerAdmin(requestParameters: LoginServerAdminApiDeleteLoginServerAdminRequest, options?: any) {
        return LoginServerAdminApiFp(this.configuration).deleteLoginServerAdmin(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets LoginServerAdmin
     * @param {LoginServerAdminApiGetLoginServerAdminRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginServerAdminApi
     */
    public getLoginServerAdmin(requestParameters: LoginServerAdminApiGetLoginServerAdminRequest, options?: any) {
        return LoginServerAdminApiFp(this.configuration).getLoginServerAdmin(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists LoginServerAdmins
     * @param {LoginServerAdminApiListLoginServerAdminsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginServerAdminApi
     */
    public listLoginServerAdmins(requestParameters: LoginServerAdminApiListLoginServerAdminsRequest = {}, options?: any) {
        return LoginServerAdminApiFp(this.configuration).listLoginServerAdmins(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates LoginServerAdmin
     * @param {LoginServerAdminApiUpdateLoginServerAdminRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginServerAdminApi
     */
    public updateLoginServerAdmin(requestParameters: LoginServerAdminApiUpdateLoginServerAdminRequest, options?: any) {
        return LoginServerAdminApiFp(this.configuration).updateLoginServerAdmin(requestParameters.id, requestParameters.loginServerAdmin, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LoginServerListTypeApi - axios parameter creator
 * @export
 */
export const LoginServerListTypeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates LoginServerListType
         * @param {ModelsLoginServerListType} loginServerListType LoginServerListType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLoginServerListType: async (loginServerListType: ModelsLoginServerListType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginServerListType' is not null or undefined
            if (loginServerListType === null || loginServerListType === undefined) {
                throw new RequiredError('loginServerListType','Required parameter loginServerListType was null or undefined when calling createLoginServerListType.');
            }
            const localVarPath = `/login_server_list_type`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof loginServerListType !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(loginServerListType !== undefined ? loginServerListType : {})
                : (loginServerListType || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes LoginServerListType
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLoginServerListType: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteLoginServerListType.');
            }
            const localVarPath = `/login_server_list_type/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets LoginServerListType
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginServerListType: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getLoginServerListType.');
            }
            const localVarPath = `/login_server_list_type/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists LoginServerListTypes
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLoginServerListTypes: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/login_server_list_types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates LoginServerListType
         * @param {number} id Id
         * @param {ModelsLoginServerListType} loginServerListType LoginServerListType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLoginServerListType: async (id: number, loginServerListType: ModelsLoginServerListType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateLoginServerListType.');
            }
            // verify required parameter 'loginServerListType' is not null or undefined
            if (loginServerListType === null || loginServerListType === undefined) {
                throw new RequiredError('loginServerListType','Required parameter loginServerListType was null or undefined when calling updateLoginServerListType.');
            }
            const localVarPath = `/login_server_list_type/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof loginServerListType !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(loginServerListType !== undefined ? loginServerListType : {})
                : (loginServerListType || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LoginServerListTypeApi - functional programming interface
 * @export
 */
export const LoginServerListTypeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates LoginServerListType
         * @param {ModelsLoginServerListType} loginServerListType LoginServerListType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLoginServerListType(loginServerListType: ModelsLoginServerListType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLoginServerListType>>> {
            const localVarAxiosArgs = await LoginServerListTypeApiAxiosParamCreator(configuration).createLoginServerListType(loginServerListType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes LoginServerListType
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLoginServerListType(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await LoginServerListTypeApiAxiosParamCreator(configuration).deleteLoginServerListType(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets LoginServerListType
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLoginServerListType(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLoginServerListType>>> {
            const localVarAxiosArgs = await LoginServerListTypeApiAxiosParamCreator(configuration).getLoginServerListType(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists LoginServerListTypes
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLoginServerListTypes(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLoginServerListType>>> {
            const localVarAxiosArgs = await LoginServerListTypeApiAxiosParamCreator(configuration).listLoginServerListTypes(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates LoginServerListType
         * @param {number} id Id
         * @param {ModelsLoginServerListType} loginServerListType LoginServerListType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLoginServerListType(id: number, loginServerListType: ModelsLoginServerListType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLoginServerListType>>> {
            const localVarAxiosArgs = await LoginServerListTypeApiAxiosParamCreator(configuration).updateLoginServerListType(id, loginServerListType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LoginServerListTypeApi - factory interface
 * @export
 */
export const LoginServerListTypeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates LoginServerListType
         * @param {ModelsLoginServerListType} loginServerListType LoginServerListType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLoginServerListType(loginServerListType: ModelsLoginServerListType, options?: any): AxiosPromise<Array<ModelsLoginServerListType>> {
            return LoginServerListTypeApiFp(configuration).createLoginServerListType(loginServerListType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes LoginServerListType
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLoginServerListType(id: number, options?: any): AxiosPromise<string> {
            return LoginServerListTypeApiFp(configuration).deleteLoginServerListType(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets LoginServerListType
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginServerListType(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsLoginServerListType>> {
            return LoginServerListTypeApiFp(configuration).getLoginServerListType(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists LoginServerListTypes
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLoginServerListTypes(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsLoginServerListType>> {
            return LoginServerListTypeApiFp(configuration).listLoginServerListTypes(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates LoginServerListType
         * @param {number} id Id
         * @param {ModelsLoginServerListType} loginServerListType LoginServerListType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLoginServerListType(id: number, loginServerListType: ModelsLoginServerListType, options?: any): AxiosPromise<Array<ModelsLoginServerListType>> {
            return LoginServerListTypeApiFp(configuration).updateLoginServerListType(id, loginServerListType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createLoginServerListType operation in LoginServerListTypeApi.
 * @export
 * @interface LoginServerListTypeApiCreateLoginServerListTypeRequest
 */
export interface LoginServerListTypeApiCreateLoginServerListTypeRequest {
    /**
     * LoginServerListType
     * @type {ModelsLoginServerListType}
     * @memberof LoginServerListTypeApiCreateLoginServerListType
     */
    readonly loginServerListType: ModelsLoginServerListType
}

/**
 * Request parameters for deleteLoginServerListType operation in LoginServerListTypeApi.
 * @export
 * @interface LoginServerListTypeApiDeleteLoginServerListTypeRequest
 */
export interface LoginServerListTypeApiDeleteLoginServerListTypeRequest {
    /**
     * Id
     * @type {number}
     * @memberof LoginServerListTypeApiDeleteLoginServerListType
     */
    readonly id: number
}

/**
 * Request parameters for getLoginServerListType operation in LoginServerListTypeApi.
 * @export
 * @interface LoginServerListTypeApiGetLoginServerListTypeRequest
 */
export interface LoginServerListTypeApiGetLoginServerListTypeRequest {
    /**
     * Id
     * @type {number}
     * @memberof LoginServerListTypeApiGetLoginServerListType
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof LoginServerListTypeApiGetLoginServerListType
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof LoginServerListTypeApiGetLoginServerListType
     */
    readonly select?: string
}

/**
 * Request parameters for listLoginServerListTypes operation in LoginServerListTypeApi.
 * @export
 * @interface LoginServerListTypeApiListLoginServerListTypesRequest
 */
export interface LoginServerListTypeApiListLoginServerListTypesRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof LoginServerListTypeApiListLoginServerListTypes
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof LoginServerListTypeApiListLoginServerListTypes
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof LoginServerListTypeApiListLoginServerListTypes
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof LoginServerListTypeApiListLoginServerListTypes
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof LoginServerListTypeApiListLoginServerListTypes
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof LoginServerListTypeApiListLoginServerListTypes
     */
    readonly select?: string
}

/**
 * Request parameters for updateLoginServerListType operation in LoginServerListTypeApi.
 * @export
 * @interface LoginServerListTypeApiUpdateLoginServerListTypeRequest
 */
export interface LoginServerListTypeApiUpdateLoginServerListTypeRequest {
    /**
     * Id
     * @type {number}
     * @memberof LoginServerListTypeApiUpdateLoginServerListType
     */
    readonly id: number

    /**
     * LoginServerListType
     * @type {ModelsLoginServerListType}
     * @memberof LoginServerListTypeApiUpdateLoginServerListType
     */
    readonly loginServerListType: ModelsLoginServerListType
}

/**
 * LoginServerListTypeApi - object-oriented interface
 * @export
 * @class LoginServerListTypeApi
 * @extends {BaseAPI}
 */
export class LoginServerListTypeApi extends BaseAPI {
    /**
     * 
     * @summary Creates LoginServerListType
     * @param {LoginServerListTypeApiCreateLoginServerListTypeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginServerListTypeApi
     */
    public createLoginServerListType(requestParameters: LoginServerListTypeApiCreateLoginServerListTypeRequest, options?: any) {
        return LoginServerListTypeApiFp(this.configuration).createLoginServerListType(requestParameters.loginServerListType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes LoginServerListType
     * @param {LoginServerListTypeApiDeleteLoginServerListTypeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginServerListTypeApi
     */
    public deleteLoginServerListType(requestParameters: LoginServerListTypeApiDeleteLoginServerListTypeRequest, options?: any) {
        return LoginServerListTypeApiFp(this.configuration).deleteLoginServerListType(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets LoginServerListType
     * @param {LoginServerListTypeApiGetLoginServerListTypeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginServerListTypeApi
     */
    public getLoginServerListType(requestParameters: LoginServerListTypeApiGetLoginServerListTypeRequest, options?: any) {
        return LoginServerListTypeApiFp(this.configuration).getLoginServerListType(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists LoginServerListTypes
     * @param {LoginServerListTypeApiListLoginServerListTypesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginServerListTypeApi
     */
    public listLoginServerListTypes(requestParameters: LoginServerListTypeApiListLoginServerListTypesRequest = {}, options?: any) {
        return LoginServerListTypeApiFp(this.configuration).listLoginServerListTypes(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates LoginServerListType
     * @param {LoginServerListTypeApiUpdateLoginServerListTypeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginServerListTypeApi
     */
    public updateLoginServerListType(requestParameters: LoginServerListTypeApiUpdateLoginServerListTypeRequest, options?: any) {
        return LoginServerListTypeApiFp(this.configuration).updateLoginServerListType(requestParameters.id, requestParameters.loginServerListType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LoginWorldServerApi - axios parameter creator
 * @export
 */
export const LoginWorldServerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates LoginWorldServer
         * @param {ModelsLoginWorldServer} loginWorldServer LoginWorldServer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLoginWorldServer: async (loginWorldServer: ModelsLoginWorldServer, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginWorldServer' is not null or undefined
            if (loginWorldServer === null || loginWorldServer === undefined) {
                throw new RequiredError('loginWorldServer','Required parameter loginWorldServer was null or undefined when calling createLoginWorldServer.');
            }
            const localVarPath = `/login_world_server`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof loginWorldServer !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(loginWorldServer !== undefined ? loginWorldServer : {})
                : (loginWorldServer || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes LoginWorldServer
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLoginWorldServer: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteLoginWorldServer.');
            }
            const localVarPath = `/login_world_server/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets LoginWorldServer
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginWorldServer: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getLoginWorldServer.');
            }
            const localVarPath = `/login_world_server/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists LoginWorldServers
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLoginWorldServers: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/login_world_servers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates LoginWorldServer
         * @param {number} id Id
         * @param {ModelsLoginWorldServer} loginWorldServer LoginWorldServer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLoginWorldServer: async (id: number, loginWorldServer: ModelsLoginWorldServer, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateLoginWorldServer.');
            }
            // verify required parameter 'loginWorldServer' is not null or undefined
            if (loginWorldServer === null || loginWorldServer === undefined) {
                throw new RequiredError('loginWorldServer','Required parameter loginWorldServer was null or undefined when calling updateLoginWorldServer.');
            }
            const localVarPath = `/login_world_server/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof loginWorldServer !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(loginWorldServer !== undefined ? loginWorldServer : {})
                : (loginWorldServer || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LoginWorldServerApi - functional programming interface
 * @export
 */
export const LoginWorldServerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates LoginWorldServer
         * @param {ModelsLoginWorldServer} loginWorldServer LoginWorldServer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLoginWorldServer(loginWorldServer: ModelsLoginWorldServer, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLoginWorldServer>>> {
            const localVarAxiosArgs = await LoginWorldServerApiAxiosParamCreator(configuration).createLoginWorldServer(loginWorldServer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes LoginWorldServer
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLoginWorldServer(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await LoginWorldServerApiAxiosParamCreator(configuration).deleteLoginWorldServer(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets LoginWorldServer
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLoginWorldServer(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLoginWorldServer>>> {
            const localVarAxiosArgs = await LoginWorldServerApiAxiosParamCreator(configuration).getLoginWorldServer(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists LoginWorldServers
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLoginWorldServers(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLoginWorldServer>>> {
            const localVarAxiosArgs = await LoginWorldServerApiAxiosParamCreator(configuration).listLoginWorldServers(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates LoginWorldServer
         * @param {number} id Id
         * @param {ModelsLoginWorldServer} loginWorldServer LoginWorldServer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLoginWorldServer(id: number, loginWorldServer: ModelsLoginWorldServer, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLoginWorldServer>>> {
            const localVarAxiosArgs = await LoginWorldServerApiAxiosParamCreator(configuration).updateLoginWorldServer(id, loginWorldServer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LoginWorldServerApi - factory interface
 * @export
 */
export const LoginWorldServerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates LoginWorldServer
         * @param {ModelsLoginWorldServer} loginWorldServer LoginWorldServer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLoginWorldServer(loginWorldServer: ModelsLoginWorldServer, options?: any): AxiosPromise<Array<ModelsLoginWorldServer>> {
            return LoginWorldServerApiFp(configuration).createLoginWorldServer(loginWorldServer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes LoginWorldServer
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLoginWorldServer(id: number, options?: any): AxiosPromise<string> {
            return LoginWorldServerApiFp(configuration).deleteLoginWorldServer(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets LoginWorldServer
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginWorldServer(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsLoginWorldServer>> {
            return LoginWorldServerApiFp(configuration).getLoginWorldServer(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists LoginWorldServers
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLoginWorldServers(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsLoginWorldServer>> {
            return LoginWorldServerApiFp(configuration).listLoginWorldServers(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates LoginWorldServer
         * @param {number} id Id
         * @param {ModelsLoginWorldServer} loginWorldServer LoginWorldServer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLoginWorldServer(id: number, loginWorldServer: ModelsLoginWorldServer, options?: any): AxiosPromise<Array<ModelsLoginWorldServer>> {
            return LoginWorldServerApiFp(configuration).updateLoginWorldServer(id, loginWorldServer, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createLoginWorldServer operation in LoginWorldServerApi.
 * @export
 * @interface LoginWorldServerApiCreateLoginWorldServerRequest
 */
export interface LoginWorldServerApiCreateLoginWorldServerRequest {
    /**
     * LoginWorldServer
     * @type {ModelsLoginWorldServer}
     * @memberof LoginWorldServerApiCreateLoginWorldServer
     */
    readonly loginWorldServer: ModelsLoginWorldServer
}

/**
 * Request parameters for deleteLoginWorldServer operation in LoginWorldServerApi.
 * @export
 * @interface LoginWorldServerApiDeleteLoginWorldServerRequest
 */
export interface LoginWorldServerApiDeleteLoginWorldServerRequest {
    /**
     * Id
     * @type {number}
     * @memberof LoginWorldServerApiDeleteLoginWorldServer
     */
    readonly id: number
}

/**
 * Request parameters for getLoginWorldServer operation in LoginWorldServerApi.
 * @export
 * @interface LoginWorldServerApiGetLoginWorldServerRequest
 */
export interface LoginWorldServerApiGetLoginWorldServerRequest {
    /**
     * Id
     * @type {number}
     * @memberof LoginWorldServerApiGetLoginWorldServer
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof LoginWorldServerApiGetLoginWorldServer
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof LoginWorldServerApiGetLoginWorldServer
     */
    readonly select?: string
}

/**
 * Request parameters for listLoginWorldServers operation in LoginWorldServerApi.
 * @export
 * @interface LoginWorldServerApiListLoginWorldServersRequest
 */
export interface LoginWorldServerApiListLoginWorldServersRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof LoginWorldServerApiListLoginWorldServers
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof LoginWorldServerApiListLoginWorldServers
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof LoginWorldServerApiListLoginWorldServers
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof LoginWorldServerApiListLoginWorldServers
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof LoginWorldServerApiListLoginWorldServers
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof LoginWorldServerApiListLoginWorldServers
     */
    readonly select?: string
}

/**
 * Request parameters for updateLoginWorldServer operation in LoginWorldServerApi.
 * @export
 * @interface LoginWorldServerApiUpdateLoginWorldServerRequest
 */
export interface LoginWorldServerApiUpdateLoginWorldServerRequest {
    /**
     * Id
     * @type {number}
     * @memberof LoginWorldServerApiUpdateLoginWorldServer
     */
    readonly id: number

    /**
     * LoginWorldServer
     * @type {ModelsLoginWorldServer}
     * @memberof LoginWorldServerApiUpdateLoginWorldServer
     */
    readonly loginWorldServer: ModelsLoginWorldServer
}

/**
 * LoginWorldServerApi - object-oriented interface
 * @export
 * @class LoginWorldServerApi
 * @extends {BaseAPI}
 */
export class LoginWorldServerApi extends BaseAPI {
    /**
     * 
     * @summary Creates LoginWorldServer
     * @param {LoginWorldServerApiCreateLoginWorldServerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginWorldServerApi
     */
    public createLoginWorldServer(requestParameters: LoginWorldServerApiCreateLoginWorldServerRequest, options?: any) {
        return LoginWorldServerApiFp(this.configuration).createLoginWorldServer(requestParameters.loginWorldServer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes LoginWorldServer
     * @param {LoginWorldServerApiDeleteLoginWorldServerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginWorldServerApi
     */
    public deleteLoginWorldServer(requestParameters: LoginWorldServerApiDeleteLoginWorldServerRequest, options?: any) {
        return LoginWorldServerApiFp(this.configuration).deleteLoginWorldServer(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets LoginWorldServer
     * @param {LoginWorldServerApiGetLoginWorldServerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginWorldServerApi
     */
    public getLoginWorldServer(requestParameters: LoginWorldServerApiGetLoginWorldServerRequest, options?: any) {
        return LoginWorldServerApiFp(this.configuration).getLoginWorldServer(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists LoginWorldServers
     * @param {LoginWorldServerApiListLoginWorldServersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginWorldServerApi
     */
    public listLoginWorldServers(requestParameters: LoginWorldServerApiListLoginWorldServersRequest = {}, options?: any) {
        return LoginWorldServerApiFp(this.configuration).listLoginWorldServers(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates LoginWorldServer
     * @param {LoginWorldServerApiUpdateLoginWorldServerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginWorldServerApi
     */
    public updateLoginWorldServer(requestParameters: LoginWorldServerApiUpdateLoginWorldServerRequest, options?: any) {
        return LoginWorldServerApiFp(this.configuration).updateLoginWorldServer(requestParameters.id, requestParameters.loginWorldServer, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LogsysCategoryApi - axios parameter creator
 * @export
 */
export const LogsysCategoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates LogsysCategory
         * @param {ModelsLogsysCategory} logsysCategory LogsysCategory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLogsysCategory: async (logsysCategory: ModelsLogsysCategory, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'logsysCategory' is not null or undefined
            if (logsysCategory === null || logsysCategory === undefined) {
                throw new RequiredError('logsysCategory','Required parameter logsysCategory was null or undefined when calling createLogsysCategory.');
            }
            const localVarPath = `/logsys_category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof logsysCategory !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(logsysCategory !== undefined ? logsysCategory : {})
                : (logsysCategory || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes LogsysCategory
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLogsysCategory: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteLogsysCategory.');
            }
            const localVarPath = `/logsys_category/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets LogsysCategory
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogsysCategory: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getLogsysCategory.');
            }
            const localVarPath = `/logsys_category/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists LogsysCategories
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLogsysCategories: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/logsys_categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates LogsysCategory
         * @param {number} id Id
         * @param {ModelsLogsysCategory} logsysCategory LogsysCategory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLogsysCategory: async (id: number, logsysCategory: ModelsLogsysCategory, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateLogsysCategory.');
            }
            // verify required parameter 'logsysCategory' is not null or undefined
            if (logsysCategory === null || logsysCategory === undefined) {
                throw new RequiredError('logsysCategory','Required parameter logsysCategory was null or undefined when calling updateLogsysCategory.');
            }
            const localVarPath = `/logsys_category/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof logsysCategory !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(logsysCategory !== undefined ? logsysCategory : {})
                : (logsysCategory || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LogsysCategoryApi - functional programming interface
 * @export
 */
export const LogsysCategoryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates LogsysCategory
         * @param {ModelsLogsysCategory} logsysCategory LogsysCategory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLogsysCategory(logsysCategory: ModelsLogsysCategory, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLogsysCategory>>> {
            const localVarAxiosArgs = await LogsysCategoryApiAxiosParamCreator(configuration).createLogsysCategory(logsysCategory, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes LogsysCategory
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLogsysCategory(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await LogsysCategoryApiAxiosParamCreator(configuration).deleteLogsysCategory(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets LogsysCategory
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLogsysCategory(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLogsysCategory>>> {
            const localVarAxiosArgs = await LogsysCategoryApiAxiosParamCreator(configuration).getLogsysCategory(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists LogsysCategories
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLogsysCategories(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLogsysCategory>>> {
            const localVarAxiosArgs = await LogsysCategoryApiAxiosParamCreator(configuration).listLogsysCategories(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates LogsysCategory
         * @param {number} id Id
         * @param {ModelsLogsysCategory} logsysCategory LogsysCategory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLogsysCategory(id: number, logsysCategory: ModelsLogsysCategory, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLogsysCategory>>> {
            const localVarAxiosArgs = await LogsysCategoryApiAxiosParamCreator(configuration).updateLogsysCategory(id, logsysCategory, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LogsysCategoryApi - factory interface
 * @export
 */
export const LogsysCategoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates LogsysCategory
         * @param {ModelsLogsysCategory} logsysCategory LogsysCategory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLogsysCategory(logsysCategory: ModelsLogsysCategory, options?: any): AxiosPromise<Array<ModelsLogsysCategory>> {
            return LogsysCategoryApiFp(configuration).createLogsysCategory(logsysCategory, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes LogsysCategory
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLogsysCategory(id: number, options?: any): AxiosPromise<string> {
            return LogsysCategoryApiFp(configuration).deleteLogsysCategory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets LogsysCategory
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogsysCategory(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsLogsysCategory>> {
            return LogsysCategoryApiFp(configuration).getLogsysCategory(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists LogsysCategories
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLogsysCategories(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsLogsysCategory>> {
            return LogsysCategoryApiFp(configuration).listLogsysCategories(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates LogsysCategory
         * @param {number} id Id
         * @param {ModelsLogsysCategory} logsysCategory LogsysCategory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLogsysCategory(id: number, logsysCategory: ModelsLogsysCategory, options?: any): AxiosPromise<Array<ModelsLogsysCategory>> {
            return LogsysCategoryApiFp(configuration).updateLogsysCategory(id, logsysCategory, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createLogsysCategory operation in LogsysCategoryApi.
 * @export
 * @interface LogsysCategoryApiCreateLogsysCategoryRequest
 */
export interface LogsysCategoryApiCreateLogsysCategoryRequest {
    /**
     * LogsysCategory
     * @type {ModelsLogsysCategory}
     * @memberof LogsysCategoryApiCreateLogsysCategory
     */
    readonly logsysCategory: ModelsLogsysCategory
}

/**
 * Request parameters for deleteLogsysCategory operation in LogsysCategoryApi.
 * @export
 * @interface LogsysCategoryApiDeleteLogsysCategoryRequest
 */
export interface LogsysCategoryApiDeleteLogsysCategoryRequest {
    /**
     * Id
     * @type {number}
     * @memberof LogsysCategoryApiDeleteLogsysCategory
     */
    readonly id: number
}

/**
 * Request parameters for getLogsysCategory operation in LogsysCategoryApi.
 * @export
 * @interface LogsysCategoryApiGetLogsysCategoryRequest
 */
export interface LogsysCategoryApiGetLogsysCategoryRequest {
    /**
     * Id
     * @type {number}
     * @memberof LogsysCategoryApiGetLogsysCategory
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof LogsysCategoryApiGetLogsysCategory
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof LogsysCategoryApiGetLogsysCategory
     */
    readonly select?: string
}

/**
 * Request parameters for listLogsysCategories operation in LogsysCategoryApi.
 * @export
 * @interface LogsysCategoryApiListLogsysCategoriesRequest
 */
export interface LogsysCategoryApiListLogsysCategoriesRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof LogsysCategoryApiListLogsysCategories
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof LogsysCategoryApiListLogsysCategories
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof LogsysCategoryApiListLogsysCategories
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof LogsysCategoryApiListLogsysCategories
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof LogsysCategoryApiListLogsysCategories
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof LogsysCategoryApiListLogsysCategories
     */
    readonly select?: string
}

/**
 * Request parameters for updateLogsysCategory operation in LogsysCategoryApi.
 * @export
 * @interface LogsysCategoryApiUpdateLogsysCategoryRequest
 */
export interface LogsysCategoryApiUpdateLogsysCategoryRequest {
    /**
     * Id
     * @type {number}
     * @memberof LogsysCategoryApiUpdateLogsysCategory
     */
    readonly id: number

    /**
     * LogsysCategory
     * @type {ModelsLogsysCategory}
     * @memberof LogsysCategoryApiUpdateLogsysCategory
     */
    readonly logsysCategory: ModelsLogsysCategory
}

/**
 * LogsysCategoryApi - object-oriented interface
 * @export
 * @class LogsysCategoryApi
 * @extends {BaseAPI}
 */
export class LogsysCategoryApi extends BaseAPI {
    /**
     * 
     * @summary Creates LogsysCategory
     * @param {LogsysCategoryApiCreateLogsysCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogsysCategoryApi
     */
    public createLogsysCategory(requestParameters: LogsysCategoryApiCreateLogsysCategoryRequest, options?: any) {
        return LogsysCategoryApiFp(this.configuration).createLogsysCategory(requestParameters.logsysCategory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes LogsysCategory
     * @param {LogsysCategoryApiDeleteLogsysCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogsysCategoryApi
     */
    public deleteLogsysCategory(requestParameters: LogsysCategoryApiDeleteLogsysCategoryRequest, options?: any) {
        return LogsysCategoryApiFp(this.configuration).deleteLogsysCategory(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets LogsysCategory
     * @param {LogsysCategoryApiGetLogsysCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogsysCategoryApi
     */
    public getLogsysCategory(requestParameters: LogsysCategoryApiGetLogsysCategoryRequest, options?: any) {
        return LogsysCategoryApiFp(this.configuration).getLogsysCategory(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists LogsysCategories
     * @param {LogsysCategoryApiListLogsysCategoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogsysCategoryApi
     */
    public listLogsysCategories(requestParameters: LogsysCategoryApiListLogsysCategoriesRequest = {}, options?: any) {
        return LogsysCategoryApiFp(this.configuration).listLogsysCategories(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates LogsysCategory
     * @param {LogsysCategoryApiUpdateLogsysCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogsysCategoryApi
     */
    public updateLogsysCategory(requestParameters: LogsysCategoryApiUpdateLogsysCategoryRequest, options?: any) {
        return LogsysCategoryApiFp(this.configuration).updateLogsysCategory(requestParameters.id, requestParameters.logsysCategory, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LootdropApi - axios parameter creator
 * @export
 */
export const LootdropApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Lootdrop
         * @param {ModelsLootdrop} lootdrop Lootdrop
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLootdrop: async (lootdrop: ModelsLootdrop, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'lootdrop' is not null or undefined
            if (lootdrop === null || lootdrop === undefined) {
                throw new RequiredError('lootdrop','Required parameter lootdrop was null or undefined when calling createLootdrop.');
            }
            const localVarPath = `/lootdrop`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof lootdrop !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(lootdrop !== undefined ? lootdrop : {})
                : (lootdrop || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes Lootdrop
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLootdrop: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteLootdrop.');
            }
            const localVarPath = `/lootdrop/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Lootdrop
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;LootdropEntries&lt;br&gt;LootdropEntries.Item&lt;br&gt;LootdropEntries.Item.DiscoveredItems
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLootdrop: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getLootdrop.');
            }
            const localVarPath = `/lootdrop/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists Lootdrops
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;LootdropEntries&lt;br&gt;LootdropEntries.Item&lt;br&gt;LootdropEntries.Item.DiscoveredItems
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLootdrops: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/lootdrops`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates Lootdrop
         * @param {number} id Id
         * @param {ModelsLootdrop} lootdrop Lootdrop
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLootdrop: async (id: number, lootdrop: ModelsLootdrop, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateLootdrop.');
            }
            // verify required parameter 'lootdrop' is not null or undefined
            if (lootdrop === null || lootdrop === undefined) {
                throw new RequiredError('lootdrop','Required parameter lootdrop was null or undefined when calling updateLootdrop.');
            }
            const localVarPath = `/lootdrop/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof lootdrop !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(lootdrop !== undefined ? lootdrop : {})
                : (lootdrop || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LootdropApi - functional programming interface
 * @export
 */
export const LootdropApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Lootdrop
         * @param {ModelsLootdrop} lootdrop Lootdrop
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLootdrop(lootdrop: ModelsLootdrop, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLootdrop>>> {
            const localVarAxiosArgs = await LootdropApiAxiosParamCreator(configuration).createLootdrop(lootdrop, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes Lootdrop
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLootdrop(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await LootdropApiAxiosParamCreator(configuration).deleteLootdrop(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Lootdrop
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;LootdropEntries&lt;br&gt;LootdropEntries.Item&lt;br&gt;LootdropEntries.Item.DiscoveredItems
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLootdrop(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLootdrop>>> {
            const localVarAxiosArgs = await LootdropApiAxiosParamCreator(configuration).getLootdrop(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists Lootdrops
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;LootdropEntries&lt;br&gt;LootdropEntries.Item&lt;br&gt;LootdropEntries.Item.DiscoveredItems
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLootdrops(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLootdrop>>> {
            const localVarAxiosArgs = await LootdropApiAxiosParamCreator(configuration).listLootdrops(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates Lootdrop
         * @param {number} id Id
         * @param {ModelsLootdrop} lootdrop Lootdrop
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLootdrop(id: number, lootdrop: ModelsLootdrop, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLootdrop>>> {
            const localVarAxiosArgs = await LootdropApiAxiosParamCreator(configuration).updateLootdrop(id, lootdrop, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LootdropApi - factory interface
 * @export
 */
export const LootdropApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates Lootdrop
         * @param {ModelsLootdrop} lootdrop Lootdrop
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLootdrop(lootdrop: ModelsLootdrop, options?: any): AxiosPromise<Array<ModelsLootdrop>> {
            return LootdropApiFp(configuration).createLootdrop(lootdrop, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes Lootdrop
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLootdrop(id: number, options?: any): AxiosPromise<string> {
            return LootdropApiFp(configuration).deleteLootdrop(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Lootdrop
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;LootdropEntries&lt;br&gt;LootdropEntries.Item&lt;br&gt;LootdropEntries.Item.DiscoveredItems
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLootdrop(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsLootdrop>> {
            return LootdropApiFp(configuration).getLootdrop(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists Lootdrops
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;LootdropEntries&lt;br&gt;LootdropEntries.Item&lt;br&gt;LootdropEntries.Item.DiscoveredItems
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLootdrops(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsLootdrop>> {
            return LootdropApiFp(configuration).listLootdrops(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates Lootdrop
         * @param {number} id Id
         * @param {ModelsLootdrop} lootdrop Lootdrop
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLootdrop(id: number, lootdrop: ModelsLootdrop, options?: any): AxiosPromise<Array<ModelsLootdrop>> {
            return LootdropApiFp(configuration).updateLootdrop(id, lootdrop, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createLootdrop operation in LootdropApi.
 * @export
 * @interface LootdropApiCreateLootdropRequest
 */
export interface LootdropApiCreateLootdropRequest {
    /**
     * Lootdrop
     * @type {ModelsLootdrop}
     * @memberof LootdropApiCreateLootdrop
     */
    readonly lootdrop: ModelsLootdrop
}

/**
 * Request parameters for deleteLootdrop operation in LootdropApi.
 * @export
 * @interface LootdropApiDeleteLootdropRequest
 */
export interface LootdropApiDeleteLootdropRequest {
    /**
     * Id
     * @type {number}
     * @memberof LootdropApiDeleteLootdrop
     */
    readonly id: number
}

/**
 * Request parameters for getLootdrop operation in LootdropApi.
 * @export
 * @interface LootdropApiGetLootdropRequest
 */
export interface LootdropApiGetLootdropRequest {
    /**
     * Id
     * @type {number}
     * @memberof LootdropApiGetLootdrop
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;LootdropEntries&lt;br&gt;LootdropEntries.Item&lt;br&gt;LootdropEntries.Item.DiscoveredItems
     * @type {string}
     * @memberof LootdropApiGetLootdrop
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof LootdropApiGetLootdrop
     */
    readonly select?: string
}

/**
 * Request parameters for listLootdrops operation in LootdropApi.
 * @export
 * @interface LootdropApiListLootdropsRequest
 */
export interface LootdropApiListLootdropsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;LootdropEntries&lt;br&gt;LootdropEntries.Item&lt;br&gt;LootdropEntries.Item.DiscoveredItems
     * @type {string}
     * @memberof LootdropApiListLootdrops
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof LootdropApiListLootdrops
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof LootdropApiListLootdrops
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof LootdropApiListLootdrops
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof LootdropApiListLootdrops
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof LootdropApiListLootdrops
     */
    readonly select?: string
}

/**
 * Request parameters for updateLootdrop operation in LootdropApi.
 * @export
 * @interface LootdropApiUpdateLootdropRequest
 */
export interface LootdropApiUpdateLootdropRequest {
    /**
     * Id
     * @type {number}
     * @memberof LootdropApiUpdateLootdrop
     */
    readonly id: number

    /**
     * Lootdrop
     * @type {ModelsLootdrop}
     * @memberof LootdropApiUpdateLootdrop
     */
    readonly lootdrop: ModelsLootdrop
}

/**
 * LootdropApi - object-oriented interface
 * @export
 * @class LootdropApi
 * @extends {BaseAPI}
 */
export class LootdropApi extends BaseAPI {
    /**
     * 
     * @summary Creates Lootdrop
     * @param {LootdropApiCreateLootdropRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LootdropApi
     */
    public createLootdrop(requestParameters: LootdropApiCreateLootdropRequest, options?: any) {
        return LootdropApiFp(this.configuration).createLootdrop(requestParameters.lootdrop, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes Lootdrop
     * @param {LootdropApiDeleteLootdropRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LootdropApi
     */
    public deleteLootdrop(requestParameters: LootdropApiDeleteLootdropRequest, options?: any) {
        return LootdropApiFp(this.configuration).deleteLootdrop(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Lootdrop
     * @param {LootdropApiGetLootdropRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LootdropApi
     */
    public getLootdrop(requestParameters: LootdropApiGetLootdropRequest, options?: any) {
        return LootdropApiFp(this.configuration).getLootdrop(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists Lootdrops
     * @param {LootdropApiListLootdropsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LootdropApi
     */
    public listLootdrops(requestParameters: LootdropApiListLootdropsRequest = {}, options?: any) {
        return LootdropApiFp(this.configuration).listLootdrops(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates Lootdrop
     * @param {LootdropApiUpdateLootdropRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LootdropApi
     */
    public updateLootdrop(requestParameters: LootdropApiUpdateLootdropRequest, options?: any) {
        return LootdropApiFp(this.configuration).updateLootdrop(requestParameters.id, requestParameters.lootdrop, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LoottableApi - axios parameter creator
 * @export
 */
export const LoottableApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Loottable
         * @param {ModelsLoottable} loottable Loottable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLoottable: async (loottable: ModelsLoottable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'loottable' is not null or undefined
            if (loottable === null || loottable === undefined) {
                throw new RequiredError('loottable','Required parameter loottable was null or undefined when calling createLoottable.');
            }
            const localVarPath = `/loottable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof loottable !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(loottable !== undefined ? loottable : {})
                : (loottable || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes Loottable
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLoottable: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteLoottable.');
            }
            const localVarPath = `/loottable/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Loottable
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;LoottableEntries&lt;br&gt;LoottableEntries.LootdropEntries&lt;br&gt;LoottableEntries.LootdropEntries.Item&lt;br&gt;LoottableEntries.LootdropEntries.Item.DiscoveredItems
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoottable: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getLoottable.');
            }
            const localVarPath = `/loottable/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists Loottables
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;LoottableEntries&lt;br&gt;LoottableEntries.LootdropEntries&lt;br&gt;LoottableEntries.LootdropEntries.Item&lt;br&gt;LoottableEntries.LootdropEntries.Item.DiscoveredItems
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLoottables: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/loottables`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates Loottable
         * @param {number} id Id
         * @param {ModelsLoottable} loottable Loottable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLoottable: async (id: number, loottable: ModelsLoottable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateLoottable.');
            }
            // verify required parameter 'loottable' is not null or undefined
            if (loottable === null || loottable === undefined) {
                throw new RequiredError('loottable','Required parameter loottable was null or undefined when calling updateLoottable.');
            }
            const localVarPath = `/loottable/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof loottable !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(loottable !== undefined ? loottable : {})
                : (loottable || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LoottableApi - functional programming interface
 * @export
 */
export const LoottableApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Loottable
         * @param {ModelsLoottable} loottable Loottable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLoottable(loottable: ModelsLoottable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLoottable>>> {
            const localVarAxiosArgs = await LoottableApiAxiosParamCreator(configuration).createLoottable(loottable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes Loottable
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLoottable(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await LoottableApiAxiosParamCreator(configuration).deleteLoottable(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Loottable
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;LoottableEntries&lt;br&gt;LoottableEntries.LootdropEntries&lt;br&gt;LoottableEntries.LootdropEntries.Item&lt;br&gt;LoottableEntries.LootdropEntries.Item.DiscoveredItems
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLoottable(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLoottable>>> {
            const localVarAxiosArgs = await LoottableApiAxiosParamCreator(configuration).getLoottable(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists Loottables
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;LoottableEntries&lt;br&gt;LoottableEntries.LootdropEntries&lt;br&gt;LoottableEntries.LootdropEntries.Item&lt;br&gt;LoottableEntries.LootdropEntries.Item.DiscoveredItems
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLoottables(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLoottable>>> {
            const localVarAxiosArgs = await LoottableApiAxiosParamCreator(configuration).listLoottables(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates Loottable
         * @param {number} id Id
         * @param {ModelsLoottable} loottable Loottable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLoottable(id: number, loottable: ModelsLoottable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsLoottable>>> {
            const localVarAxiosArgs = await LoottableApiAxiosParamCreator(configuration).updateLoottable(id, loottable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LoottableApi - factory interface
 * @export
 */
export const LoottableApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates Loottable
         * @param {ModelsLoottable} loottable Loottable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLoottable(loottable: ModelsLoottable, options?: any): AxiosPromise<Array<ModelsLoottable>> {
            return LoottableApiFp(configuration).createLoottable(loottable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes Loottable
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLoottable(id: number, options?: any): AxiosPromise<string> {
            return LoottableApiFp(configuration).deleteLoottable(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Loottable
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;LoottableEntries&lt;br&gt;LoottableEntries.LootdropEntries&lt;br&gt;LoottableEntries.LootdropEntries.Item&lt;br&gt;LoottableEntries.LootdropEntries.Item.DiscoveredItems
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoottable(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsLoottable>> {
            return LoottableApiFp(configuration).getLoottable(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists Loottables
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;LoottableEntries&lt;br&gt;LoottableEntries.LootdropEntries&lt;br&gt;LoottableEntries.LootdropEntries.Item&lt;br&gt;LoottableEntries.LootdropEntries.Item.DiscoveredItems
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLoottables(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsLoottable>> {
            return LoottableApiFp(configuration).listLoottables(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates Loottable
         * @param {number} id Id
         * @param {ModelsLoottable} loottable Loottable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLoottable(id: number, loottable: ModelsLoottable, options?: any): AxiosPromise<Array<ModelsLoottable>> {
            return LoottableApiFp(configuration).updateLoottable(id, loottable, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createLoottable operation in LoottableApi.
 * @export
 * @interface LoottableApiCreateLoottableRequest
 */
export interface LoottableApiCreateLoottableRequest {
    /**
     * Loottable
     * @type {ModelsLoottable}
     * @memberof LoottableApiCreateLoottable
     */
    readonly loottable: ModelsLoottable
}

/**
 * Request parameters for deleteLoottable operation in LoottableApi.
 * @export
 * @interface LoottableApiDeleteLoottableRequest
 */
export interface LoottableApiDeleteLoottableRequest {
    /**
     * Id
     * @type {number}
     * @memberof LoottableApiDeleteLoottable
     */
    readonly id: number
}

/**
 * Request parameters for getLoottable operation in LoottableApi.
 * @export
 * @interface LoottableApiGetLoottableRequest
 */
export interface LoottableApiGetLoottableRequest {
    /**
     * Id
     * @type {number}
     * @memberof LoottableApiGetLoottable
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;LoottableEntries&lt;br&gt;LoottableEntries.LootdropEntries&lt;br&gt;LoottableEntries.LootdropEntries.Item&lt;br&gt;LoottableEntries.LootdropEntries.Item.DiscoveredItems
     * @type {string}
     * @memberof LoottableApiGetLoottable
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof LoottableApiGetLoottable
     */
    readonly select?: string
}

/**
 * Request parameters for listLoottables operation in LoottableApi.
 * @export
 * @interface LoottableApiListLoottablesRequest
 */
export interface LoottableApiListLoottablesRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;LoottableEntries&lt;br&gt;LoottableEntries.LootdropEntries&lt;br&gt;LoottableEntries.LootdropEntries.Item&lt;br&gt;LoottableEntries.LootdropEntries.Item.DiscoveredItems
     * @type {string}
     * @memberof LoottableApiListLoottables
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof LoottableApiListLoottables
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof LoottableApiListLoottables
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof LoottableApiListLoottables
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof LoottableApiListLoottables
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof LoottableApiListLoottables
     */
    readonly select?: string
}

/**
 * Request parameters for updateLoottable operation in LoottableApi.
 * @export
 * @interface LoottableApiUpdateLoottableRequest
 */
export interface LoottableApiUpdateLoottableRequest {
    /**
     * Id
     * @type {number}
     * @memberof LoottableApiUpdateLoottable
     */
    readonly id: number

    /**
     * Loottable
     * @type {ModelsLoottable}
     * @memberof LoottableApiUpdateLoottable
     */
    readonly loottable: ModelsLoottable
}

/**
 * LoottableApi - object-oriented interface
 * @export
 * @class LoottableApi
 * @extends {BaseAPI}
 */
export class LoottableApi extends BaseAPI {
    /**
     * 
     * @summary Creates Loottable
     * @param {LoottableApiCreateLoottableRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoottableApi
     */
    public createLoottable(requestParameters: LoottableApiCreateLoottableRequest, options?: any) {
        return LoottableApiFp(this.configuration).createLoottable(requestParameters.loottable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes Loottable
     * @param {LoottableApiDeleteLoottableRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoottableApi
     */
    public deleteLoottable(requestParameters: LoottableApiDeleteLoottableRequest, options?: any) {
        return LoottableApiFp(this.configuration).deleteLoottable(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Loottable
     * @param {LoottableApiGetLoottableRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoottableApi
     */
    public getLoottable(requestParameters: LoottableApiGetLoottableRequest, options?: any) {
        return LoottableApiFp(this.configuration).getLoottable(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists Loottables
     * @param {LoottableApiListLoottablesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoottableApi
     */
    public listLoottables(requestParameters: LoottableApiListLoottablesRequest = {}, options?: any) {
        return LoottableApiFp(this.configuration).listLoottables(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates Loottable
     * @param {LoottableApiUpdateLoottableRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoottableApi
     */
    public updateLoottable(requestParameters: LoottableApiUpdateLoottableRequest, options?: any) {
        return LoottableApiFp(this.configuration).updateLoottable(requestParameters.id, requestParameters.loottable, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MeApi - axios parameter creator
 * @export
 */
export const MeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns current logged in user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        me: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeApi - functional programming interface
 * @export
 */
export const MeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns current logged in user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async me(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsUser>>> {
            const localVarAxiosArgs = await MeApiAxiosParamCreator(configuration).me(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * MeApi - factory interface
 * @export
 */
export const MeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Returns current logged in user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        me(options?: any): AxiosPromise<Array<ModelsUser>> {
            return MeApiFp(configuration).me(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MeApi - object-oriented interface
 * @export
 * @class MeApi
 * @extends {BaseAPI}
 */
export class MeApi extends BaseAPI {
    /**
     * 
     * @summary Returns current logged in user information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public me(options?: any) {
        return MeApiFp(this.configuration).me(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MerchantlistApi - axios parameter creator
 * @export
 */
export const MerchantlistApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Merchantlist
         * @param {ModelsMerchantlist} merchantlist Merchantlist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMerchantlist: async (merchantlist: ModelsMerchantlist, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'merchantlist' is not null or undefined
            if (merchantlist === null || merchantlist === undefined) {
                throw new RequiredError('merchantlist','Required parameter merchantlist was null or undefined when calling createMerchantlist.');
            }
            const localVarPath = `/merchantlist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof merchantlist !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(merchantlist !== undefined ? merchantlist : {})
                : (merchantlist || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes Merchantlist
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMerchantlist: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteMerchantlist.');
            }
            const localVarPath = `/merchantlist/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Merchantlist
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMerchantlist: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getMerchantlist.');
            }
            const localVarPath = `/merchantlist/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists Merchantlists
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMerchantlists: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/merchantlists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates Merchantlist
         * @param {number} id Id
         * @param {ModelsMerchantlist} merchantlist Merchantlist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMerchantlist: async (id: number, merchantlist: ModelsMerchantlist, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateMerchantlist.');
            }
            // verify required parameter 'merchantlist' is not null or undefined
            if (merchantlist === null || merchantlist === undefined) {
                throw new RequiredError('merchantlist','Required parameter merchantlist was null or undefined when calling updateMerchantlist.');
            }
            const localVarPath = `/merchantlist/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof merchantlist !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(merchantlist !== undefined ? merchantlist : {})
                : (merchantlist || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MerchantlistApi - functional programming interface
 * @export
 */
export const MerchantlistApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Merchantlist
         * @param {ModelsMerchantlist} merchantlist Merchantlist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMerchantlist(merchantlist: ModelsMerchantlist, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsMerchantlist>>> {
            const localVarAxiosArgs = await MerchantlistApiAxiosParamCreator(configuration).createMerchantlist(merchantlist, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes Merchantlist
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMerchantlist(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await MerchantlistApiAxiosParamCreator(configuration).deleteMerchantlist(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Merchantlist
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMerchantlist(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsMerchantlist>>> {
            const localVarAxiosArgs = await MerchantlistApiAxiosParamCreator(configuration).getMerchantlist(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists Merchantlists
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMerchantlists(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsMerchantlist>>> {
            const localVarAxiosArgs = await MerchantlistApiAxiosParamCreator(configuration).listMerchantlists(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates Merchantlist
         * @param {number} id Id
         * @param {ModelsMerchantlist} merchantlist Merchantlist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMerchantlist(id: number, merchantlist: ModelsMerchantlist, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsMerchantlist>>> {
            const localVarAxiosArgs = await MerchantlistApiAxiosParamCreator(configuration).updateMerchantlist(id, merchantlist, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * MerchantlistApi - factory interface
 * @export
 */
export const MerchantlistApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates Merchantlist
         * @param {ModelsMerchantlist} merchantlist Merchantlist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMerchantlist(merchantlist: ModelsMerchantlist, options?: any): AxiosPromise<Array<ModelsMerchantlist>> {
            return MerchantlistApiFp(configuration).createMerchantlist(merchantlist, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes Merchantlist
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMerchantlist(id: number, options?: any): AxiosPromise<string> {
            return MerchantlistApiFp(configuration).deleteMerchantlist(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Merchantlist
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMerchantlist(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsMerchantlist>> {
            return MerchantlistApiFp(configuration).getMerchantlist(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists Merchantlists
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMerchantlists(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsMerchantlist>> {
            return MerchantlistApiFp(configuration).listMerchantlists(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates Merchantlist
         * @param {number} id Id
         * @param {ModelsMerchantlist} merchantlist Merchantlist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMerchantlist(id: number, merchantlist: ModelsMerchantlist, options?: any): AxiosPromise<Array<ModelsMerchantlist>> {
            return MerchantlistApiFp(configuration).updateMerchantlist(id, merchantlist, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createMerchantlist operation in MerchantlistApi.
 * @export
 * @interface MerchantlistApiCreateMerchantlistRequest
 */
export interface MerchantlistApiCreateMerchantlistRequest {
    /**
     * Merchantlist
     * @type {ModelsMerchantlist}
     * @memberof MerchantlistApiCreateMerchantlist
     */
    readonly merchantlist: ModelsMerchantlist
}

/**
 * Request parameters for deleteMerchantlist operation in MerchantlistApi.
 * @export
 * @interface MerchantlistApiDeleteMerchantlistRequest
 */
export interface MerchantlistApiDeleteMerchantlistRequest {
    /**
     * Id
     * @type {number}
     * @memberof MerchantlistApiDeleteMerchantlist
     */
    readonly id: number
}

/**
 * Request parameters for getMerchantlist operation in MerchantlistApi.
 * @export
 * @interface MerchantlistApiGetMerchantlistRequest
 */
export interface MerchantlistApiGetMerchantlistRequest {
    /**
     * Id
     * @type {number}
     * @memberof MerchantlistApiGetMerchantlist
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof MerchantlistApiGetMerchantlist
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof MerchantlistApiGetMerchantlist
     */
    readonly select?: string
}

/**
 * Request parameters for listMerchantlists operation in MerchantlistApi.
 * @export
 * @interface MerchantlistApiListMerchantlistsRequest
 */
export interface MerchantlistApiListMerchantlistsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof MerchantlistApiListMerchantlists
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof MerchantlistApiListMerchantlists
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof MerchantlistApiListMerchantlists
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof MerchantlistApiListMerchantlists
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof MerchantlistApiListMerchantlists
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof MerchantlistApiListMerchantlists
     */
    readonly select?: string
}

/**
 * Request parameters for updateMerchantlist operation in MerchantlistApi.
 * @export
 * @interface MerchantlistApiUpdateMerchantlistRequest
 */
export interface MerchantlistApiUpdateMerchantlistRequest {
    /**
     * Id
     * @type {number}
     * @memberof MerchantlistApiUpdateMerchantlist
     */
    readonly id: number

    /**
     * Merchantlist
     * @type {ModelsMerchantlist}
     * @memberof MerchantlistApiUpdateMerchantlist
     */
    readonly merchantlist: ModelsMerchantlist
}

/**
 * MerchantlistApi - object-oriented interface
 * @export
 * @class MerchantlistApi
 * @extends {BaseAPI}
 */
export class MerchantlistApi extends BaseAPI {
    /**
     * 
     * @summary Creates Merchantlist
     * @param {MerchantlistApiCreateMerchantlistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantlistApi
     */
    public createMerchantlist(requestParameters: MerchantlistApiCreateMerchantlistRequest, options?: any) {
        return MerchantlistApiFp(this.configuration).createMerchantlist(requestParameters.merchantlist, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes Merchantlist
     * @param {MerchantlistApiDeleteMerchantlistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantlistApi
     */
    public deleteMerchantlist(requestParameters: MerchantlistApiDeleteMerchantlistRequest, options?: any) {
        return MerchantlistApiFp(this.configuration).deleteMerchantlist(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Merchantlist
     * @param {MerchantlistApiGetMerchantlistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantlistApi
     */
    public getMerchantlist(requestParameters: MerchantlistApiGetMerchantlistRequest, options?: any) {
        return MerchantlistApiFp(this.configuration).getMerchantlist(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists Merchantlists
     * @param {MerchantlistApiListMerchantlistsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantlistApi
     */
    public listMerchantlists(requestParameters: MerchantlistApiListMerchantlistsRequest = {}, options?: any) {
        return MerchantlistApiFp(this.configuration).listMerchantlists(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates Merchantlist
     * @param {MerchantlistApiUpdateMerchantlistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantlistApi
     */
    public updateMerchantlist(requestParameters: MerchantlistApiUpdateMerchantlistRequest, options?: any) {
        return MerchantlistApiFp(this.configuration).updateMerchantlist(requestParameters.id, requestParameters.merchantlist, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NameFilterApi - axios parameter creator
 * @export
 */
export const NameFilterApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates NameFilter
         * @param {ModelsNameFilter} nameFilter NameFilter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNameFilter: async (nameFilter: ModelsNameFilter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'nameFilter' is not null or undefined
            if (nameFilter === null || nameFilter === undefined) {
                throw new RequiredError('nameFilter','Required parameter nameFilter was null or undefined when calling createNameFilter.');
            }
            const localVarPath = `/name_filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof nameFilter !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(nameFilter !== undefined ? nameFilter : {})
                : (nameFilter || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes NameFilter
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNameFilter: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteNameFilter.');
            }
            const localVarPath = `/name_filter/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets NameFilter
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNameFilter: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getNameFilter.');
            }
            const localVarPath = `/name_filter/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists NameFilters
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNameFilters: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/name_filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates NameFilter
         * @param {number} id Id
         * @param {ModelsNameFilter} nameFilter NameFilter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNameFilter: async (id: number, nameFilter: ModelsNameFilter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateNameFilter.');
            }
            // verify required parameter 'nameFilter' is not null or undefined
            if (nameFilter === null || nameFilter === undefined) {
                throw new RequiredError('nameFilter','Required parameter nameFilter was null or undefined when calling updateNameFilter.');
            }
            const localVarPath = `/name_filter/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof nameFilter !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(nameFilter !== undefined ? nameFilter : {})
                : (nameFilter || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NameFilterApi - functional programming interface
 * @export
 */
export const NameFilterApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates NameFilter
         * @param {ModelsNameFilter} nameFilter NameFilter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNameFilter(nameFilter: ModelsNameFilter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsNameFilter>>> {
            const localVarAxiosArgs = await NameFilterApiAxiosParamCreator(configuration).createNameFilter(nameFilter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes NameFilter
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNameFilter(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await NameFilterApiAxiosParamCreator(configuration).deleteNameFilter(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets NameFilter
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNameFilter(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsNameFilter>>> {
            const localVarAxiosArgs = await NameFilterApiAxiosParamCreator(configuration).getNameFilter(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists NameFilters
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNameFilters(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsNameFilter>>> {
            const localVarAxiosArgs = await NameFilterApiAxiosParamCreator(configuration).listNameFilters(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates NameFilter
         * @param {number} id Id
         * @param {ModelsNameFilter} nameFilter NameFilter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNameFilter(id: number, nameFilter: ModelsNameFilter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsNameFilter>>> {
            const localVarAxiosArgs = await NameFilterApiAxiosParamCreator(configuration).updateNameFilter(id, nameFilter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * NameFilterApi - factory interface
 * @export
 */
export const NameFilterApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates NameFilter
         * @param {ModelsNameFilter} nameFilter NameFilter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNameFilter(nameFilter: ModelsNameFilter, options?: any): AxiosPromise<Array<ModelsNameFilter>> {
            return NameFilterApiFp(configuration).createNameFilter(nameFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes NameFilter
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNameFilter(id: number, options?: any): AxiosPromise<string> {
            return NameFilterApiFp(configuration).deleteNameFilter(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets NameFilter
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNameFilter(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsNameFilter>> {
            return NameFilterApiFp(configuration).getNameFilter(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists NameFilters
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNameFilters(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsNameFilter>> {
            return NameFilterApiFp(configuration).listNameFilters(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates NameFilter
         * @param {number} id Id
         * @param {ModelsNameFilter} nameFilter NameFilter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNameFilter(id: number, nameFilter: ModelsNameFilter, options?: any): AxiosPromise<Array<ModelsNameFilter>> {
            return NameFilterApiFp(configuration).updateNameFilter(id, nameFilter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createNameFilter operation in NameFilterApi.
 * @export
 * @interface NameFilterApiCreateNameFilterRequest
 */
export interface NameFilterApiCreateNameFilterRequest {
    /**
     * NameFilter
     * @type {ModelsNameFilter}
     * @memberof NameFilterApiCreateNameFilter
     */
    readonly nameFilter: ModelsNameFilter
}

/**
 * Request parameters for deleteNameFilter operation in NameFilterApi.
 * @export
 * @interface NameFilterApiDeleteNameFilterRequest
 */
export interface NameFilterApiDeleteNameFilterRequest {
    /**
     * Id
     * @type {number}
     * @memberof NameFilterApiDeleteNameFilter
     */
    readonly id: number
}

/**
 * Request parameters for getNameFilter operation in NameFilterApi.
 * @export
 * @interface NameFilterApiGetNameFilterRequest
 */
export interface NameFilterApiGetNameFilterRequest {
    /**
     * Id
     * @type {number}
     * @memberof NameFilterApiGetNameFilter
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof NameFilterApiGetNameFilter
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof NameFilterApiGetNameFilter
     */
    readonly select?: string
}

/**
 * Request parameters for listNameFilters operation in NameFilterApi.
 * @export
 * @interface NameFilterApiListNameFiltersRequest
 */
export interface NameFilterApiListNameFiltersRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof NameFilterApiListNameFilters
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof NameFilterApiListNameFilters
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof NameFilterApiListNameFilters
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof NameFilterApiListNameFilters
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof NameFilterApiListNameFilters
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof NameFilterApiListNameFilters
     */
    readonly select?: string
}

/**
 * Request parameters for updateNameFilter operation in NameFilterApi.
 * @export
 * @interface NameFilterApiUpdateNameFilterRequest
 */
export interface NameFilterApiUpdateNameFilterRequest {
    /**
     * Id
     * @type {number}
     * @memberof NameFilterApiUpdateNameFilter
     */
    readonly id: number

    /**
     * NameFilter
     * @type {ModelsNameFilter}
     * @memberof NameFilterApiUpdateNameFilter
     */
    readonly nameFilter: ModelsNameFilter
}

/**
 * NameFilterApi - object-oriented interface
 * @export
 * @class NameFilterApi
 * @extends {BaseAPI}
 */
export class NameFilterApi extends BaseAPI {
    /**
     * 
     * @summary Creates NameFilter
     * @param {NameFilterApiCreateNameFilterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NameFilterApi
     */
    public createNameFilter(requestParameters: NameFilterApiCreateNameFilterRequest, options?: any) {
        return NameFilterApiFp(this.configuration).createNameFilter(requestParameters.nameFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes NameFilter
     * @param {NameFilterApiDeleteNameFilterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NameFilterApi
     */
    public deleteNameFilter(requestParameters: NameFilterApiDeleteNameFilterRequest, options?: any) {
        return NameFilterApiFp(this.configuration).deleteNameFilter(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets NameFilter
     * @param {NameFilterApiGetNameFilterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NameFilterApi
     */
    public getNameFilter(requestParameters: NameFilterApiGetNameFilterRequest, options?: any) {
        return NameFilterApiFp(this.configuration).getNameFilter(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists NameFilters
     * @param {NameFilterApiListNameFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NameFilterApi
     */
    public listNameFilters(requestParameters: NameFilterApiListNameFiltersRequest = {}, options?: any) {
        return NameFilterApiFp(this.configuration).listNameFilters(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates NameFilter
     * @param {NameFilterApiUpdateNameFilterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NameFilterApi
     */
    public updateNameFilter(requestParameters: NameFilterApiUpdateNameFilterRequest, options?: any) {
        return NameFilterApiFp(this.configuration).updateNameFilter(requestParameters.id, requestParameters.nameFilter, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NpcEmoteApi - axios parameter creator
 * @export
 */
export const NpcEmoteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates NpcEmote
         * @param {ModelsNpcEmote} npcEmote NpcEmote
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNpcEmote: async (npcEmote: ModelsNpcEmote, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'npcEmote' is not null or undefined
            if (npcEmote === null || npcEmote === undefined) {
                throw new RequiredError('npcEmote','Required parameter npcEmote was null or undefined when calling createNpcEmote.');
            }
            const localVarPath = `/npc_emote`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof npcEmote !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(npcEmote !== undefined ? npcEmote : {})
                : (npcEmote || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes NpcEmote
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNpcEmote: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteNpcEmote.');
            }
            const localVarPath = `/npc_emote/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets NpcEmote
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNpcEmote: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getNpcEmote.');
            }
            const localVarPath = `/npc_emote/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists NpcEmotes
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNpcEmotes: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/npc_emotes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates NpcEmote
         * @param {number} id Id
         * @param {ModelsNpcEmote} npcEmote NpcEmote
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNpcEmote: async (id: number, npcEmote: ModelsNpcEmote, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateNpcEmote.');
            }
            // verify required parameter 'npcEmote' is not null or undefined
            if (npcEmote === null || npcEmote === undefined) {
                throw new RequiredError('npcEmote','Required parameter npcEmote was null or undefined when calling updateNpcEmote.');
            }
            const localVarPath = `/npc_emote/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof npcEmote !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(npcEmote !== undefined ? npcEmote : {})
                : (npcEmote || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NpcEmoteApi - functional programming interface
 * @export
 */
export const NpcEmoteApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates NpcEmote
         * @param {ModelsNpcEmote} npcEmote NpcEmote
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNpcEmote(npcEmote: ModelsNpcEmote, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsNpcEmote>>> {
            const localVarAxiosArgs = await NpcEmoteApiAxiosParamCreator(configuration).createNpcEmote(npcEmote, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes NpcEmote
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNpcEmote(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await NpcEmoteApiAxiosParamCreator(configuration).deleteNpcEmote(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets NpcEmote
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNpcEmote(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsNpcEmote>>> {
            const localVarAxiosArgs = await NpcEmoteApiAxiosParamCreator(configuration).getNpcEmote(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists NpcEmotes
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNpcEmotes(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsNpcEmote>>> {
            const localVarAxiosArgs = await NpcEmoteApiAxiosParamCreator(configuration).listNpcEmotes(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates NpcEmote
         * @param {number} id Id
         * @param {ModelsNpcEmote} npcEmote NpcEmote
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNpcEmote(id: number, npcEmote: ModelsNpcEmote, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsNpcEmote>>> {
            const localVarAxiosArgs = await NpcEmoteApiAxiosParamCreator(configuration).updateNpcEmote(id, npcEmote, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * NpcEmoteApi - factory interface
 * @export
 */
export const NpcEmoteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates NpcEmote
         * @param {ModelsNpcEmote} npcEmote NpcEmote
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNpcEmote(npcEmote: ModelsNpcEmote, options?: any): AxiosPromise<Array<ModelsNpcEmote>> {
            return NpcEmoteApiFp(configuration).createNpcEmote(npcEmote, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes NpcEmote
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNpcEmote(id: number, options?: any): AxiosPromise<string> {
            return NpcEmoteApiFp(configuration).deleteNpcEmote(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets NpcEmote
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNpcEmote(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsNpcEmote>> {
            return NpcEmoteApiFp(configuration).getNpcEmote(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists NpcEmotes
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNpcEmotes(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsNpcEmote>> {
            return NpcEmoteApiFp(configuration).listNpcEmotes(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates NpcEmote
         * @param {number} id Id
         * @param {ModelsNpcEmote} npcEmote NpcEmote
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNpcEmote(id: number, npcEmote: ModelsNpcEmote, options?: any): AxiosPromise<Array<ModelsNpcEmote>> {
            return NpcEmoteApiFp(configuration).updateNpcEmote(id, npcEmote, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createNpcEmote operation in NpcEmoteApi.
 * @export
 * @interface NpcEmoteApiCreateNpcEmoteRequest
 */
export interface NpcEmoteApiCreateNpcEmoteRequest {
    /**
     * NpcEmote
     * @type {ModelsNpcEmote}
     * @memberof NpcEmoteApiCreateNpcEmote
     */
    readonly npcEmote: ModelsNpcEmote
}

/**
 * Request parameters for deleteNpcEmote operation in NpcEmoteApi.
 * @export
 * @interface NpcEmoteApiDeleteNpcEmoteRequest
 */
export interface NpcEmoteApiDeleteNpcEmoteRequest {
    /**
     * Id
     * @type {number}
     * @memberof NpcEmoteApiDeleteNpcEmote
     */
    readonly id: number
}

/**
 * Request parameters for getNpcEmote operation in NpcEmoteApi.
 * @export
 * @interface NpcEmoteApiGetNpcEmoteRequest
 */
export interface NpcEmoteApiGetNpcEmoteRequest {
    /**
     * Id
     * @type {number}
     * @memberof NpcEmoteApiGetNpcEmote
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof NpcEmoteApiGetNpcEmote
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof NpcEmoteApiGetNpcEmote
     */
    readonly select?: string
}

/**
 * Request parameters for listNpcEmotes operation in NpcEmoteApi.
 * @export
 * @interface NpcEmoteApiListNpcEmotesRequest
 */
export interface NpcEmoteApiListNpcEmotesRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof NpcEmoteApiListNpcEmotes
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof NpcEmoteApiListNpcEmotes
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof NpcEmoteApiListNpcEmotes
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof NpcEmoteApiListNpcEmotes
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof NpcEmoteApiListNpcEmotes
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof NpcEmoteApiListNpcEmotes
     */
    readonly select?: string
}

/**
 * Request parameters for updateNpcEmote operation in NpcEmoteApi.
 * @export
 * @interface NpcEmoteApiUpdateNpcEmoteRequest
 */
export interface NpcEmoteApiUpdateNpcEmoteRequest {
    /**
     * Id
     * @type {number}
     * @memberof NpcEmoteApiUpdateNpcEmote
     */
    readonly id: number

    /**
     * NpcEmote
     * @type {ModelsNpcEmote}
     * @memberof NpcEmoteApiUpdateNpcEmote
     */
    readonly npcEmote: ModelsNpcEmote
}

/**
 * NpcEmoteApi - object-oriented interface
 * @export
 * @class NpcEmoteApi
 * @extends {BaseAPI}
 */
export class NpcEmoteApi extends BaseAPI {
    /**
     * 
     * @summary Creates NpcEmote
     * @param {NpcEmoteApiCreateNpcEmoteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcEmoteApi
     */
    public createNpcEmote(requestParameters: NpcEmoteApiCreateNpcEmoteRequest, options?: any) {
        return NpcEmoteApiFp(this.configuration).createNpcEmote(requestParameters.npcEmote, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes NpcEmote
     * @param {NpcEmoteApiDeleteNpcEmoteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcEmoteApi
     */
    public deleteNpcEmote(requestParameters: NpcEmoteApiDeleteNpcEmoteRequest, options?: any) {
        return NpcEmoteApiFp(this.configuration).deleteNpcEmote(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets NpcEmote
     * @param {NpcEmoteApiGetNpcEmoteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcEmoteApi
     */
    public getNpcEmote(requestParameters: NpcEmoteApiGetNpcEmoteRequest, options?: any) {
        return NpcEmoteApiFp(this.configuration).getNpcEmote(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists NpcEmotes
     * @param {NpcEmoteApiListNpcEmotesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcEmoteApi
     */
    public listNpcEmotes(requestParameters: NpcEmoteApiListNpcEmotesRequest = {}, options?: any) {
        return NpcEmoteApiFp(this.configuration).listNpcEmotes(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates NpcEmote
     * @param {NpcEmoteApiUpdateNpcEmoteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcEmoteApi
     */
    public updateNpcEmote(requestParameters: NpcEmoteApiUpdateNpcEmoteRequest, options?: any) {
        return NpcEmoteApiFp(this.configuration).updateNpcEmote(requestParameters.id, requestParameters.npcEmote, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NpcFactionApi - axios parameter creator
 * @export
 */
export const NpcFactionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates NpcFaction
         * @param {ModelsNpcFaction} npcFaction NpcFaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNpcFaction: async (npcFaction: ModelsNpcFaction, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'npcFaction' is not null or undefined
            if (npcFaction === null || npcFaction === undefined) {
                throw new RequiredError('npcFaction','Required parameter npcFaction was null or undefined when calling createNpcFaction.');
            }
            const localVarPath = `/npc_faction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof npcFaction !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(npcFaction !== undefined ? npcFaction : {})
                : (npcFaction || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes NpcFaction
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNpcFaction: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteNpcFaction.');
            }
            const localVarPath = `/npc_faction/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets NpcFaction
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;NpcFactionEntries
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNpcFaction: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getNpcFaction.');
            }
            const localVarPath = `/npc_faction/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists NpcFactions
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;NpcFactionEntries
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNpcFactions: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/npc_factions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates NpcFaction
         * @param {number} id Id
         * @param {ModelsNpcFaction} npcFaction NpcFaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNpcFaction: async (id: number, npcFaction: ModelsNpcFaction, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateNpcFaction.');
            }
            // verify required parameter 'npcFaction' is not null or undefined
            if (npcFaction === null || npcFaction === undefined) {
                throw new RequiredError('npcFaction','Required parameter npcFaction was null or undefined when calling updateNpcFaction.');
            }
            const localVarPath = `/npc_faction/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof npcFaction !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(npcFaction !== undefined ? npcFaction : {})
                : (npcFaction || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NpcFactionApi - functional programming interface
 * @export
 */
export const NpcFactionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates NpcFaction
         * @param {ModelsNpcFaction} npcFaction NpcFaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNpcFaction(npcFaction: ModelsNpcFaction, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsNpcFaction>>> {
            const localVarAxiosArgs = await NpcFactionApiAxiosParamCreator(configuration).createNpcFaction(npcFaction, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes NpcFaction
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNpcFaction(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await NpcFactionApiAxiosParamCreator(configuration).deleteNpcFaction(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets NpcFaction
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;NpcFactionEntries
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNpcFaction(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsNpcFaction>>> {
            const localVarAxiosArgs = await NpcFactionApiAxiosParamCreator(configuration).getNpcFaction(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists NpcFactions
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;NpcFactionEntries
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNpcFactions(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsNpcFaction>>> {
            const localVarAxiosArgs = await NpcFactionApiAxiosParamCreator(configuration).listNpcFactions(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates NpcFaction
         * @param {number} id Id
         * @param {ModelsNpcFaction} npcFaction NpcFaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNpcFaction(id: number, npcFaction: ModelsNpcFaction, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsNpcFaction>>> {
            const localVarAxiosArgs = await NpcFactionApiAxiosParamCreator(configuration).updateNpcFaction(id, npcFaction, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * NpcFactionApi - factory interface
 * @export
 */
export const NpcFactionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates NpcFaction
         * @param {ModelsNpcFaction} npcFaction NpcFaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNpcFaction(npcFaction: ModelsNpcFaction, options?: any): AxiosPromise<Array<ModelsNpcFaction>> {
            return NpcFactionApiFp(configuration).createNpcFaction(npcFaction, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes NpcFaction
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNpcFaction(id: number, options?: any): AxiosPromise<string> {
            return NpcFactionApiFp(configuration).deleteNpcFaction(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets NpcFaction
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;NpcFactionEntries
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNpcFaction(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsNpcFaction>> {
            return NpcFactionApiFp(configuration).getNpcFaction(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists NpcFactions
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;NpcFactionEntries
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNpcFactions(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsNpcFaction>> {
            return NpcFactionApiFp(configuration).listNpcFactions(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates NpcFaction
         * @param {number} id Id
         * @param {ModelsNpcFaction} npcFaction NpcFaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNpcFaction(id: number, npcFaction: ModelsNpcFaction, options?: any): AxiosPromise<Array<ModelsNpcFaction>> {
            return NpcFactionApiFp(configuration).updateNpcFaction(id, npcFaction, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createNpcFaction operation in NpcFactionApi.
 * @export
 * @interface NpcFactionApiCreateNpcFactionRequest
 */
export interface NpcFactionApiCreateNpcFactionRequest {
    /**
     * NpcFaction
     * @type {ModelsNpcFaction}
     * @memberof NpcFactionApiCreateNpcFaction
     */
    readonly npcFaction: ModelsNpcFaction
}

/**
 * Request parameters for deleteNpcFaction operation in NpcFactionApi.
 * @export
 * @interface NpcFactionApiDeleteNpcFactionRequest
 */
export interface NpcFactionApiDeleteNpcFactionRequest {
    /**
     * Id
     * @type {number}
     * @memberof NpcFactionApiDeleteNpcFaction
     */
    readonly id: number
}

/**
 * Request parameters for getNpcFaction operation in NpcFactionApi.
 * @export
 * @interface NpcFactionApiGetNpcFactionRequest
 */
export interface NpcFactionApiGetNpcFactionRequest {
    /**
     * Id
     * @type {number}
     * @memberof NpcFactionApiGetNpcFaction
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;NpcFactionEntries
     * @type {string}
     * @memberof NpcFactionApiGetNpcFaction
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof NpcFactionApiGetNpcFaction
     */
    readonly select?: string
}

/**
 * Request parameters for listNpcFactions operation in NpcFactionApi.
 * @export
 * @interface NpcFactionApiListNpcFactionsRequest
 */
export interface NpcFactionApiListNpcFactionsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;NpcFactionEntries
     * @type {string}
     * @memberof NpcFactionApiListNpcFactions
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof NpcFactionApiListNpcFactions
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof NpcFactionApiListNpcFactions
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof NpcFactionApiListNpcFactions
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof NpcFactionApiListNpcFactions
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof NpcFactionApiListNpcFactions
     */
    readonly select?: string
}

/**
 * Request parameters for updateNpcFaction operation in NpcFactionApi.
 * @export
 * @interface NpcFactionApiUpdateNpcFactionRequest
 */
export interface NpcFactionApiUpdateNpcFactionRequest {
    /**
     * Id
     * @type {number}
     * @memberof NpcFactionApiUpdateNpcFaction
     */
    readonly id: number

    /**
     * NpcFaction
     * @type {ModelsNpcFaction}
     * @memberof NpcFactionApiUpdateNpcFaction
     */
    readonly npcFaction: ModelsNpcFaction
}

/**
 * NpcFactionApi - object-oriented interface
 * @export
 * @class NpcFactionApi
 * @extends {BaseAPI}
 */
export class NpcFactionApi extends BaseAPI {
    /**
     * 
     * @summary Creates NpcFaction
     * @param {NpcFactionApiCreateNpcFactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcFactionApi
     */
    public createNpcFaction(requestParameters: NpcFactionApiCreateNpcFactionRequest, options?: any) {
        return NpcFactionApiFp(this.configuration).createNpcFaction(requestParameters.npcFaction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes NpcFaction
     * @param {NpcFactionApiDeleteNpcFactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcFactionApi
     */
    public deleteNpcFaction(requestParameters: NpcFactionApiDeleteNpcFactionRequest, options?: any) {
        return NpcFactionApiFp(this.configuration).deleteNpcFaction(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets NpcFaction
     * @param {NpcFactionApiGetNpcFactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcFactionApi
     */
    public getNpcFaction(requestParameters: NpcFactionApiGetNpcFactionRequest, options?: any) {
        return NpcFactionApiFp(this.configuration).getNpcFaction(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists NpcFactions
     * @param {NpcFactionApiListNpcFactionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcFactionApi
     */
    public listNpcFactions(requestParameters: NpcFactionApiListNpcFactionsRequest = {}, options?: any) {
        return NpcFactionApiFp(this.configuration).listNpcFactions(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates NpcFaction
     * @param {NpcFactionApiUpdateNpcFactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcFactionApi
     */
    public updateNpcFaction(requestParameters: NpcFactionApiUpdateNpcFactionRequest, options?: any) {
        return NpcFactionApiFp(this.configuration).updateNpcFaction(requestParameters.id, requestParameters.npcFaction, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NpcScaleGlobalBaseApi - axios parameter creator
 * @export
 */
export const NpcScaleGlobalBaseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates NpcScaleGlobalBase
         * @param {ModelsNpcScaleGlobalBase} npcScaleGlobalBase NpcScaleGlobalBase
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNpcScaleGlobalBase: async (npcScaleGlobalBase: ModelsNpcScaleGlobalBase, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'npcScaleGlobalBase' is not null or undefined
            if (npcScaleGlobalBase === null || npcScaleGlobalBase === undefined) {
                throw new RequiredError('npcScaleGlobalBase','Required parameter npcScaleGlobalBase was null or undefined when calling createNpcScaleGlobalBase.');
            }
            const localVarPath = `/npc_scale_global_base`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof npcScaleGlobalBase !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(npcScaleGlobalBase !== undefined ? npcScaleGlobalBase : {})
                : (npcScaleGlobalBase || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes NpcScaleGlobalBase
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNpcScaleGlobalBase: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteNpcScaleGlobalBase.');
            }
            const localVarPath = `/npc_scale_global_base/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets NpcScaleGlobalBase
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNpcScaleGlobalBase: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getNpcScaleGlobalBase.');
            }
            const localVarPath = `/npc_scale_global_base/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists NpcScaleGlobalBases
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNpcScaleGlobalBases: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/npc_scale_global_bases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates NpcScaleGlobalBase
         * @param {number} id Id
         * @param {ModelsNpcScaleGlobalBase} npcScaleGlobalBase NpcScaleGlobalBase
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNpcScaleGlobalBase: async (id: number, npcScaleGlobalBase: ModelsNpcScaleGlobalBase, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateNpcScaleGlobalBase.');
            }
            // verify required parameter 'npcScaleGlobalBase' is not null or undefined
            if (npcScaleGlobalBase === null || npcScaleGlobalBase === undefined) {
                throw new RequiredError('npcScaleGlobalBase','Required parameter npcScaleGlobalBase was null or undefined when calling updateNpcScaleGlobalBase.');
            }
            const localVarPath = `/npc_scale_global_base/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof npcScaleGlobalBase !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(npcScaleGlobalBase !== undefined ? npcScaleGlobalBase : {})
                : (npcScaleGlobalBase || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NpcScaleGlobalBaseApi - functional programming interface
 * @export
 */
export const NpcScaleGlobalBaseApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates NpcScaleGlobalBase
         * @param {ModelsNpcScaleGlobalBase} npcScaleGlobalBase NpcScaleGlobalBase
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNpcScaleGlobalBase(npcScaleGlobalBase: ModelsNpcScaleGlobalBase, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsNpcScaleGlobalBase>>> {
            const localVarAxiosArgs = await NpcScaleGlobalBaseApiAxiosParamCreator(configuration).createNpcScaleGlobalBase(npcScaleGlobalBase, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes NpcScaleGlobalBase
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNpcScaleGlobalBase(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await NpcScaleGlobalBaseApiAxiosParamCreator(configuration).deleteNpcScaleGlobalBase(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets NpcScaleGlobalBase
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNpcScaleGlobalBase(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsNpcScaleGlobalBase>>> {
            const localVarAxiosArgs = await NpcScaleGlobalBaseApiAxiosParamCreator(configuration).getNpcScaleGlobalBase(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists NpcScaleGlobalBases
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNpcScaleGlobalBases(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsNpcScaleGlobalBase>>> {
            const localVarAxiosArgs = await NpcScaleGlobalBaseApiAxiosParamCreator(configuration).listNpcScaleGlobalBases(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates NpcScaleGlobalBase
         * @param {number} id Id
         * @param {ModelsNpcScaleGlobalBase} npcScaleGlobalBase NpcScaleGlobalBase
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNpcScaleGlobalBase(id: number, npcScaleGlobalBase: ModelsNpcScaleGlobalBase, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsNpcScaleGlobalBase>>> {
            const localVarAxiosArgs = await NpcScaleGlobalBaseApiAxiosParamCreator(configuration).updateNpcScaleGlobalBase(id, npcScaleGlobalBase, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * NpcScaleGlobalBaseApi - factory interface
 * @export
 */
export const NpcScaleGlobalBaseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates NpcScaleGlobalBase
         * @param {ModelsNpcScaleGlobalBase} npcScaleGlobalBase NpcScaleGlobalBase
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNpcScaleGlobalBase(npcScaleGlobalBase: ModelsNpcScaleGlobalBase, options?: any): AxiosPromise<Array<ModelsNpcScaleGlobalBase>> {
            return NpcScaleGlobalBaseApiFp(configuration).createNpcScaleGlobalBase(npcScaleGlobalBase, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes NpcScaleGlobalBase
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNpcScaleGlobalBase(id: number, options?: any): AxiosPromise<string> {
            return NpcScaleGlobalBaseApiFp(configuration).deleteNpcScaleGlobalBase(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets NpcScaleGlobalBase
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNpcScaleGlobalBase(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsNpcScaleGlobalBase>> {
            return NpcScaleGlobalBaseApiFp(configuration).getNpcScaleGlobalBase(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists NpcScaleGlobalBases
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNpcScaleGlobalBases(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsNpcScaleGlobalBase>> {
            return NpcScaleGlobalBaseApiFp(configuration).listNpcScaleGlobalBases(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates NpcScaleGlobalBase
         * @param {number} id Id
         * @param {ModelsNpcScaleGlobalBase} npcScaleGlobalBase NpcScaleGlobalBase
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNpcScaleGlobalBase(id: number, npcScaleGlobalBase: ModelsNpcScaleGlobalBase, options?: any): AxiosPromise<Array<ModelsNpcScaleGlobalBase>> {
            return NpcScaleGlobalBaseApiFp(configuration).updateNpcScaleGlobalBase(id, npcScaleGlobalBase, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createNpcScaleGlobalBase operation in NpcScaleGlobalBaseApi.
 * @export
 * @interface NpcScaleGlobalBaseApiCreateNpcScaleGlobalBaseRequest
 */
export interface NpcScaleGlobalBaseApiCreateNpcScaleGlobalBaseRequest {
    /**
     * NpcScaleGlobalBase
     * @type {ModelsNpcScaleGlobalBase}
     * @memberof NpcScaleGlobalBaseApiCreateNpcScaleGlobalBase
     */
    readonly npcScaleGlobalBase: ModelsNpcScaleGlobalBase
}

/**
 * Request parameters for deleteNpcScaleGlobalBase operation in NpcScaleGlobalBaseApi.
 * @export
 * @interface NpcScaleGlobalBaseApiDeleteNpcScaleGlobalBaseRequest
 */
export interface NpcScaleGlobalBaseApiDeleteNpcScaleGlobalBaseRequest {
    /**
     * Id
     * @type {number}
     * @memberof NpcScaleGlobalBaseApiDeleteNpcScaleGlobalBase
     */
    readonly id: number
}

/**
 * Request parameters for getNpcScaleGlobalBase operation in NpcScaleGlobalBaseApi.
 * @export
 * @interface NpcScaleGlobalBaseApiGetNpcScaleGlobalBaseRequest
 */
export interface NpcScaleGlobalBaseApiGetNpcScaleGlobalBaseRequest {
    /**
     * Id
     * @type {number}
     * @memberof NpcScaleGlobalBaseApiGetNpcScaleGlobalBase
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof NpcScaleGlobalBaseApiGetNpcScaleGlobalBase
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof NpcScaleGlobalBaseApiGetNpcScaleGlobalBase
     */
    readonly select?: string
}

/**
 * Request parameters for listNpcScaleGlobalBases operation in NpcScaleGlobalBaseApi.
 * @export
 * @interface NpcScaleGlobalBaseApiListNpcScaleGlobalBasesRequest
 */
export interface NpcScaleGlobalBaseApiListNpcScaleGlobalBasesRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof NpcScaleGlobalBaseApiListNpcScaleGlobalBases
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof NpcScaleGlobalBaseApiListNpcScaleGlobalBases
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof NpcScaleGlobalBaseApiListNpcScaleGlobalBases
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof NpcScaleGlobalBaseApiListNpcScaleGlobalBases
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof NpcScaleGlobalBaseApiListNpcScaleGlobalBases
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof NpcScaleGlobalBaseApiListNpcScaleGlobalBases
     */
    readonly select?: string
}

/**
 * Request parameters for updateNpcScaleGlobalBase operation in NpcScaleGlobalBaseApi.
 * @export
 * @interface NpcScaleGlobalBaseApiUpdateNpcScaleGlobalBaseRequest
 */
export interface NpcScaleGlobalBaseApiUpdateNpcScaleGlobalBaseRequest {
    /**
     * Id
     * @type {number}
     * @memberof NpcScaleGlobalBaseApiUpdateNpcScaleGlobalBase
     */
    readonly id: number

    /**
     * NpcScaleGlobalBase
     * @type {ModelsNpcScaleGlobalBase}
     * @memberof NpcScaleGlobalBaseApiUpdateNpcScaleGlobalBase
     */
    readonly npcScaleGlobalBase: ModelsNpcScaleGlobalBase
}

/**
 * NpcScaleGlobalBaseApi - object-oriented interface
 * @export
 * @class NpcScaleGlobalBaseApi
 * @extends {BaseAPI}
 */
export class NpcScaleGlobalBaseApi extends BaseAPI {
    /**
     * 
     * @summary Creates NpcScaleGlobalBase
     * @param {NpcScaleGlobalBaseApiCreateNpcScaleGlobalBaseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcScaleGlobalBaseApi
     */
    public createNpcScaleGlobalBase(requestParameters: NpcScaleGlobalBaseApiCreateNpcScaleGlobalBaseRequest, options?: any) {
        return NpcScaleGlobalBaseApiFp(this.configuration).createNpcScaleGlobalBase(requestParameters.npcScaleGlobalBase, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes NpcScaleGlobalBase
     * @param {NpcScaleGlobalBaseApiDeleteNpcScaleGlobalBaseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcScaleGlobalBaseApi
     */
    public deleteNpcScaleGlobalBase(requestParameters: NpcScaleGlobalBaseApiDeleteNpcScaleGlobalBaseRequest, options?: any) {
        return NpcScaleGlobalBaseApiFp(this.configuration).deleteNpcScaleGlobalBase(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets NpcScaleGlobalBase
     * @param {NpcScaleGlobalBaseApiGetNpcScaleGlobalBaseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcScaleGlobalBaseApi
     */
    public getNpcScaleGlobalBase(requestParameters: NpcScaleGlobalBaseApiGetNpcScaleGlobalBaseRequest, options?: any) {
        return NpcScaleGlobalBaseApiFp(this.configuration).getNpcScaleGlobalBase(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists NpcScaleGlobalBases
     * @param {NpcScaleGlobalBaseApiListNpcScaleGlobalBasesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcScaleGlobalBaseApi
     */
    public listNpcScaleGlobalBases(requestParameters: NpcScaleGlobalBaseApiListNpcScaleGlobalBasesRequest = {}, options?: any) {
        return NpcScaleGlobalBaseApiFp(this.configuration).listNpcScaleGlobalBases(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates NpcScaleGlobalBase
     * @param {NpcScaleGlobalBaseApiUpdateNpcScaleGlobalBaseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcScaleGlobalBaseApi
     */
    public updateNpcScaleGlobalBase(requestParameters: NpcScaleGlobalBaseApiUpdateNpcScaleGlobalBaseRequest, options?: any) {
        return NpcScaleGlobalBaseApiFp(this.configuration).updateNpcScaleGlobalBase(requestParameters.id, requestParameters.npcScaleGlobalBase, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NpcSpellApi - axios parameter creator
 * @export
 */
export const NpcSpellApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates NpcSpell
         * @param {ModelsNpcSpell} npcSpell NpcSpell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNpcSpell: async (npcSpell: ModelsNpcSpell, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'npcSpell' is not null or undefined
            if (npcSpell === null || npcSpell === undefined) {
                throw new RequiredError('npcSpell','Required parameter npcSpell was null or undefined when calling createNpcSpell.');
            }
            const localVarPath = `/npc_spell`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof npcSpell !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(npcSpell !== undefined ? npcSpell : {})
                : (npcSpell || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes NpcSpell
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNpcSpell: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteNpcSpell.');
            }
            const localVarPath = `/npc_spell/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets NpcSpell
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;NpcSpellsEntries
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNpcSpell: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getNpcSpell.');
            }
            const localVarPath = `/npc_spell/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists NpcSpells
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;NpcSpellsEntries
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNpcSpells: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/npc_spells`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates NpcSpell
         * @param {number} id Id
         * @param {ModelsNpcSpell} npcSpell NpcSpell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNpcSpell: async (id: number, npcSpell: ModelsNpcSpell, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateNpcSpell.');
            }
            // verify required parameter 'npcSpell' is not null or undefined
            if (npcSpell === null || npcSpell === undefined) {
                throw new RequiredError('npcSpell','Required parameter npcSpell was null or undefined when calling updateNpcSpell.');
            }
            const localVarPath = `/npc_spell/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof npcSpell !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(npcSpell !== undefined ? npcSpell : {})
                : (npcSpell || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NpcSpellApi - functional programming interface
 * @export
 */
export const NpcSpellApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates NpcSpell
         * @param {ModelsNpcSpell} npcSpell NpcSpell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNpcSpell(npcSpell: ModelsNpcSpell, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsNpcSpell>>> {
            const localVarAxiosArgs = await NpcSpellApiAxiosParamCreator(configuration).createNpcSpell(npcSpell, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes NpcSpell
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNpcSpell(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await NpcSpellApiAxiosParamCreator(configuration).deleteNpcSpell(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets NpcSpell
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;NpcSpellsEntries
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNpcSpell(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsNpcSpell>>> {
            const localVarAxiosArgs = await NpcSpellApiAxiosParamCreator(configuration).getNpcSpell(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists NpcSpells
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;NpcSpellsEntries
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNpcSpells(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsNpcSpell>>> {
            const localVarAxiosArgs = await NpcSpellApiAxiosParamCreator(configuration).listNpcSpells(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates NpcSpell
         * @param {number} id Id
         * @param {ModelsNpcSpell} npcSpell NpcSpell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNpcSpell(id: number, npcSpell: ModelsNpcSpell, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsNpcSpell>>> {
            const localVarAxiosArgs = await NpcSpellApiAxiosParamCreator(configuration).updateNpcSpell(id, npcSpell, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * NpcSpellApi - factory interface
 * @export
 */
export const NpcSpellApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates NpcSpell
         * @param {ModelsNpcSpell} npcSpell NpcSpell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNpcSpell(npcSpell: ModelsNpcSpell, options?: any): AxiosPromise<Array<ModelsNpcSpell>> {
            return NpcSpellApiFp(configuration).createNpcSpell(npcSpell, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes NpcSpell
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNpcSpell(id: number, options?: any): AxiosPromise<string> {
            return NpcSpellApiFp(configuration).deleteNpcSpell(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets NpcSpell
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;NpcSpellsEntries
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNpcSpell(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsNpcSpell>> {
            return NpcSpellApiFp(configuration).getNpcSpell(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists NpcSpells
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;NpcSpellsEntries
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNpcSpells(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsNpcSpell>> {
            return NpcSpellApiFp(configuration).listNpcSpells(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates NpcSpell
         * @param {number} id Id
         * @param {ModelsNpcSpell} npcSpell NpcSpell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNpcSpell(id: number, npcSpell: ModelsNpcSpell, options?: any): AxiosPromise<Array<ModelsNpcSpell>> {
            return NpcSpellApiFp(configuration).updateNpcSpell(id, npcSpell, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createNpcSpell operation in NpcSpellApi.
 * @export
 * @interface NpcSpellApiCreateNpcSpellRequest
 */
export interface NpcSpellApiCreateNpcSpellRequest {
    /**
     * NpcSpell
     * @type {ModelsNpcSpell}
     * @memberof NpcSpellApiCreateNpcSpell
     */
    readonly npcSpell: ModelsNpcSpell
}

/**
 * Request parameters for deleteNpcSpell operation in NpcSpellApi.
 * @export
 * @interface NpcSpellApiDeleteNpcSpellRequest
 */
export interface NpcSpellApiDeleteNpcSpellRequest {
    /**
     * Id
     * @type {number}
     * @memberof NpcSpellApiDeleteNpcSpell
     */
    readonly id: number
}

/**
 * Request parameters for getNpcSpell operation in NpcSpellApi.
 * @export
 * @interface NpcSpellApiGetNpcSpellRequest
 */
export interface NpcSpellApiGetNpcSpellRequest {
    /**
     * Id
     * @type {number}
     * @memberof NpcSpellApiGetNpcSpell
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;NpcSpellsEntries
     * @type {string}
     * @memberof NpcSpellApiGetNpcSpell
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof NpcSpellApiGetNpcSpell
     */
    readonly select?: string
}

/**
 * Request parameters for listNpcSpells operation in NpcSpellApi.
 * @export
 * @interface NpcSpellApiListNpcSpellsRequest
 */
export interface NpcSpellApiListNpcSpellsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;NpcSpellsEntries
     * @type {string}
     * @memberof NpcSpellApiListNpcSpells
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof NpcSpellApiListNpcSpells
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof NpcSpellApiListNpcSpells
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof NpcSpellApiListNpcSpells
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof NpcSpellApiListNpcSpells
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof NpcSpellApiListNpcSpells
     */
    readonly select?: string
}

/**
 * Request parameters for updateNpcSpell operation in NpcSpellApi.
 * @export
 * @interface NpcSpellApiUpdateNpcSpellRequest
 */
export interface NpcSpellApiUpdateNpcSpellRequest {
    /**
     * Id
     * @type {number}
     * @memberof NpcSpellApiUpdateNpcSpell
     */
    readonly id: number

    /**
     * NpcSpell
     * @type {ModelsNpcSpell}
     * @memberof NpcSpellApiUpdateNpcSpell
     */
    readonly npcSpell: ModelsNpcSpell
}

/**
 * NpcSpellApi - object-oriented interface
 * @export
 * @class NpcSpellApi
 * @extends {BaseAPI}
 */
export class NpcSpellApi extends BaseAPI {
    /**
     * 
     * @summary Creates NpcSpell
     * @param {NpcSpellApiCreateNpcSpellRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcSpellApi
     */
    public createNpcSpell(requestParameters: NpcSpellApiCreateNpcSpellRequest, options?: any) {
        return NpcSpellApiFp(this.configuration).createNpcSpell(requestParameters.npcSpell, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes NpcSpell
     * @param {NpcSpellApiDeleteNpcSpellRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcSpellApi
     */
    public deleteNpcSpell(requestParameters: NpcSpellApiDeleteNpcSpellRequest, options?: any) {
        return NpcSpellApiFp(this.configuration).deleteNpcSpell(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets NpcSpell
     * @param {NpcSpellApiGetNpcSpellRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcSpellApi
     */
    public getNpcSpell(requestParameters: NpcSpellApiGetNpcSpellRequest, options?: any) {
        return NpcSpellApiFp(this.configuration).getNpcSpell(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists NpcSpells
     * @param {NpcSpellApiListNpcSpellsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcSpellApi
     */
    public listNpcSpells(requestParameters: NpcSpellApiListNpcSpellsRequest = {}, options?: any) {
        return NpcSpellApiFp(this.configuration).listNpcSpells(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates NpcSpell
     * @param {NpcSpellApiUpdateNpcSpellRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcSpellApi
     */
    public updateNpcSpell(requestParameters: NpcSpellApiUpdateNpcSpellRequest, options?: any) {
        return NpcSpellApiFp(this.configuration).updateNpcSpell(requestParameters.id, requestParameters.npcSpell, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NpcSpellsEffectApi - axios parameter creator
 * @export
 */
export const NpcSpellsEffectApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates NpcSpellsEffect
         * @param {ModelsNpcSpellsEffect} npcSpellsEffect NpcSpellsEffect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNpcSpellsEffect: async (npcSpellsEffect: ModelsNpcSpellsEffect, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'npcSpellsEffect' is not null or undefined
            if (npcSpellsEffect === null || npcSpellsEffect === undefined) {
                throw new RequiredError('npcSpellsEffect','Required parameter npcSpellsEffect was null or undefined when calling createNpcSpellsEffect.');
            }
            const localVarPath = `/npc_spells_effect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof npcSpellsEffect !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(npcSpellsEffect !== undefined ? npcSpellsEffect : {})
                : (npcSpellsEffect || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes NpcSpellsEffect
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNpcSpellsEffect: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteNpcSpellsEffect.');
            }
            const localVarPath = `/npc_spells_effect/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets NpcSpellsEffect
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;NpcSpellsEffectsEntries
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNpcSpellsEffect: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getNpcSpellsEffect.');
            }
            const localVarPath = `/npc_spells_effect/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists NpcSpellsEffects
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;NpcSpellsEffectsEntries
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNpcSpellsEffects: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/npc_spells_effects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates NpcSpellsEffect
         * @param {number} id Id
         * @param {ModelsNpcSpellsEffect} npcSpellsEffect NpcSpellsEffect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNpcSpellsEffect: async (id: number, npcSpellsEffect: ModelsNpcSpellsEffect, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateNpcSpellsEffect.');
            }
            // verify required parameter 'npcSpellsEffect' is not null or undefined
            if (npcSpellsEffect === null || npcSpellsEffect === undefined) {
                throw new RequiredError('npcSpellsEffect','Required parameter npcSpellsEffect was null or undefined when calling updateNpcSpellsEffect.');
            }
            const localVarPath = `/npc_spells_effect/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof npcSpellsEffect !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(npcSpellsEffect !== undefined ? npcSpellsEffect : {})
                : (npcSpellsEffect || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NpcSpellsEffectApi - functional programming interface
 * @export
 */
export const NpcSpellsEffectApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates NpcSpellsEffect
         * @param {ModelsNpcSpellsEffect} npcSpellsEffect NpcSpellsEffect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNpcSpellsEffect(npcSpellsEffect: ModelsNpcSpellsEffect, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsNpcSpellsEffect>>> {
            const localVarAxiosArgs = await NpcSpellsEffectApiAxiosParamCreator(configuration).createNpcSpellsEffect(npcSpellsEffect, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes NpcSpellsEffect
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNpcSpellsEffect(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await NpcSpellsEffectApiAxiosParamCreator(configuration).deleteNpcSpellsEffect(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets NpcSpellsEffect
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;NpcSpellsEffectsEntries
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNpcSpellsEffect(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsNpcSpellsEffect>>> {
            const localVarAxiosArgs = await NpcSpellsEffectApiAxiosParamCreator(configuration).getNpcSpellsEffect(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists NpcSpellsEffects
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;NpcSpellsEffectsEntries
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNpcSpellsEffects(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsNpcSpellsEffect>>> {
            const localVarAxiosArgs = await NpcSpellsEffectApiAxiosParamCreator(configuration).listNpcSpellsEffects(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates NpcSpellsEffect
         * @param {number} id Id
         * @param {ModelsNpcSpellsEffect} npcSpellsEffect NpcSpellsEffect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNpcSpellsEffect(id: number, npcSpellsEffect: ModelsNpcSpellsEffect, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsNpcSpellsEffect>>> {
            const localVarAxiosArgs = await NpcSpellsEffectApiAxiosParamCreator(configuration).updateNpcSpellsEffect(id, npcSpellsEffect, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * NpcSpellsEffectApi - factory interface
 * @export
 */
export const NpcSpellsEffectApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates NpcSpellsEffect
         * @param {ModelsNpcSpellsEffect} npcSpellsEffect NpcSpellsEffect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNpcSpellsEffect(npcSpellsEffect: ModelsNpcSpellsEffect, options?: any): AxiosPromise<Array<ModelsNpcSpellsEffect>> {
            return NpcSpellsEffectApiFp(configuration).createNpcSpellsEffect(npcSpellsEffect, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes NpcSpellsEffect
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNpcSpellsEffect(id: number, options?: any): AxiosPromise<string> {
            return NpcSpellsEffectApiFp(configuration).deleteNpcSpellsEffect(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets NpcSpellsEffect
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;NpcSpellsEffectsEntries
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNpcSpellsEffect(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsNpcSpellsEffect>> {
            return NpcSpellsEffectApiFp(configuration).getNpcSpellsEffect(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists NpcSpellsEffects
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;NpcSpellsEffectsEntries
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNpcSpellsEffects(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsNpcSpellsEffect>> {
            return NpcSpellsEffectApiFp(configuration).listNpcSpellsEffects(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates NpcSpellsEffect
         * @param {number} id Id
         * @param {ModelsNpcSpellsEffect} npcSpellsEffect NpcSpellsEffect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNpcSpellsEffect(id: number, npcSpellsEffect: ModelsNpcSpellsEffect, options?: any): AxiosPromise<Array<ModelsNpcSpellsEffect>> {
            return NpcSpellsEffectApiFp(configuration).updateNpcSpellsEffect(id, npcSpellsEffect, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createNpcSpellsEffect operation in NpcSpellsEffectApi.
 * @export
 * @interface NpcSpellsEffectApiCreateNpcSpellsEffectRequest
 */
export interface NpcSpellsEffectApiCreateNpcSpellsEffectRequest {
    /**
     * NpcSpellsEffect
     * @type {ModelsNpcSpellsEffect}
     * @memberof NpcSpellsEffectApiCreateNpcSpellsEffect
     */
    readonly npcSpellsEffect: ModelsNpcSpellsEffect
}

/**
 * Request parameters for deleteNpcSpellsEffect operation in NpcSpellsEffectApi.
 * @export
 * @interface NpcSpellsEffectApiDeleteNpcSpellsEffectRequest
 */
export interface NpcSpellsEffectApiDeleteNpcSpellsEffectRequest {
    /**
     * Id
     * @type {number}
     * @memberof NpcSpellsEffectApiDeleteNpcSpellsEffect
     */
    readonly id: number
}

/**
 * Request parameters for getNpcSpellsEffect operation in NpcSpellsEffectApi.
 * @export
 * @interface NpcSpellsEffectApiGetNpcSpellsEffectRequest
 */
export interface NpcSpellsEffectApiGetNpcSpellsEffectRequest {
    /**
     * Id
     * @type {number}
     * @memberof NpcSpellsEffectApiGetNpcSpellsEffect
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;NpcSpellsEffectsEntries
     * @type {string}
     * @memberof NpcSpellsEffectApiGetNpcSpellsEffect
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof NpcSpellsEffectApiGetNpcSpellsEffect
     */
    readonly select?: string
}

/**
 * Request parameters for listNpcSpellsEffects operation in NpcSpellsEffectApi.
 * @export
 * @interface NpcSpellsEffectApiListNpcSpellsEffectsRequest
 */
export interface NpcSpellsEffectApiListNpcSpellsEffectsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;NpcSpellsEffectsEntries
     * @type {string}
     * @memberof NpcSpellsEffectApiListNpcSpellsEffects
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof NpcSpellsEffectApiListNpcSpellsEffects
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof NpcSpellsEffectApiListNpcSpellsEffects
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof NpcSpellsEffectApiListNpcSpellsEffects
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof NpcSpellsEffectApiListNpcSpellsEffects
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof NpcSpellsEffectApiListNpcSpellsEffects
     */
    readonly select?: string
}

/**
 * Request parameters for updateNpcSpellsEffect operation in NpcSpellsEffectApi.
 * @export
 * @interface NpcSpellsEffectApiUpdateNpcSpellsEffectRequest
 */
export interface NpcSpellsEffectApiUpdateNpcSpellsEffectRequest {
    /**
     * Id
     * @type {number}
     * @memberof NpcSpellsEffectApiUpdateNpcSpellsEffect
     */
    readonly id: number

    /**
     * NpcSpellsEffect
     * @type {ModelsNpcSpellsEffect}
     * @memberof NpcSpellsEffectApiUpdateNpcSpellsEffect
     */
    readonly npcSpellsEffect: ModelsNpcSpellsEffect
}

/**
 * NpcSpellsEffectApi - object-oriented interface
 * @export
 * @class NpcSpellsEffectApi
 * @extends {BaseAPI}
 */
export class NpcSpellsEffectApi extends BaseAPI {
    /**
     * 
     * @summary Creates NpcSpellsEffect
     * @param {NpcSpellsEffectApiCreateNpcSpellsEffectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcSpellsEffectApi
     */
    public createNpcSpellsEffect(requestParameters: NpcSpellsEffectApiCreateNpcSpellsEffectRequest, options?: any) {
        return NpcSpellsEffectApiFp(this.configuration).createNpcSpellsEffect(requestParameters.npcSpellsEffect, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes NpcSpellsEffect
     * @param {NpcSpellsEffectApiDeleteNpcSpellsEffectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcSpellsEffectApi
     */
    public deleteNpcSpellsEffect(requestParameters: NpcSpellsEffectApiDeleteNpcSpellsEffectRequest, options?: any) {
        return NpcSpellsEffectApiFp(this.configuration).deleteNpcSpellsEffect(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets NpcSpellsEffect
     * @param {NpcSpellsEffectApiGetNpcSpellsEffectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcSpellsEffectApi
     */
    public getNpcSpellsEffect(requestParameters: NpcSpellsEffectApiGetNpcSpellsEffectRequest, options?: any) {
        return NpcSpellsEffectApiFp(this.configuration).getNpcSpellsEffect(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists NpcSpellsEffects
     * @param {NpcSpellsEffectApiListNpcSpellsEffectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcSpellsEffectApi
     */
    public listNpcSpellsEffects(requestParameters: NpcSpellsEffectApiListNpcSpellsEffectsRequest = {}, options?: any) {
        return NpcSpellsEffectApiFp(this.configuration).listNpcSpellsEffects(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates NpcSpellsEffect
     * @param {NpcSpellsEffectApiUpdateNpcSpellsEffectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcSpellsEffectApi
     */
    public updateNpcSpellsEffect(requestParameters: NpcSpellsEffectApiUpdateNpcSpellsEffectRequest, options?: any) {
        return NpcSpellsEffectApiFp(this.configuration).updateNpcSpellsEffect(requestParameters.id, requestParameters.npcSpellsEffect, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NpcSpellsEffectsEntryApi - axios parameter creator
 * @export
 */
export const NpcSpellsEffectsEntryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates NpcSpellsEffectsEntry
         * @param {ModelsNpcSpellsEffectsEntry} npcSpellsEffectsEntry NpcSpellsEffectsEntry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNpcSpellsEffectsEntry: async (npcSpellsEffectsEntry: ModelsNpcSpellsEffectsEntry, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'npcSpellsEffectsEntry' is not null or undefined
            if (npcSpellsEffectsEntry === null || npcSpellsEffectsEntry === undefined) {
                throw new RequiredError('npcSpellsEffectsEntry','Required parameter npcSpellsEffectsEntry was null or undefined when calling createNpcSpellsEffectsEntry.');
            }
            const localVarPath = `/npc_spells_effects_entry`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof npcSpellsEffectsEntry !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(npcSpellsEffectsEntry !== undefined ? npcSpellsEffectsEntry : {})
                : (npcSpellsEffectsEntry || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes NpcSpellsEffectsEntry
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNpcSpellsEffectsEntry: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteNpcSpellsEffectsEntry.');
            }
            const localVarPath = `/npc_spells_effects_entry/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets NpcSpellsEffectsEntry
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNpcSpellsEffectsEntry: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getNpcSpellsEffectsEntry.');
            }
            const localVarPath = `/npc_spells_effects_entry/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists NpcSpellsEffectsEntries
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNpcSpellsEffectsEntries: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/npc_spells_effects_entries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates NpcSpellsEffectsEntry
         * @param {number} id Id
         * @param {ModelsNpcSpellsEffectsEntry} npcSpellsEffectsEntry NpcSpellsEffectsEntry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNpcSpellsEffectsEntry: async (id: number, npcSpellsEffectsEntry: ModelsNpcSpellsEffectsEntry, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateNpcSpellsEffectsEntry.');
            }
            // verify required parameter 'npcSpellsEffectsEntry' is not null or undefined
            if (npcSpellsEffectsEntry === null || npcSpellsEffectsEntry === undefined) {
                throw new RequiredError('npcSpellsEffectsEntry','Required parameter npcSpellsEffectsEntry was null or undefined when calling updateNpcSpellsEffectsEntry.');
            }
            const localVarPath = `/npc_spells_effects_entry/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof npcSpellsEffectsEntry !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(npcSpellsEffectsEntry !== undefined ? npcSpellsEffectsEntry : {})
                : (npcSpellsEffectsEntry || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NpcSpellsEffectsEntryApi - functional programming interface
 * @export
 */
export const NpcSpellsEffectsEntryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates NpcSpellsEffectsEntry
         * @param {ModelsNpcSpellsEffectsEntry} npcSpellsEffectsEntry NpcSpellsEffectsEntry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNpcSpellsEffectsEntry(npcSpellsEffectsEntry: ModelsNpcSpellsEffectsEntry, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsNpcSpellsEffectsEntry>>> {
            const localVarAxiosArgs = await NpcSpellsEffectsEntryApiAxiosParamCreator(configuration).createNpcSpellsEffectsEntry(npcSpellsEffectsEntry, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes NpcSpellsEffectsEntry
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNpcSpellsEffectsEntry(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await NpcSpellsEffectsEntryApiAxiosParamCreator(configuration).deleteNpcSpellsEffectsEntry(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets NpcSpellsEffectsEntry
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNpcSpellsEffectsEntry(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsNpcSpellsEffectsEntry>>> {
            const localVarAxiosArgs = await NpcSpellsEffectsEntryApiAxiosParamCreator(configuration).getNpcSpellsEffectsEntry(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists NpcSpellsEffectsEntries
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNpcSpellsEffectsEntries(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsNpcSpellsEffectsEntry>>> {
            const localVarAxiosArgs = await NpcSpellsEffectsEntryApiAxiosParamCreator(configuration).listNpcSpellsEffectsEntries(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates NpcSpellsEffectsEntry
         * @param {number} id Id
         * @param {ModelsNpcSpellsEffectsEntry} npcSpellsEffectsEntry NpcSpellsEffectsEntry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNpcSpellsEffectsEntry(id: number, npcSpellsEffectsEntry: ModelsNpcSpellsEffectsEntry, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsNpcSpellsEffectsEntry>>> {
            const localVarAxiosArgs = await NpcSpellsEffectsEntryApiAxiosParamCreator(configuration).updateNpcSpellsEffectsEntry(id, npcSpellsEffectsEntry, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * NpcSpellsEffectsEntryApi - factory interface
 * @export
 */
export const NpcSpellsEffectsEntryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates NpcSpellsEffectsEntry
         * @param {ModelsNpcSpellsEffectsEntry} npcSpellsEffectsEntry NpcSpellsEffectsEntry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNpcSpellsEffectsEntry(npcSpellsEffectsEntry: ModelsNpcSpellsEffectsEntry, options?: any): AxiosPromise<Array<ModelsNpcSpellsEffectsEntry>> {
            return NpcSpellsEffectsEntryApiFp(configuration).createNpcSpellsEffectsEntry(npcSpellsEffectsEntry, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes NpcSpellsEffectsEntry
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNpcSpellsEffectsEntry(id: number, options?: any): AxiosPromise<string> {
            return NpcSpellsEffectsEntryApiFp(configuration).deleteNpcSpellsEffectsEntry(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets NpcSpellsEffectsEntry
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNpcSpellsEffectsEntry(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsNpcSpellsEffectsEntry>> {
            return NpcSpellsEffectsEntryApiFp(configuration).getNpcSpellsEffectsEntry(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists NpcSpellsEffectsEntries
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNpcSpellsEffectsEntries(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsNpcSpellsEffectsEntry>> {
            return NpcSpellsEffectsEntryApiFp(configuration).listNpcSpellsEffectsEntries(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates NpcSpellsEffectsEntry
         * @param {number} id Id
         * @param {ModelsNpcSpellsEffectsEntry} npcSpellsEffectsEntry NpcSpellsEffectsEntry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNpcSpellsEffectsEntry(id: number, npcSpellsEffectsEntry: ModelsNpcSpellsEffectsEntry, options?: any): AxiosPromise<Array<ModelsNpcSpellsEffectsEntry>> {
            return NpcSpellsEffectsEntryApiFp(configuration).updateNpcSpellsEffectsEntry(id, npcSpellsEffectsEntry, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createNpcSpellsEffectsEntry operation in NpcSpellsEffectsEntryApi.
 * @export
 * @interface NpcSpellsEffectsEntryApiCreateNpcSpellsEffectsEntryRequest
 */
export interface NpcSpellsEffectsEntryApiCreateNpcSpellsEffectsEntryRequest {
    /**
     * NpcSpellsEffectsEntry
     * @type {ModelsNpcSpellsEffectsEntry}
     * @memberof NpcSpellsEffectsEntryApiCreateNpcSpellsEffectsEntry
     */
    readonly npcSpellsEffectsEntry: ModelsNpcSpellsEffectsEntry
}

/**
 * Request parameters for deleteNpcSpellsEffectsEntry operation in NpcSpellsEffectsEntryApi.
 * @export
 * @interface NpcSpellsEffectsEntryApiDeleteNpcSpellsEffectsEntryRequest
 */
export interface NpcSpellsEffectsEntryApiDeleteNpcSpellsEffectsEntryRequest {
    /**
     * Id
     * @type {number}
     * @memberof NpcSpellsEffectsEntryApiDeleteNpcSpellsEffectsEntry
     */
    readonly id: number
}

/**
 * Request parameters for getNpcSpellsEffectsEntry operation in NpcSpellsEffectsEntryApi.
 * @export
 * @interface NpcSpellsEffectsEntryApiGetNpcSpellsEffectsEntryRequest
 */
export interface NpcSpellsEffectsEntryApiGetNpcSpellsEffectsEntryRequest {
    /**
     * Id
     * @type {number}
     * @memberof NpcSpellsEffectsEntryApiGetNpcSpellsEffectsEntry
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof NpcSpellsEffectsEntryApiGetNpcSpellsEffectsEntry
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof NpcSpellsEffectsEntryApiGetNpcSpellsEffectsEntry
     */
    readonly select?: string
}

/**
 * Request parameters for listNpcSpellsEffectsEntries operation in NpcSpellsEffectsEntryApi.
 * @export
 * @interface NpcSpellsEffectsEntryApiListNpcSpellsEffectsEntriesRequest
 */
export interface NpcSpellsEffectsEntryApiListNpcSpellsEffectsEntriesRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof NpcSpellsEffectsEntryApiListNpcSpellsEffectsEntries
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof NpcSpellsEffectsEntryApiListNpcSpellsEffectsEntries
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof NpcSpellsEffectsEntryApiListNpcSpellsEffectsEntries
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof NpcSpellsEffectsEntryApiListNpcSpellsEffectsEntries
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof NpcSpellsEffectsEntryApiListNpcSpellsEffectsEntries
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof NpcSpellsEffectsEntryApiListNpcSpellsEffectsEntries
     */
    readonly select?: string
}

/**
 * Request parameters for updateNpcSpellsEffectsEntry operation in NpcSpellsEffectsEntryApi.
 * @export
 * @interface NpcSpellsEffectsEntryApiUpdateNpcSpellsEffectsEntryRequest
 */
export interface NpcSpellsEffectsEntryApiUpdateNpcSpellsEffectsEntryRequest {
    /**
     * Id
     * @type {number}
     * @memberof NpcSpellsEffectsEntryApiUpdateNpcSpellsEffectsEntry
     */
    readonly id: number

    /**
     * NpcSpellsEffectsEntry
     * @type {ModelsNpcSpellsEffectsEntry}
     * @memberof NpcSpellsEffectsEntryApiUpdateNpcSpellsEffectsEntry
     */
    readonly npcSpellsEffectsEntry: ModelsNpcSpellsEffectsEntry
}

/**
 * NpcSpellsEffectsEntryApi - object-oriented interface
 * @export
 * @class NpcSpellsEffectsEntryApi
 * @extends {BaseAPI}
 */
export class NpcSpellsEffectsEntryApi extends BaseAPI {
    /**
     * 
     * @summary Creates NpcSpellsEffectsEntry
     * @param {NpcSpellsEffectsEntryApiCreateNpcSpellsEffectsEntryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcSpellsEffectsEntryApi
     */
    public createNpcSpellsEffectsEntry(requestParameters: NpcSpellsEffectsEntryApiCreateNpcSpellsEffectsEntryRequest, options?: any) {
        return NpcSpellsEffectsEntryApiFp(this.configuration).createNpcSpellsEffectsEntry(requestParameters.npcSpellsEffectsEntry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes NpcSpellsEffectsEntry
     * @param {NpcSpellsEffectsEntryApiDeleteNpcSpellsEffectsEntryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcSpellsEffectsEntryApi
     */
    public deleteNpcSpellsEffectsEntry(requestParameters: NpcSpellsEffectsEntryApiDeleteNpcSpellsEffectsEntryRequest, options?: any) {
        return NpcSpellsEffectsEntryApiFp(this.configuration).deleteNpcSpellsEffectsEntry(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets NpcSpellsEffectsEntry
     * @param {NpcSpellsEffectsEntryApiGetNpcSpellsEffectsEntryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcSpellsEffectsEntryApi
     */
    public getNpcSpellsEffectsEntry(requestParameters: NpcSpellsEffectsEntryApiGetNpcSpellsEffectsEntryRequest, options?: any) {
        return NpcSpellsEffectsEntryApiFp(this.configuration).getNpcSpellsEffectsEntry(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists NpcSpellsEffectsEntries
     * @param {NpcSpellsEffectsEntryApiListNpcSpellsEffectsEntriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcSpellsEffectsEntryApi
     */
    public listNpcSpellsEffectsEntries(requestParameters: NpcSpellsEffectsEntryApiListNpcSpellsEffectsEntriesRequest = {}, options?: any) {
        return NpcSpellsEffectsEntryApiFp(this.configuration).listNpcSpellsEffectsEntries(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates NpcSpellsEffectsEntry
     * @param {NpcSpellsEffectsEntryApiUpdateNpcSpellsEffectsEntryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcSpellsEffectsEntryApi
     */
    public updateNpcSpellsEffectsEntry(requestParameters: NpcSpellsEffectsEntryApiUpdateNpcSpellsEffectsEntryRequest, options?: any) {
        return NpcSpellsEffectsEntryApiFp(this.configuration).updateNpcSpellsEffectsEntry(requestParameters.id, requestParameters.npcSpellsEffectsEntry, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NpcSpellsEntryApi - axios parameter creator
 * @export
 */
export const NpcSpellsEntryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates NpcSpellsEntry
         * @param {ModelsNpcSpellsEntry} npcSpellsEntry NpcSpellsEntry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNpcSpellsEntry: async (npcSpellsEntry: ModelsNpcSpellsEntry, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'npcSpellsEntry' is not null or undefined
            if (npcSpellsEntry === null || npcSpellsEntry === undefined) {
                throw new RequiredError('npcSpellsEntry','Required parameter npcSpellsEntry was null or undefined when calling createNpcSpellsEntry.');
            }
            const localVarPath = `/npc_spells_entry`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof npcSpellsEntry !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(npcSpellsEntry !== undefined ? npcSpellsEntry : {})
                : (npcSpellsEntry || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes NpcSpellsEntry
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNpcSpellsEntry: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteNpcSpellsEntry.');
            }
            const localVarPath = `/npc_spells_entry/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets NpcSpellsEntry
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNpcSpellsEntry: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getNpcSpellsEntry.');
            }
            const localVarPath = `/npc_spells_entry/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists NpcSpellsEntries
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNpcSpellsEntries: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/npc_spells_entries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates NpcSpellsEntry
         * @param {number} id Id
         * @param {ModelsNpcSpellsEntry} npcSpellsEntry NpcSpellsEntry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNpcSpellsEntry: async (id: number, npcSpellsEntry: ModelsNpcSpellsEntry, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateNpcSpellsEntry.');
            }
            // verify required parameter 'npcSpellsEntry' is not null or undefined
            if (npcSpellsEntry === null || npcSpellsEntry === undefined) {
                throw new RequiredError('npcSpellsEntry','Required parameter npcSpellsEntry was null or undefined when calling updateNpcSpellsEntry.');
            }
            const localVarPath = `/npc_spells_entry/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof npcSpellsEntry !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(npcSpellsEntry !== undefined ? npcSpellsEntry : {})
                : (npcSpellsEntry || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NpcSpellsEntryApi - functional programming interface
 * @export
 */
export const NpcSpellsEntryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates NpcSpellsEntry
         * @param {ModelsNpcSpellsEntry} npcSpellsEntry NpcSpellsEntry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNpcSpellsEntry(npcSpellsEntry: ModelsNpcSpellsEntry, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsNpcSpellsEntry>>> {
            const localVarAxiosArgs = await NpcSpellsEntryApiAxiosParamCreator(configuration).createNpcSpellsEntry(npcSpellsEntry, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes NpcSpellsEntry
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNpcSpellsEntry(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await NpcSpellsEntryApiAxiosParamCreator(configuration).deleteNpcSpellsEntry(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets NpcSpellsEntry
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNpcSpellsEntry(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsNpcSpellsEntry>>> {
            const localVarAxiosArgs = await NpcSpellsEntryApiAxiosParamCreator(configuration).getNpcSpellsEntry(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists NpcSpellsEntries
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNpcSpellsEntries(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsNpcSpellsEntry>>> {
            const localVarAxiosArgs = await NpcSpellsEntryApiAxiosParamCreator(configuration).listNpcSpellsEntries(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates NpcSpellsEntry
         * @param {number} id Id
         * @param {ModelsNpcSpellsEntry} npcSpellsEntry NpcSpellsEntry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNpcSpellsEntry(id: number, npcSpellsEntry: ModelsNpcSpellsEntry, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsNpcSpellsEntry>>> {
            const localVarAxiosArgs = await NpcSpellsEntryApiAxiosParamCreator(configuration).updateNpcSpellsEntry(id, npcSpellsEntry, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * NpcSpellsEntryApi - factory interface
 * @export
 */
export const NpcSpellsEntryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates NpcSpellsEntry
         * @param {ModelsNpcSpellsEntry} npcSpellsEntry NpcSpellsEntry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNpcSpellsEntry(npcSpellsEntry: ModelsNpcSpellsEntry, options?: any): AxiosPromise<Array<ModelsNpcSpellsEntry>> {
            return NpcSpellsEntryApiFp(configuration).createNpcSpellsEntry(npcSpellsEntry, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes NpcSpellsEntry
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNpcSpellsEntry(id: number, options?: any): AxiosPromise<string> {
            return NpcSpellsEntryApiFp(configuration).deleteNpcSpellsEntry(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets NpcSpellsEntry
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNpcSpellsEntry(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsNpcSpellsEntry>> {
            return NpcSpellsEntryApiFp(configuration).getNpcSpellsEntry(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists NpcSpellsEntries
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNpcSpellsEntries(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsNpcSpellsEntry>> {
            return NpcSpellsEntryApiFp(configuration).listNpcSpellsEntries(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates NpcSpellsEntry
         * @param {number} id Id
         * @param {ModelsNpcSpellsEntry} npcSpellsEntry NpcSpellsEntry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNpcSpellsEntry(id: number, npcSpellsEntry: ModelsNpcSpellsEntry, options?: any): AxiosPromise<Array<ModelsNpcSpellsEntry>> {
            return NpcSpellsEntryApiFp(configuration).updateNpcSpellsEntry(id, npcSpellsEntry, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createNpcSpellsEntry operation in NpcSpellsEntryApi.
 * @export
 * @interface NpcSpellsEntryApiCreateNpcSpellsEntryRequest
 */
export interface NpcSpellsEntryApiCreateNpcSpellsEntryRequest {
    /**
     * NpcSpellsEntry
     * @type {ModelsNpcSpellsEntry}
     * @memberof NpcSpellsEntryApiCreateNpcSpellsEntry
     */
    readonly npcSpellsEntry: ModelsNpcSpellsEntry
}

/**
 * Request parameters for deleteNpcSpellsEntry operation in NpcSpellsEntryApi.
 * @export
 * @interface NpcSpellsEntryApiDeleteNpcSpellsEntryRequest
 */
export interface NpcSpellsEntryApiDeleteNpcSpellsEntryRequest {
    /**
     * Id
     * @type {number}
     * @memberof NpcSpellsEntryApiDeleteNpcSpellsEntry
     */
    readonly id: number
}

/**
 * Request parameters for getNpcSpellsEntry operation in NpcSpellsEntryApi.
 * @export
 * @interface NpcSpellsEntryApiGetNpcSpellsEntryRequest
 */
export interface NpcSpellsEntryApiGetNpcSpellsEntryRequest {
    /**
     * Id
     * @type {number}
     * @memberof NpcSpellsEntryApiGetNpcSpellsEntry
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof NpcSpellsEntryApiGetNpcSpellsEntry
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof NpcSpellsEntryApiGetNpcSpellsEntry
     */
    readonly select?: string
}

/**
 * Request parameters for listNpcSpellsEntries operation in NpcSpellsEntryApi.
 * @export
 * @interface NpcSpellsEntryApiListNpcSpellsEntriesRequest
 */
export interface NpcSpellsEntryApiListNpcSpellsEntriesRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof NpcSpellsEntryApiListNpcSpellsEntries
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof NpcSpellsEntryApiListNpcSpellsEntries
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof NpcSpellsEntryApiListNpcSpellsEntries
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof NpcSpellsEntryApiListNpcSpellsEntries
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof NpcSpellsEntryApiListNpcSpellsEntries
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof NpcSpellsEntryApiListNpcSpellsEntries
     */
    readonly select?: string
}

/**
 * Request parameters for updateNpcSpellsEntry operation in NpcSpellsEntryApi.
 * @export
 * @interface NpcSpellsEntryApiUpdateNpcSpellsEntryRequest
 */
export interface NpcSpellsEntryApiUpdateNpcSpellsEntryRequest {
    /**
     * Id
     * @type {number}
     * @memberof NpcSpellsEntryApiUpdateNpcSpellsEntry
     */
    readonly id: number

    /**
     * NpcSpellsEntry
     * @type {ModelsNpcSpellsEntry}
     * @memberof NpcSpellsEntryApiUpdateNpcSpellsEntry
     */
    readonly npcSpellsEntry: ModelsNpcSpellsEntry
}

/**
 * NpcSpellsEntryApi - object-oriented interface
 * @export
 * @class NpcSpellsEntryApi
 * @extends {BaseAPI}
 */
export class NpcSpellsEntryApi extends BaseAPI {
    /**
     * 
     * @summary Creates NpcSpellsEntry
     * @param {NpcSpellsEntryApiCreateNpcSpellsEntryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcSpellsEntryApi
     */
    public createNpcSpellsEntry(requestParameters: NpcSpellsEntryApiCreateNpcSpellsEntryRequest, options?: any) {
        return NpcSpellsEntryApiFp(this.configuration).createNpcSpellsEntry(requestParameters.npcSpellsEntry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes NpcSpellsEntry
     * @param {NpcSpellsEntryApiDeleteNpcSpellsEntryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcSpellsEntryApi
     */
    public deleteNpcSpellsEntry(requestParameters: NpcSpellsEntryApiDeleteNpcSpellsEntryRequest, options?: any) {
        return NpcSpellsEntryApiFp(this.configuration).deleteNpcSpellsEntry(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets NpcSpellsEntry
     * @param {NpcSpellsEntryApiGetNpcSpellsEntryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcSpellsEntryApi
     */
    public getNpcSpellsEntry(requestParameters: NpcSpellsEntryApiGetNpcSpellsEntryRequest, options?: any) {
        return NpcSpellsEntryApiFp(this.configuration).getNpcSpellsEntry(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists NpcSpellsEntries
     * @param {NpcSpellsEntryApiListNpcSpellsEntriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcSpellsEntryApi
     */
    public listNpcSpellsEntries(requestParameters: NpcSpellsEntryApiListNpcSpellsEntriesRequest = {}, options?: any) {
        return NpcSpellsEntryApiFp(this.configuration).listNpcSpellsEntries(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates NpcSpellsEntry
     * @param {NpcSpellsEntryApiUpdateNpcSpellsEntryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcSpellsEntryApi
     */
    public updateNpcSpellsEntry(requestParameters: NpcSpellsEntryApiUpdateNpcSpellsEntryRequest, options?: any) {
        return NpcSpellsEntryApiFp(this.configuration).updateNpcSpellsEntry(requestParameters.id, requestParameters.npcSpellsEntry, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NpcTypeApi - axios parameter creator
 * @export
 */
export const NpcTypeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates NpcType
         * @param {ModelsNpcType} npcType NpcType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNpcType: async (npcType: ModelsNpcType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'npcType' is not null or undefined
            if (npcType === null || npcType === undefined) {
                throw new RequiredError('npcType','Required parameter npcType was null or undefined when calling createNpcType.');
            }
            const localVarPath = `/npc_type`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof npcType !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(npcType !== undefined ? npcType : {})
                : (npcType || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes NpcType
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNpcType: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteNpcType.');
            }
            const localVarPath = `/npc_type/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets NpcType
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;AlternateCurrency&lt;br&gt;Merchantlists&lt;br&gt;NpcEmotes&lt;br&gt;NpcFactions&lt;br&gt;NpcFactions.NpcFactionEntries&lt;br&gt;NpcSpells&lt;br&gt;NpcSpells.NpcSpellsEntries&lt;br&gt;NpcTypesTint&lt;br&gt;Spawnentries&lt;br&gt;Spawnentries.Spawngroup&lt;br&gt;Spawnentries.Spawngroup.Spawn2
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNpcType: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getNpcType.');
            }
            const localVarPath = `/npc_type/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists NpcTypes
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;AlternateCurrency&lt;br&gt;Merchantlists&lt;br&gt;NpcEmotes&lt;br&gt;NpcFactions&lt;br&gt;NpcFactions.NpcFactionEntries&lt;br&gt;NpcSpells&lt;br&gt;NpcSpells.NpcSpellsEntries&lt;br&gt;NpcTypesTint&lt;br&gt;Spawnentries&lt;br&gt;Spawnentries.Spawngroup&lt;br&gt;Spawnentries.Spawngroup.Spawn2
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNpcTypes: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/npc_types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates NpcType
         * @param {number} id Id
         * @param {ModelsNpcType} npcType NpcType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNpcType: async (id: number, npcType: ModelsNpcType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateNpcType.');
            }
            // verify required parameter 'npcType' is not null or undefined
            if (npcType === null || npcType === undefined) {
                throw new RequiredError('npcType','Required parameter npcType was null or undefined when calling updateNpcType.');
            }
            const localVarPath = `/npc_type/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof npcType !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(npcType !== undefined ? npcType : {})
                : (npcType || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NpcTypeApi - functional programming interface
 * @export
 */
export const NpcTypeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates NpcType
         * @param {ModelsNpcType} npcType NpcType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNpcType(npcType: ModelsNpcType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsNpcType>>> {
            const localVarAxiosArgs = await NpcTypeApiAxiosParamCreator(configuration).createNpcType(npcType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes NpcType
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNpcType(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await NpcTypeApiAxiosParamCreator(configuration).deleteNpcType(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets NpcType
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;AlternateCurrency&lt;br&gt;Merchantlists&lt;br&gt;NpcEmotes&lt;br&gt;NpcFactions&lt;br&gt;NpcFactions.NpcFactionEntries&lt;br&gt;NpcSpells&lt;br&gt;NpcSpells.NpcSpellsEntries&lt;br&gt;NpcTypesTint&lt;br&gt;Spawnentries&lt;br&gt;Spawnentries.Spawngroup&lt;br&gt;Spawnentries.Spawngroup.Spawn2
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNpcType(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsNpcType>>> {
            const localVarAxiosArgs = await NpcTypeApiAxiosParamCreator(configuration).getNpcType(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists NpcTypes
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;AlternateCurrency&lt;br&gt;Merchantlists&lt;br&gt;NpcEmotes&lt;br&gt;NpcFactions&lt;br&gt;NpcFactions.NpcFactionEntries&lt;br&gt;NpcSpells&lt;br&gt;NpcSpells.NpcSpellsEntries&lt;br&gt;NpcTypesTint&lt;br&gt;Spawnentries&lt;br&gt;Spawnentries.Spawngroup&lt;br&gt;Spawnentries.Spawngroup.Spawn2
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNpcTypes(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsNpcType>>> {
            const localVarAxiosArgs = await NpcTypeApiAxiosParamCreator(configuration).listNpcTypes(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates NpcType
         * @param {number} id Id
         * @param {ModelsNpcType} npcType NpcType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNpcType(id: number, npcType: ModelsNpcType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsNpcType>>> {
            const localVarAxiosArgs = await NpcTypeApiAxiosParamCreator(configuration).updateNpcType(id, npcType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * NpcTypeApi - factory interface
 * @export
 */
export const NpcTypeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates NpcType
         * @param {ModelsNpcType} npcType NpcType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNpcType(npcType: ModelsNpcType, options?: any): AxiosPromise<Array<ModelsNpcType>> {
            return NpcTypeApiFp(configuration).createNpcType(npcType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes NpcType
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNpcType(id: number, options?: any): AxiosPromise<string> {
            return NpcTypeApiFp(configuration).deleteNpcType(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets NpcType
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;AlternateCurrency&lt;br&gt;Merchantlists&lt;br&gt;NpcEmotes&lt;br&gt;NpcFactions&lt;br&gt;NpcFactions.NpcFactionEntries&lt;br&gt;NpcSpells&lt;br&gt;NpcSpells.NpcSpellsEntries&lt;br&gt;NpcTypesTint&lt;br&gt;Spawnentries&lt;br&gt;Spawnentries.Spawngroup&lt;br&gt;Spawnentries.Spawngroup.Spawn2
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNpcType(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsNpcType>> {
            return NpcTypeApiFp(configuration).getNpcType(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists NpcTypes
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;AlternateCurrency&lt;br&gt;Merchantlists&lt;br&gt;NpcEmotes&lt;br&gt;NpcFactions&lt;br&gt;NpcFactions.NpcFactionEntries&lt;br&gt;NpcSpells&lt;br&gt;NpcSpells.NpcSpellsEntries&lt;br&gt;NpcTypesTint&lt;br&gt;Spawnentries&lt;br&gt;Spawnentries.Spawngroup&lt;br&gt;Spawnentries.Spawngroup.Spawn2
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNpcTypes(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsNpcType>> {
            return NpcTypeApiFp(configuration).listNpcTypes(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates NpcType
         * @param {number} id Id
         * @param {ModelsNpcType} npcType NpcType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNpcType(id: number, npcType: ModelsNpcType, options?: any): AxiosPromise<Array<ModelsNpcType>> {
            return NpcTypeApiFp(configuration).updateNpcType(id, npcType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createNpcType operation in NpcTypeApi.
 * @export
 * @interface NpcTypeApiCreateNpcTypeRequest
 */
export interface NpcTypeApiCreateNpcTypeRequest {
    /**
     * NpcType
     * @type {ModelsNpcType}
     * @memberof NpcTypeApiCreateNpcType
     */
    readonly npcType: ModelsNpcType
}

/**
 * Request parameters for deleteNpcType operation in NpcTypeApi.
 * @export
 * @interface NpcTypeApiDeleteNpcTypeRequest
 */
export interface NpcTypeApiDeleteNpcTypeRequest {
    /**
     * Id
     * @type {number}
     * @memberof NpcTypeApiDeleteNpcType
     */
    readonly id: number
}

/**
 * Request parameters for getNpcType operation in NpcTypeApi.
 * @export
 * @interface NpcTypeApiGetNpcTypeRequest
 */
export interface NpcTypeApiGetNpcTypeRequest {
    /**
     * Id
     * @type {number}
     * @memberof NpcTypeApiGetNpcType
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;AlternateCurrency&lt;br&gt;Merchantlists&lt;br&gt;NpcEmotes&lt;br&gt;NpcFactions&lt;br&gt;NpcFactions.NpcFactionEntries&lt;br&gt;NpcSpells&lt;br&gt;NpcSpells.NpcSpellsEntries&lt;br&gt;NpcTypesTint&lt;br&gt;Spawnentries&lt;br&gt;Spawnentries.Spawngroup&lt;br&gt;Spawnentries.Spawngroup.Spawn2
     * @type {string}
     * @memberof NpcTypeApiGetNpcType
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof NpcTypeApiGetNpcType
     */
    readonly select?: string
}

/**
 * Request parameters for listNpcTypes operation in NpcTypeApi.
 * @export
 * @interface NpcTypeApiListNpcTypesRequest
 */
export interface NpcTypeApiListNpcTypesRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;AlternateCurrency&lt;br&gt;Merchantlists&lt;br&gt;NpcEmotes&lt;br&gt;NpcFactions&lt;br&gt;NpcFactions.NpcFactionEntries&lt;br&gt;NpcSpells&lt;br&gt;NpcSpells.NpcSpellsEntries&lt;br&gt;NpcTypesTint&lt;br&gt;Spawnentries&lt;br&gt;Spawnentries.Spawngroup&lt;br&gt;Spawnentries.Spawngroup.Spawn2
     * @type {string}
     * @memberof NpcTypeApiListNpcTypes
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof NpcTypeApiListNpcTypes
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof NpcTypeApiListNpcTypes
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof NpcTypeApiListNpcTypes
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof NpcTypeApiListNpcTypes
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof NpcTypeApiListNpcTypes
     */
    readonly select?: string
}

/**
 * Request parameters for updateNpcType operation in NpcTypeApi.
 * @export
 * @interface NpcTypeApiUpdateNpcTypeRequest
 */
export interface NpcTypeApiUpdateNpcTypeRequest {
    /**
     * Id
     * @type {number}
     * @memberof NpcTypeApiUpdateNpcType
     */
    readonly id: number

    /**
     * NpcType
     * @type {ModelsNpcType}
     * @memberof NpcTypeApiUpdateNpcType
     */
    readonly npcType: ModelsNpcType
}

/**
 * NpcTypeApi - object-oriented interface
 * @export
 * @class NpcTypeApi
 * @extends {BaseAPI}
 */
export class NpcTypeApi extends BaseAPI {
    /**
     * 
     * @summary Creates NpcType
     * @param {NpcTypeApiCreateNpcTypeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcTypeApi
     */
    public createNpcType(requestParameters: NpcTypeApiCreateNpcTypeRequest, options?: any) {
        return NpcTypeApiFp(this.configuration).createNpcType(requestParameters.npcType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes NpcType
     * @param {NpcTypeApiDeleteNpcTypeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcTypeApi
     */
    public deleteNpcType(requestParameters: NpcTypeApiDeleteNpcTypeRequest, options?: any) {
        return NpcTypeApiFp(this.configuration).deleteNpcType(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets NpcType
     * @param {NpcTypeApiGetNpcTypeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcTypeApi
     */
    public getNpcType(requestParameters: NpcTypeApiGetNpcTypeRequest, options?: any) {
        return NpcTypeApiFp(this.configuration).getNpcType(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists NpcTypes
     * @param {NpcTypeApiListNpcTypesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcTypeApi
     */
    public listNpcTypes(requestParameters: NpcTypeApiListNpcTypesRequest = {}, options?: any) {
        return NpcTypeApiFp(this.configuration).listNpcTypes(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates NpcType
     * @param {NpcTypeApiUpdateNpcTypeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcTypeApi
     */
    public updateNpcType(requestParameters: NpcTypeApiUpdateNpcTypeRequest, options?: any) {
        return NpcTypeApiFp(this.configuration).updateNpcType(requestParameters.id, requestParameters.npcType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NpcTypesTintApi - axios parameter creator
 * @export
 */
export const NpcTypesTintApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates NpcTypesTint
         * @param {ModelsNpcTypesTint} npcTypesTint NpcTypesTint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNpcTypesTint: async (npcTypesTint: ModelsNpcTypesTint, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'npcTypesTint' is not null or undefined
            if (npcTypesTint === null || npcTypesTint === undefined) {
                throw new RequiredError('npcTypesTint','Required parameter npcTypesTint was null or undefined when calling createNpcTypesTint.');
            }
            const localVarPath = `/npc_types_tint`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof npcTypesTint !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(npcTypesTint !== undefined ? npcTypesTint : {})
                : (npcTypesTint || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes NpcTypesTint
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNpcTypesTint: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteNpcTypesTint.');
            }
            const localVarPath = `/npc_types_tint/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets NpcTypesTint
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNpcTypesTint: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getNpcTypesTint.');
            }
            const localVarPath = `/npc_types_tint/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists NpcTypesTints
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNpcTypesTints: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/npc_types_tints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates NpcTypesTint
         * @param {number} id Id
         * @param {ModelsNpcTypesTint} npcTypesTint NpcTypesTint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNpcTypesTint: async (id: number, npcTypesTint: ModelsNpcTypesTint, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateNpcTypesTint.');
            }
            // verify required parameter 'npcTypesTint' is not null or undefined
            if (npcTypesTint === null || npcTypesTint === undefined) {
                throw new RequiredError('npcTypesTint','Required parameter npcTypesTint was null or undefined when calling updateNpcTypesTint.');
            }
            const localVarPath = `/npc_types_tint/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof npcTypesTint !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(npcTypesTint !== undefined ? npcTypesTint : {})
                : (npcTypesTint || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NpcTypesTintApi - functional programming interface
 * @export
 */
export const NpcTypesTintApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates NpcTypesTint
         * @param {ModelsNpcTypesTint} npcTypesTint NpcTypesTint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNpcTypesTint(npcTypesTint: ModelsNpcTypesTint, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsNpcTypesTint>>> {
            const localVarAxiosArgs = await NpcTypesTintApiAxiosParamCreator(configuration).createNpcTypesTint(npcTypesTint, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes NpcTypesTint
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNpcTypesTint(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await NpcTypesTintApiAxiosParamCreator(configuration).deleteNpcTypesTint(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets NpcTypesTint
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNpcTypesTint(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsNpcTypesTint>>> {
            const localVarAxiosArgs = await NpcTypesTintApiAxiosParamCreator(configuration).getNpcTypesTint(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists NpcTypesTints
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNpcTypesTints(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsNpcTypesTint>>> {
            const localVarAxiosArgs = await NpcTypesTintApiAxiosParamCreator(configuration).listNpcTypesTints(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates NpcTypesTint
         * @param {number} id Id
         * @param {ModelsNpcTypesTint} npcTypesTint NpcTypesTint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNpcTypesTint(id: number, npcTypesTint: ModelsNpcTypesTint, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsNpcTypesTint>>> {
            const localVarAxiosArgs = await NpcTypesTintApiAxiosParamCreator(configuration).updateNpcTypesTint(id, npcTypesTint, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * NpcTypesTintApi - factory interface
 * @export
 */
export const NpcTypesTintApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates NpcTypesTint
         * @param {ModelsNpcTypesTint} npcTypesTint NpcTypesTint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNpcTypesTint(npcTypesTint: ModelsNpcTypesTint, options?: any): AxiosPromise<Array<ModelsNpcTypesTint>> {
            return NpcTypesTintApiFp(configuration).createNpcTypesTint(npcTypesTint, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes NpcTypesTint
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNpcTypesTint(id: number, options?: any): AxiosPromise<string> {
            return NpcTypesTintApiFp(configuration).deleteNpcTypesTint(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets NpcTypesTint
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNpcTypesTint(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsNpcTypesTint>> {
            return NpcTypesTintApiFp(configuration).getNpcTypesTint(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists NpcTypesTints
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNpcTypesTints(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsNpcTypesTint>> {
            return NpcTypesTintApiFp(configuration).listNpcTypesTints(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates NpcTypesTint
         * @param {number} id Id
         * @param {ModelsNpcTypesTint} npcTypesTint NpcTypesTint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNpcTypesTint(id: number, npcTypesTint: ModelsNpcTypesTint, options?: any): AxiosPromise<Array<ModelsNpcTypesTint>> {
            return NpcTypesTintApiFp(configuration).updateNpcTypesTint(id, npcTypesTint, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createNpcTypesTint operation in NpcTypesTintApi.
 * @export
 * @interface NpcTypesTintApiCreateNpcTypesTintRequest
 */
export interface NpcTypesTintApiCreateNpcTypesTintRequest {
    /**
     * NpcTypesTint
     * @type {ModelsNpcTypesTint}
     * @memberof NpcTypesTintApiCreateNpcTypesTint
     */
    readonly npcTypesTint: ModelsNpcTypesTint
}

/**
 * Request parameters for deleteNpcTypesTint operation in NpcTypesTintApi.
 * @export
 * @interface NpcTypesTintApiDeleteNpcTypesTintRequest
 */
export interface NpcTypesTintApiDeleteNpcTypesTintRequest {
    /**
     * Id
     * @type {number}
     * @memberof NpcTypesTintApiDeleteNpcTypesTint
     */
    readonly id: number
}

/**
 * Request parameters for getNpcTypesTint operation in NpcTypesTintApi.
 * @export
 * @interface NpcTypesTintApiGetNpcTypesTintRequest
 */
export interface NpcTypesTintApiGetNpcTypesTintRequest {
    /**
     * Id
     * @type {number}
     * @memberof NpcTypesTintApiGetNpcTypesTint
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof NpcTypesTintApiGetNpcTypesTint
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof NpcTypesTintApiGetNpcTypesTint
     */
    readonly select?: string
}

/**
 * Request parameters for listNpcTypesTints operation in NpcTypesTintApi.
 * @export
 * @interface NpcTypesTintApiListNpcTypesTintsRequest
 */
export interface NpcTypesTintApiListNpcTypesTintsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof NpcTypesTintApiListNpcTypesTints
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof NpcTypesTintApiListNpcTypesTints
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof NpcTypesTintApiListNpcTypesTints
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof NpcTypesTintApiListNpcTypesTints
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof NpcTypesTintApiListNpcTypesTints
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof NpcTypesTintApiListNpcTypesTints
     */
    readonly select?: string
}

/**
 * Request parameters for updateNpcTypesTint operation in NpcTypesTintApi.
 * @export
 * @interface NpcTypesTintApiUpdateNpcTypesTintRequest
 */
export interface NpcTypesTintApiUpdateNpcTypesTintRequest {
    /**
     * Id
     * @type {number}
     * @memberof NpcTypesTintApiUpdateNpcTypesTint
     */
    readonly id: number

    /**
     * NpcTypesTint
     * @type {ModelsNpcTypesTint}
     * @memberof NpcTypesTintApiUpdateNpcTypesTint
     */
    readonly npcTypesTint: ModelsNpcTypesTint
}

/**
 * NpcTypesTintApi - object-oriented interface
 * @export
 * @class NpcTypesTintApi
 * @extends {BaseAPI}
 */
export class NpcTypesTintApi extends BaseAPI {
    /**
     * 
     * @summary Creates NpcTypesTint
     * @param {NpcTypesTintApiCreateNpcTypesTintRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcTypesTintApi
     */
    public createNpcTypesTint(requestParameters: NpcTypesTintApiCreateNpcTypesTintRequest, options?: any) {
        return NpcTypesTintApiFp(this.configuration).createNpcTypesTint(requestParameters.npcTypesTint, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes NpcTypesTint
     * @param {NpcTypesTintApiDeleteNpcTypesTintRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcTypesTintApi
     */
    public deleteNpcTypesTint(requestParameters: NpcTypesTintApiDeleteNpcTypesTintRequest, options?: any) {
        return NpcTypesTintApiFp(this.configuration).deleteNpcTypesTint(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets NpcTypesTint
     * @param {NpcTypesTintApiGetNpcTypesTintRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcTypesTintApi
     */
    public getNpcTypesTint(requestParameters: NpcTypesTintApiGetNpcTypesTintRequest, options?: any) {
        return NpcTypesTintApiFp(this.configuration).getNpcTypesTint(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists NpcTypesTints
     * @param {NpcTypesTintApiListNpcTypesTintsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcTypesTintApi
     */
    public listNpcTypesTints(requestParameters: NpcTypesTintApiListNpcTypesTintsRequest = {}, options?: any) {
        return NpcTypesTintApiFp(this.configuration).listNpcTypesTints(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates NpcTypesTint
     * @param {NpcTypesTintApiUpdateNpcTypesTintRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NpcTypesTintApi
     */
    public updateNpcTypesTint(requestParameters: NpcTypesTintApiUpdateNpcTypesTintRequest, options?: any) {
        return NpcTypesTintApiFp(this.configuration).updateNpcTypesTint(requestParameters.id, requestParameters.npcTypesTint, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ObjectApi - axios parameter creator
 * @export
 */
export const ObjectApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Object
         * @param {ModelsObject} object Object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createObject: async (object: ModelsObject, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'object' is not null or undefined
            if (object === null || object === undefined) {
                throw new RequiredError('object','Required parameter object was null or undefined when calling createObject.');
            }
            const localVarPath = `/object`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof object !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(object !== undefined ? object : {})
                : (object || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes Object
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteObject: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteObject.');
            }
            const localVarPath = `/object/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Object
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObject: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getObject.');
            }
            const localVarPath = `/object/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists Objects
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listObjects: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/objects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates Object
         * @param {number} id Id
         * @param {ModelsObject} object Object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateObject: async (id: number, object: ModelsObject, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateObject.');
            }
            // verify required parameter 'object' is not null or undefined
            if (object === null || object === undefined) {
                throw new RequiredError('object','Required parameter object was null or undefined when calling updateObject.');
            }
            const localVarPath = `/object/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof object !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(object !== undefined ? object : {})
                : (object || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ObjectApi - functional programming interface
 * @export
 */
export const ObjectApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Object
         * @param {ModelsObject} object Object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createObject(object: ModelsObject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsObject>>> {
            const localVarAxiosArgs = await ObjectApiAxiosParamCreator(configuration).createObject(object, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes Object
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteObject(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await ObjectApiAxiosParamCreator(configuration).deleteObject(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Object
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getObject(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsObject>>> {
            const localVarAxiosArgs = await ObjectApiAxiosParamCreator(configuration).getObject(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists Objects
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listObjects(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsObject>>> {
            const localVarAxiosArgs = await ObjectApiAxiosParamCreator(configuration).listObjects(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates Object
         * @param {number} id Id
         * @param {ModelsObject} object Object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateObject(id: number, object: ModelsObject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsObject>>> {
            const localVarAxiosArgs = await ObjectApiAxiosParamCreator(configuration).updateObject(id, object, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ObjectApi - factory interface
 * @export
 */
export const ObjectApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates Object
         * @param {ModelsObject} object Object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createObject(object: ModelsObject, options?: any): AxiosPromise<Array<ModelsObject>> {
            return ObjectApiFp(configuration).createObject(object, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes Object
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteObject(id: number, options?: any): AxiosPromise<string> {
            return ObjectApiFp(configuration).deleteObject(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Object
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObject(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsObject>> {
            return ObjectApiFp(configuration).getObject(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists Objects
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listObjects(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsObject>> {
            return ObjectApiFp(configuration).listObjects(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates Object
         * @param {number} id Id
         * @param {ModelsObject} object Object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateObject(id: number, object: ModelsObject, options?: any): AxiosPromise<Array<ModelsObject>> {
            return ObjectApiFp(configuration).updateObject(id, object, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createObject operation in ObjectApi.
 * @export
 * @interface ObjectApiCreateObjectRequest
 */
export interface ObjectApiCreateObjectRequest {
    /**
     * Object
     * @type {ModelsObject}
     * @memberof ObjectApiCreateObject
     */
    readonly object: ModelsObject
}

/**
 * Request parameters for deleteObject operation in ObjectApi.
 * @export
 * @interface ObjectApiDeleteObjectRequest
 */
export interface ObjectApiDeleteObjectRequest {
    /**
     * Id
     * @type {number}
     * @memberof ObjectApiDeleteObject
     */
    readonly id: number
}

/**
 * Request parameters for getObject operation in ObjectApi.
 * @export
 * @interface ObjectApiGetObjectRequest
 */
export interface ObjectApiGetObjectRequest {
    /**
     * Id
     * @type {number}
     * @memberof ObjectApiGetObject
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof ObjectApiGetObject
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof ObjectApiGetObject
     */
    readonly select?: string
}

/**
 * Request parameters for listObjects operation in ObjectApi.
 * @export
 * @interface ObjectApiListObjectsRequest
 */
export interface ObjectApiListObjectsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof ObjectApiListObjects
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof ObjectApiListObjects
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof ObjectApiListObjects
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof ObjectApiListObjects
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof ObjectApiListObjects
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof ObjectApiListObjects
     */
    readonly select?: string
}

/**
 * Request parameters for updateObject operation in ObjectApi.
 * @export
 * @interface ObjectApiUpdateObjectRequest
 */
export interface ObjectApiUpdateObjectRequest {
    /**
     * Id
     * @type {number}
     * @memberof ObjectApiUpdateObject
     */
    readonly id: number

    /**
     * Object
     * @type {ModelsObject}
     * @memberof ObjectApiUpdateObject
     */
    readonly object: ModelsObject
}

/**
 * ObjectApi - object-oriented interface
 * @export
 * @class ObjectApi
 * @extends {BaseAPI}
 */
export class ObjectApi extends BaseAPI {
    /**
     * 
     * @summary Creates Object
     * @param {ObjectApiCreateObjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectApi
     */
    public createObject(requestParameters: ObjectApiCreateObjectRequest, options?: any) {
        return ObjectApiFp(this.configuration).createObject(requestParameters.object, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes Object
     * @param {ObjectApiDeleteObjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectApi
     */
    public deleteObject(requestParameters: ObjectApiDeleteObjectRequest, options?: any) {
        return ObjectApiFp(this.configuration).deleteObject(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Object
     * @param {ObjectApiGetObjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectApi
     */
    public getObject(requestParameters: ObjectApiGetObjectRequest, options?: any) {
        return ObjectApiFp(this.configuration).getObject(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists Objects
     * @param {ObjectApiListObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectApi
     */
    public listObjects(requestParameters: ObjectApiListObjectsRequest = {}, options?: any) {
        return ObjectApiFp(this.configuration).listObjects(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates Object
     * @param {ObjectApiUpdateObjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectApi
     */
    public updateObject(requestParameters: ObjectApiUpdateObjectRequest, options?: any) {
        return ObjectApiFp(this.configuration).updateObject(requestParameters.id, requestParameters.object, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PerlEventExportSettingApi - axios parameter creator
 * @export
 */
export const PerlEventExportSettingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates PerlEventExportSetting
         * @param {ModelsPerlEventExportSetting} perlEventExportSetting PerlEventExportSetting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPerlEventExportSetting: async (perlEventExportSetting: ModelsPerlEventExportSetting, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'perlEventExportSetting' is not null or undefined
            if (perlEventExportSetting === null || perlEventExportSetting === undefined) {
                throw new RequiredError('perlEventExportSetting','Required parameter perlEventExportSetting was null or undefined when calling createPerlEventExportSetting.');
            }
            const localVarPath = `/perl_event_export_setting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof perlEventExportSetting !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(perlEventExportSetting !== undefined ? perlEventExportSetting : {})
                : (perlEventExportSetting || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes PerlEventExportSetting
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePerlEventExportSetting: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deletePerlEventExportSetting.');
            }
            const localVarPath = `/perl_event_export_setting/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets PerlEventExportSetting
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPerlEventExportSetting: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPerlEventExportSetting.');
            }
            const localVarPath = `/perl_event_export_setting/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists PerlEventExportSettings
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPerlEventExportSettings: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/perl_event_export_settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates PerlEventExportSetting
         * @param {number} id Id
         * @param {ModelsPerlEventExportSetting} perlEventExportSetting PerlEventExportSetting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePerlEventExportSetting: async (id: number, perlEventExportSetting: ModelsPerlEventExportSetting, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updatePerlEventExportSetting.');
            }
            // verify required parameter 'perlEventExportSetting' is not null or undefined
            if (perlEventExportSetting === null || perlEventExportSetting === undefined) {
                throw new RequiredError('perlEventExportSetting','Required parameter perlEventExportSetting was null or undefined when calling updatePerlEventExportSetting.');
            }
            const localVarPath = `/perl_event_export_setting/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof perlEventExportSetting !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(perlEventExportSetting !== undefined ? perlEventExportSetting : {})
                : (perlEventExportSetting || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PerlEventExportSettingApi - functional programming interface
 * @export
 */
export const PerlEventExportSettingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates PerlEventExportSetting
         * @param {ModelsPerlEventExportSetting} perlEventExportSetting PerlEventExportSetting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPerlEventExportSetting(perlEventExportSetting: ModelsPerlEventExportSetting, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsPerlEventExportSetting>>> {
            const localVarAxiosArgs = await PerlEventExportSettingApiAxiosParamCreator(configuration).createPerlEventExportSetting(perlEventExportSetting, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes PerlEventExportSetting
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePerlEventExportSetting(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await PerlEventExportSettingApiAxiosParamCreator(configuration).deletePerlEventExportSetting(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets PerlEventExportSetting
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPerlEventExportSetting(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsPerlEventExportSetting>>> {
            const localVarAxiosArgs = await PerlEventExportSettingApiAxiosParamCreator(configuration).getPerlEventExportSetting(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists PerlEventExportSettings
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPerlEventExportSettings(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsPerlEventExportSetting>>> {
            const localVarAxiosArgs = await PerlEventExportSettingApiAxiosParamCreator(configuration).listPerlEventExportSettings(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates PerlEventExportSetting
         * @param {number} id Id
         * @param {ModelsPerlEventExportSetting} perlEventExportSetting PerlEventExportSetting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePerlEventExportSetting(id: number, perlEventExportSetting: ModelsPerlEventExportSetting, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsPerlEventExportSetting>>> {
            const localVarAxiosArgs = await PerlEventExportSettingApiAxiosParamCreator(configuration).updatePerlEventExportSetting(id, perlEventExportSetting, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PerlEventExportSettingApi - factory interface
 * @export
 */
export const PerlEventExportSettingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates PerlEventExportSetting
         * @param {ModelsPerlEventExportSetting} perlEventExportSetting PerlEventExportSetting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPerlEventExportSetting(perlEventExportSetting: ModelsPerlEventExportSetting, options?: any): AxiosPromise<Array<ModelsPerlEventExportSetting>> {
            return PerlEventExportSettingApiFp(configuration).createPerlEventExportSetting(perlEventExportSetting, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes PerlEventExportSetting
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePerlEventExportSetting(id: number, options?: any): AxiosPromise<string> {
            return PerlEventExportSettingApiFp(configuration).deletePerlEventExportSetting(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets PerlEventExportSetting
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPerlEventExportSetting(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsPerlEventExportSetting>> {
            return PerlEventExportSettingApiFp(configuration).getPerlEventExportSetting(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists PerlEventExportSettings
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPerlEventExportSettings(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsPerlEventExportSetting>> {
            return PerlEventExportSettingApiFp(configuration).listPerlEventExportSettings(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates PerlEventExportSetting
         * @param {number} id Id
         * @param {ModelsPerlEventExportSetting} perlEventExportSetting PerlEventExportSetting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePerlEventExportSetting(id: number, perlEventExportSetting: ModelsPerlEventExportSetting, options?: any): AxiosPromise<Array<ModelsPerlEventExportSetting>> {
            return PerlEventExportSettingApiFp(configuration).updatePerlEventExportSetting(id, perlEventExportSetting, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createPerlEventExportSetting operation in PerlEventExportSettingApi.
 * @export
 * @interface PerlEventExportSettingApiCreatePerlEventExportSettingRequest
 */
export interface PerlEventExportSettingApiCreatePerlEventExportSettingRequest {
    /**
     * PerlEventExportSetting
     * @type {ModelsPerlEventExportSetting}
     * @memberof PerlEventExportSettingApiCreatePerlEventExportSetting
     */
    readonly perlEventExportSetting: ModelsPerlEventExportSetting
}

/**
 * Request parameters for deletePerlEventExportSetting operation in PerlEventExportSettingApi.
 * @export
 * @interface PerlEventExportSettingApiDeletePerlEventExportSettingRequest
 */
export interface PerlEventExportSettingApiDeletePerlEventExportSettingRequest {
    /**
     * Id
     * @type {number}
     * @memberof PerlEventExportSettingApiDeletePerlEventExportSetting
     */
    readonly id: number
}

/**
 * Request parameters for getPerlEventExportSetting operation in PerlEventExportSettingApi.
 * @export
 * @interface PerlEventExportSettingApiGetPerlEventExportSettingRequest
 */
export interface PerlEventExportSettingApiGetPerlEventExportSettingRequest {
    /**
     * Id
     * @type {number}
     * @memberof PerlEventExportSettingApiGetPerlEventExportSetting
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof PerlEventExportSettingApiGetPerlEventExportSetting
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof PerlEventExportSettingApiGetPerlEventExportSetting
     */
    readonly select?: string
}

/**
 * Request parameters for listPerlEventExportSettings operation in PerlEventExportSettingApi.
 * @export
 * @interface PerlEventExportSettingApiListPerlEventExportSettingsRequest
 */
export interface PerlEventExportSettingApiListPerlEventExportSettingsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof PerlEventExportSettingApiListPerlEventExportSettings
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof PerlEventExportSettingApiListPerlEventExportSettings
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof PerlEventExportSettingApiListPerlEventExportSettings
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof PerlEventExportSettingApiListPerlEventExportSettings
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof PerlEventExportSettingApiListPerlEventExportSettings
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof PerlEventExportSettingApiListPerlEventExportSettings
     */
    readonly select?: string
}

/**
 * Request parameters for updatePerlEventExportSetting operation in PerlEventExportSettingApi.
 * @export
 * @interface PerlEventExportSettingApiUpdatePerlEventExportSettingRequest
 */
export interface PerlEventExportSettingApiUpdatePerlEventExportSettingRequest {
    /**
     * Id
     * @type {number}
     * @memberof PerlEventExportSettingApiUpdatePerlEventExportSetting
     */
    readonly id: number

    /**
     * PerlEventExportSetting
     * @type {ModelsPerlEventExportSetting}
     * @memberof PerlEventExportSettingApiUpdatePerlEventExportSetting
     */
    readonly perlEventExportSetting: ModelsPerlEventExportSetting
}

/**
 * PerlEventExportSettingApi - object-oriented interface
 * @export
 * @class PerlEventExportSettingApi
 * @extends {BaseAPI}
 */
export class PerlEventExportSettingApi extends BaseAPI {
    /**
     * 
     * @summary Creates PerlEventExportSetting
     * @param {PerlEventExportSettingApiCreatePerlEventExportSettingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerlEventExportSettingApi
     */
    public createPerlEventExportSetting(requestParameters: PerlEventExportSettingApiCreatePerlEventExportSettingRequest, options?: any) {
        return PerlEventExportSettingApiFp(this.configuration).createPerlEventExportSetting(requestParameters.perlEventExportSetting, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes PerlEventExportSetting
     * @param {PerlEventExportSettingApiDeletePerlEventExportSettingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerlEventExportSettingApi
     */
    public deletePerlEventExportSetting(requestParameters: PerlEventExportSettingApiDeletePerlEventExportSettingRequest, options?: any) {
        return PerlEventExportSettingApiFp(this.configuration).deletePerlEventExportSetting(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets PerlEventExportSetting
     * @param {PerlEventExportSettingApiGetPerlEventExportSettingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerlEventExportSettingApi
     */
    public getPerlEventExportSetting(requestParameters: PerlEventExportSettingApiGetPerlEventExportSettingRequest, options?: any) {
        return PerlEventExportSettingApiFp(this.configuration).getPerlEventExportSetting(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists PerlEventExportSettings
     * @param {PerlEventExportSettingApiListPerlEventExportSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerlEventExportSettingApi
     */
    public listPerlEventExportSettings(requestParameters: PerlEventExportSettingApiListPerlEventExportSettingsRequest = {}, options?: any) {
        return PerlEventExportSettingApiFp(this.configuration).listPerlEventExportSettings(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates PerlEventExportSetting
     * @param {PerlEventExportSettingApiUpdatePerlEventExportSettingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PerlEventExportSettingApi
     */
    public updatePerlEventExportSetting(requestParameters: PerlEventExportSettingApiUpdatePerlEventExportSettingRequest, options?: any) {
        return PerlEventExportSettingApiFp(this.configuration).updatePerlEventExportSetting(requestParameters.id, requestParameters.perlEventExportSetting, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PetsEquipmentsetApi - axios parameter creator
 * @export
 */
export const PetsEquipmentsetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates PetsEquipmentset
         * @param {ModelsPetsEquipmentset} petsEquipmentset PetsEquipmentset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPetsEquipmentset: async (petsEquipmentset: ModelsPetsEquipmentset, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'petsEquipmentset' is not null or undefined
            if (petsEquipmentset === null || petsEquipmentset === undefined) {
                throw new RequiredError('petsEquipmentset','Required parameter petsEquipmentset was null or undefined when calling createPetsEquipmentset.');
            }
            const localVarPath = `/pets_equipmentset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof petsEquipmentset !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(petsEquipmentset !== undefined ? petsEquipmentset : {})
                : (petsEquipmentset || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes PetsEquipmentset
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePetsEquipmentset: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deletePetsEquipmentset.');
            }
            const localVarPath = `/pets_equipmentset/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets PetsEquipmentset
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;PetsEquipmentsetEntries
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPetsEquipmentset: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPetsEquipmentset.');
            }
            const localVarPath = `/pets_equipmentset/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists PetsEquipmentsets
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;PetsEquipmentsetEntries
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPetsEquipmentsets: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pets_equipmentsets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates PetsEquipmentset
         * @param {number} id Id
         * @param {ModelsPetsEquipmentset} petsEquipmentset PetsEquipmentset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePetsEquipmentset: async (id: number, petsEquipmentset: ModelsPetsEquipmentset, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updatePetsEquipmentset.');
            }
            // verify required parameter 'petsEquipmentset' is not null or undefined
            if (petsEquipmentset === null || petsEquipmentset === undefined) {
                throw new RequiredError('petsEquipmentset','Required parameter petsEquipmentset was null or undefined when calling updatePetsEquipmentset.');
            }
            const localVarPath = `/pets_equipmentset/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof petsEquipmentset !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(petsEquipmentset !== undefined ? petsEquipmentset : {})
                : (petsEquipmentset || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PetsEquipmentsetApi - functional programming interface
 * @export
 */
export const PetsEquipmentsetApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates PetsEquipmentset
         * @param {ModelsPetsEquipmentset} petsEquipmentset PetsEquipmentset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPetsEquipmentset(petsEquipmentset: ModelsPetsEquipmentset, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsPetsEquipmentset>>> {
            const localVarAxiosArgs = await PetsEquipmentsetApiAxiosParamCreator(configuration).createPetsEquipmentset(petsEquipmentset, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes PetsEquipmentset
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePetsEquipmentset(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await PetsEquipmentsetApiAxiosParamCreator(configuration).deletePetsEquipmentset(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets PetsEquipmentset
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;PetsEquipmentsetEntries
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPetsEquipmentset(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsPetsEquipmentset>>> {
            const localVarAxiosArgs = await PetsEquipmentsetApiAxiosParamCreator(configuration).getPetsEquipmentset(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists PetsEquipmentsets
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;PetsEquipmentsetEntries
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPetsEquipmentsets(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsPetsEquipmentset>>> {
            const localVarAxiosArgs = await PetsEquipmentsetApiAxiosParamCreator(configuration).listPetsEquipmentsets(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates PetsEquipmentset
         * @param {number} id Id
         * @param {ModelsPetsEquipmentset} petsEquipmentset PetsEquipmentset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePetsEquipmentset(id: number, petsEquipmentset: ModelsPetsEquipmentset, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsPetsEquipmentset>>> {
            const localVarAxiosArgs = await PetsEquipmentsetApiAxiosParamCreator(configuration).updatePetsEquipmentset(id, petsEquipmentset, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PetsEquipmentsetApi - factory interface
 * @export
 */
export const PetsEquipmentsetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates PetsEquipmentset
         * @param {ModelsPetsEquipmentset} petsEquipmentset PetsEquipmentset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPetsEquipmentset(petsEquipmentset: ModelsPetsEquipmentset, options?: any): AxiosPromise<Array<ModelsPetsEquipmentset>> {
            return PetsEquipmentsetApiFp(configuration).createPetsEquipmentset(petsEquipmentset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes PetsEquipmentset
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePetsEquipmentset(id: number, options?: any): AxiosPromise<string> {
            return PetsEquipmentsetApiFp(configuration).deletePetsEquipmentset(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets PetsEquipmentset
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;PetsEquipmentsetEntries
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPetsEquipmentset(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsPetsEquipmentset>> {
            return PetsEquipmentsetApiFp(configuration).getPetsEquipmentset(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists PetsEquipmentsets
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;PetsEquipmentsetEntries
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPetsEquipmentsets(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsPetsEquipmentset>> {
            return PetsEquipmentsetApiFp(configuration).listPetsEquipmentsets(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates PetsEquipmentset
         * @param {number} id Id
         * @param {ModelsPetsEquipmentset} petsEquipmentset PetsEquipmentset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePetsEquipmentset(id: number, petsEquipmentset: ModelsPetsEquipmentset, options?: any): AxiosPromise<Array<ModelsPetsEquipmentset>> {
            return PetsEquipmentsetApiFp(configuration).updatePetsEquipmentset(id, petsEquipmentset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createPetsEquipmentset operation in PetsEquipmentsetApi.
 * @export
 * @interface PetsEquipmentsetApiCreatePetsEquipmentsetRequest
 */
export interface PetsEquipmentsetApiCreatePetsEquipmentsetRequest {
    /**
     * PetsEquipmentset
     * @type {ModelsPetsEquipmentset}
     * @memberof PetsEquipmentsetApiCreatePetsEquipmentset
     */
    readonly petsEquipmentset: ModelsPetsEquipmentset
}

/**
 * Request parameters for deletePetsEquipmentset operation in PetsEquipmentsetApi.
 * @export
 * @interface PetsEquipmentsetApiDeletePetsEquipmentsetRequest
 */
export interface PetsEquipmentsetApiDeletePetsEquipmentsetRequest {
    /**
     * Id
     * @type {number}
     * @memberof PetsEquipmentsetApiDeletePetsEquipmentset
     */
    readonly id: number
}

/**
 * Request parameters for getPetsEquipmentset operation in PetsEquipmentsetApi.
 * @export
 * @interface PetsEquipmentsetApiGetPetsEquipmentsetRequest
 */
export interface PetsEquipmentsetApiGetPetsEquipmentsetRequest {
    /**
     * Id
     * @type {number}
     * @memberof PetsEquipmentsetApiGetPetsEquipmentset
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;PetsEquipmentsetEntries
     * @type {string}
     * @memberof PetsEquipmentsetApiGetPetsEquipmentset
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof PetsEquipmentsetApiGetPetsEquipmentset
     */
    readonly select?: string
}

/**
 * Request parameters for listPetsEquipmentsets operation in PetsEquipmentsetApi.
 * @export
 * @interface PetsEquipmentsetApiListPetsEquipmentsetsRequest
 */
export interface PetsEquipmentsetApiListPetsEquipmentsetsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;PetsEquipmentsetEntries
     * @type {string}
     * @memberof PetsEquipmentsetApiListPetsEquipmentsets
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof PetsEquipmentsetApiListPetsEquipmentsets
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof PetsEquipmentsetApiListPetsEquipmentsets
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof PetsEquipmentsetApiListPetsEquipmentsets
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof PetsEquipmentsetApiListPetsEquipmentsets
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof PetsEquipmentsetApiListPetsEquipmentsets
     */
    readonly select?: string
}

/**
 * Request parameters for updatePetsEquipmentset operation in PetsEquipmentsetApi.
 * @export
 * @interface PetsEquipmentsetApiUpdatePetsEquipmentsetRequest
 */
export interface PetsEquipmentsetApiUpdatePetsEquipmentsetRequest {
    /**
     * Id
     * @type {number}
     * @memberof PetsEquipmentsetApiUpdatePetsEquipmentset
     */
    readonly id: number

    /**
     * PetsEquipmentset
     * @type {ModelsPetsEquipmentset}
     * @memberof PetsEquipmentsetApiUpdatePetsEquipmentset
     */
    readonly petsEquipmentset: ModelsPetsEquipmentset
}

/**
 * PetsEquipmentsetApi - object-oriented interface
 * @export
 * @class PetsEquipmentsetApi
 * @extends {BaseAPI}
 */
export class PetsEquipmentsetApi extends BaseAPI {
    /**
     * 
     * @summary Creates PetsEquipmentset
     * @param {PetsEquipmentsetApiCreatePetsEquipmentsetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PetsEquipmentsetApi
     */
    public createPetsEquipmentset(requestParameters: PetsEquipmentsetApiCreatePetsEquipmentsetRequest, options?: any) {
        return PetsEquipmentsetApiFp(this.configuration).createPetsEquipmentset(requestParameters.petsEquipmentset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes PetsEquipmentset
     * @param {PetsEquipmentsetApiDeletePetsEquipmentsetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PetsEquipmentsetApi
     */
    public deletePetsEquipmentset(requestParameters: PetsEquipmentsetApiDeletePetsEquipmentsetRequest, options?: any) {
        return PetsEquipmentsetApiFp(this.configuration).deletePetsEquipmentset(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets PetsEquipmentset
     * @param {PetsEquipmentsetApiGetPetsEquipmentsetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PetsEquipmentsetApi
     */
    public getPetsEquipmentset(requestParameters: PetsEquipmentsetApiGetPetsEquipmentsetRequest, options?: any) {
        return PetsEquipmentsetApiFp(this.configuration).getPetsEquipmentset(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists PetsEquipmentsets
     * @param {PetsEquipmentsetApiListPetsEquipmentsetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PetsEquipmentsetApi
     */
    public listPetsEquipmentsets(requestParameters: PetsEquipmentsetApiListPetsEquipmentsetsRequest = {}, options?: any) {
        return PetsEquipmentsetApiFp(this.configuration).listPetsEquipmentsets(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates PetsEquipmentset
     * @param {PetsEquipmentsetApiUpdatePetsEquipmentsetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PetsEquipmentsetApi
     */
    public updatePetsEquipmentset(requestParameters: PetsEquipmentsetApiUpdatePetsEquipmentsetRequest, options?: any) {
        return PetsEquipmentsetApiFp(this.configuration).updatePetsEquipmentset(requestParameters.id, requestParameters.petsEquipmentset, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PetsEquipmentsetEntryApi - axios parameter creator
 * @export
 */
export const PetsEquipmentsetEntryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates PetsEquipmentsetEntry
         * @param {ModelsPetsEquipmentsetEntry} petsEquipmentsetEntry PetsEquipmentsetEntry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPetsEquipmentsetEntry: async (petsEquipmentsetEntry: ModelsPetsEquipmentsetEntry, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'petsEquipmentsetEntry' is not null or undefined
            if (petsEquipmentsetEntry === null || petsEquipmentsetEntry === undefined) {
                throw new RequiredError('petsEquipmentsetEntry','Required parameter petsEquipmentsetEntry was null or undefined when calling createPetsEquipmentsetEntry.');
            }
            const localVarPath = `/pets_equipmentset_entry`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof petsEquipmentsetEntry !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(petsEquipmentsetEntry !== undefined ? petsEquipmentsetEntry : {})
                : (petsEquipmentsetEntry || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes PetsEquipmentsetEntry
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePetsEquipmentsetEntry: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deletePetsEquipmentsetEntry.');
            }
            const localVarPath = `/pets_equipmentset_entry/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets PetsEquipmentsetEntry
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPetsEquipmentsetEntry: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPetsEquipmentsetEntry.');
            }
            const localVarPath = `/pets_equipmentset_entry/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists PetsEquipmentsetEntries
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPetsEquipmentsetEntries: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pets_equipmentset_entries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates PetsEquipmentsetEntry
         * @param {number} id Id
         * @param {ModelsPetsEquipmentsetEntry} petsEquipmentsetEntry PetsEquipmentsetEntry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePetsEquipmentsetEntry: async (id: number, petsEquipmentsetEntry: ModelsPetsEquipmentsetEntry, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updatePetsEquipmentsetEntry.');
            }
            // verify required parameter 'petsEquipmentsetEntry' is not null or undefined
            if (petsEquipmentsetEntry === null || petsEquipmentsetEntry === undefined) {
                throw new RequiredError('petsEquipmentsetEntry','Required parameter petsEquipmentsetEntry was null or undefined when calling updatePetsEquipmentsetEntry.');
            }
            const localVarPath = `/pets_equipmentset_entry/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof petsEquipmentsetEntry !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(petsEquipmentsetEntry !== undefined ? petsEquipmentsetEntry : {})
                : (petsEquipmentsetEntry || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PetsEquipmentsetEntryApi - functional programming interface
 * @export
 */
export const PetsEquipmentsetEntryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates PetsEquipmentsetEntry
         * @param {ModelsPetsEquipmentsetEntry} petsEquipmentsetEntry PetsEquipmentsetEntry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPetsEquipmentsetEntry(petsEquipmentsetEntry: ModelsPetsEquipmentsetEntry, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsPetsEquipmentsetEntry>>> {
            const localVarAxiosArgs = await PetsEquipmentsetEntryApiAxiosParamCreator(configuration).createPetsEquipmentsetEntry(petsEquipmentsetEntry, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes PetsEquipmentsetEntry
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePetsEquipmentsetEntry(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await PetsEquipmentsetEntryApiAxiosParamCreator(configuration).deletePetsEquipmentsetEntry(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets PetsEquipmentsetEntry
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPetsEquipmentsetEntry(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsPetsEquipmentsetEntry>>> {
            const localVarAxiosArgs = await PetsEquipmentsetEntryApiAxiosParamCreator(configuration).getPetsEquipmentsetEntry(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists PetsEquipmentsetEntries
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPetsEquipmentsetEntries(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsPetsEquipmentsetEntry>>> {
            const localVarAxiosArgs = await PetsEquipmentsetEntryApiAxiosParamCreator(configuration).listPetsEquipmentsetEntries(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates PetsEquipmentsetEntry
         * @param {number} id Id
         * @param {ModelsPetsEquipmentsetEntry} petsEquipmentsetEntry PetsEquipmentsetEntry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePetsEquipmentsetEntry(id: number, petsEquipmentsetEntry: ModelsPetsEquipmentsetEntry, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsPetsEquipmentsetEntry>>> {
            const localVarAxiosArgs = await PetsEquipmentsetEntryApiAxiosParamCreator(configuration).updatePetsEquipmentsetEntry(id, petsEquipmentsetEntry, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PetsEquipmentsetEntryApi - factory interface
 * @export
 */
export const PetsEquipmentsetEntryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates PetsEquipmentsetEntry
         * @param {ModelsPetsEquipmentsetEntry} petsEquipmentsetEntry PetsEquipmentsetEntry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPetsEquipmentsetEntry(petsEquipmentsetEntry: ModelsPetsEquipmentsetEntry, options?: any): AxiosPromise<Array<ModelsPetsEquipmentsetEntry>> {
            return PetsEquipmentsetEntryApiFp(configuration).createPetsEquipmentsetEntry(petsEquipmentsetEntry, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes PetsEquipmentsetEntry
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePetsEquipmentsetEntry(id: number, options?: any): AxiosPromise<string> {
            return PetsEquipmentsetEntryApiFp(configuration).deletePetsEquipmentsetEntry(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets PetsEquipmentsetEntry
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPetsEquipmentsetEntry(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsPetsEquipmentsetEntry>> {
            return PetsEquipmentsetEntryApiFp(configuration).getPetsEquipmentsetEntry(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists PetsEquipmentsetEntries
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPetsEquipmentsetEntries(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsPetsEquipmentsetEntry>> {
            return PetsEquipmentsetEntryApiFp(configuration).listPetsEquipmentsetEntries(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates PetsEquipmentsetEntry
         * @param {number} id Id
         * @param {ModelsPetsEquipmentsetEntry} petsEquipmentsetEntry PetsEquipmentsetEntry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePetsEquipmentsetEntry(id: number, petsEquipmentsetEntry: ModelsPetsEquipmentsetEntry, options?: any): AxiosPromise<Array<ModelsPetsEquipmentsetEntry>> {
            return PetsEquipmentsetEntryApiFp(configuration).updatePetsEquipmentsetEntry(id, petsEquipmentsetEntry, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createPetsEquipmentsetEntry operation in PetsEquipmentsetEntryApi.
 * @export
 * @interface PetsEquipmentsetEntryApiCreatePetsEquipmentsetEntryRequest
 */
export interface PetsEquipmentsetEntryApiCreatePetsEquipmentsetEntryRequest {
    /**
     * PetsEquipmentsetEntry
     * @type {ModelsPetsEquipmentsetEntry}
     * @memberof PetsEquipmentsetEntryApiCreatePetsEquipmentsetEntry
     */
    readonly petsEquipmentsetEntry: ModelsPetsEquipmentsetEntry
}

/**
 * Request parameters for deletePetsEquipmentsetEntry operation in PetsEquipmentsetEntryApi.
 * @export
 * @interface PetsEquipmentsetEntryApiDeletePetsEquipmentsetEntryRequest
 */
export interface PetsEquipmentsetEntryApiDeletePetsEquipmentsetEntryRequest {
    /**
     * Id
     * @type {number}
     * @memberof PetsEquipmentsetEntryApiDeletePetsEquipmentsetEntry
     */
    readonly id: number
}

/**
 * Request parameters for getPetsEquipmentsetEntry operation in PetsEquipmentsetEntryApi.
 * @export
 * @interface PetsEquipmentsetEntryApiGetPetsEquipmentsetEntryRequest
 */
export interface PetsEquipmentsetEntryApiGetPetsEquipmentsetEntryRequest {
    /**
     * Id
     * @type {number}
     * @memberof PetsEquipmentsetEntryApiGetPetsEquipmentsetEntry
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof PetsEquipmentsetEntryApiGetPetsEquipmentsetEntry
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof PetsEquipmentsetEntryApiGetPetsEquipmentsetEntry
     */
    readonly select?: string
}

/**
 * Request parameters for listPetsEquipmentsetEntries operation in PetsEquipmentsetEntryApi.
 * @export
 * @interface PetsEquipmentsetEntryApiListPetsEquipmentsetEntriesRequest
 */
export interface PetsEquipmentsetEntryApiListPetsEquipmentsetEntriesRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof PetsEquipmentsetEntryApiListPetsEquipmentsetEntries
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof PetsEquipmentsetEntryApiListPetsEquipmentsetEntries
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof PetsEquipmentsetEntryApiListPetsEquipmentsetEntries
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof PetsEquipmentsetEntryApiListPetsEquipmentsetEntries
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof PetsEquipmentsetEntryApiListPetsEquipmentsetEntries
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof PetsEquipmentsetEntryApiListPetsEquipmentsetEntries
     */
    readonly select?: string
}

/**
 * Request parameters for updatePetsEquipmentsetEntry operation in PetsEquipmentsetEntryApi.
 * @export
 * @interface PetsEquipmentsetEntryApiUpdatePetsEquipmentsetEntryRequest
 */
export interface PetsEquipmentsetEntryApiUpdatePetsEquipmentsetEntryRequest {
    /**
     * Id
     * @type {number}
     * @memberof PetsEquipmentsetEntryApiUpdatePetsEquipmentsetEntry
     */
    readonly id: number

    /**
     * PetsEquipmentsetEntry
     * @type {ModelsPetsEquipmentsetEntry}
     * @memberof PetsEquipmentsetEntryApiUpdatePetsEquipmentsetEntry
     */
    readonly petsEquipmentsetEntry: ModelsPetsEquipmentsetEntry
}

/**
 * PetsEquipmentsetEntryApi - object-oriented interface
 * @export
 * @class PetsEquipmentsetEntryApi
 * @extends {BaseAPI}
 */
export class PetsEquipmentsetEntryApi extends BaseAPI {
    /**
     * 
     * @summary Creates PetsEquipmentsetEntry
     * @param {PetsEquipmentsetEntryApiCreatePetsEquipmentsetEntryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PetsEquipmentsetEntryApi
     */
    public createPetsEquipmentsetEntry(requestParameters: PetsEquipmentsetEntryApiCreatePetsEquipmentsetEntryRequest, options?: any) {
        return PetsEquipmentsetEntryApiFp(this.configuration).createPetsEquipmentsetEntry(requestParameters.petsEquipmentsetEntry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes PetsEquipmentsetEntry
     * @param {PetsEquipmentsetEntryApiDeletePetsEquipmentsetEntryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PetsEquipmentsetEntryApi
     */
    public deletePetsEquipmentsetEntry(requestParameters: PetsEquipmentsetEntryApiDeletePetsEquipmentsetEntryRequest, options?: any) {
        return PetsEquipmentsetEntryApiFp(this.configuration).deletePetsEquipmentsetEntry(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets PetsEquipmentsetEntry
     * @param {PetsEquipmentsetEntryApiGetPetsEquipmentsetEntryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PetsEquipmentsetEntryApi
     */
    public getPetsEquipmentsetEntry(requestParameters: PetsEquipmentsetEntryApiGetPetsEquipmentsetEntryRequest, options?: any) {
        return PetsEquipmentsetEntryApiFp(this.configuration).getPetsEquipmentsetEntry(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists PetsEquipmentsetEntries
     * @param {PetsEquipmentsetEntryApiListPetsEquipmentsetEntriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PetsEquipmentsetEntryApi
     */
    public listPetsEquipmentsetEntries(requestParameters: PetsEquipmentsetEntryApiListPetsEquipmentsetEntriesRequest = {}, options?: any) {
        return PetsEquipmentsetEntryApiFp(this.configuration).listPetsEquipmentsetEntries(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates PetsEquipmentsetEntry
     * @param {PetsEquipmentsetEntryApiUpdatePetsEquipmentsetEntryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PetsEquipmentsetEntryApi
     */
    public updatePetsEquipmentsetEntry(requestParameters: PetsEquipmentsetEntryApiUpdatePetsEquipmentsetEntryRequest, options?: any) {
        return PetsEquipmentsetEntryApiFp(this.configuration).updatePetsEquipmentsetEntry(requestParameters.id, requestParameters.petsEquipmentsetEntry, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PlayerTitlesetApi - axios parameter creator
 * @export
 */
export const PlayerTitlesetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates PlayerTitleset
         * @param {ModelsPlayerTitleset} playerTitleset PlayerTitleset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlayerTitleset: async (playerTitleset: ModelsPlayerTitleset, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'playerTitleset' is not null or undefined
            if (playerTitleset === null || playerTitleset === undefined) {
                throw new RequiredError('playerTitleset','Required parameter playerTitleset was null or undefined when calling createPlayerTitleset.');
            }
            const localVarPath = `/player_titleset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof playerTitleset !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(playerTitleset !== undefined ? playerTitleset : {})
                : (playerTitleset || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes PlayerTitleset
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlayerTitleset: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deletePlayerTitleset.');
            }
            const localVarPath = `/player_titleset/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets PlayerTitleset
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayerTitleset: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPlayerTitleset.');
            }
            const localVarPath = `/player_titleset/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists PlayerTitlesets
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlayerTitlesets: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/player_titlesets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates PlayerTitleset
         * @param {number} id Id
         * @param {ModelsPlayerTitleset} playerTitleset PlayerTitleset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlayerTitleset: async (id: number, playerTitleset: ModelsPlayerTitleset, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updatePlayerTitleset.');
            }
            // verify required parameter 'playerTitleset' is not null or undefined
            if (playerTitleset === null || playerTitleset === undefined) {
                throw new RequiredError('playerTitleset','Required parameter playerTitleset was null or undefined when calling updatePlayerTitleset.');
            }
            const localVarPath = `/player_titleset/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof playerTitleset !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(playerTitleset !== undefined ? playerTitleset : {})
                : (playerTitleset || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlayerTitlesetApi - functional programming interface
 * @export
 */
export const PlayerTitlesetApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates PlayerTitleset
         * @param {ModelsPlayerTitleset} playerTitleset PlayerTitleset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPlayerTitleset(playerTitleset: ModelsPlayerTitleset, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsPlayerTitleset>>> {
            const localVarAxiosArgs = await PlayerTitlesetApiAxiosParamCreator(configuration).createPlayerTitleset(playerTitleset, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes PlayerTitleset
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePlayerTitleset(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await PlayerTitlesetApiAxiosParamCreator(configuration).deletePlayerTitleset(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets PlayerTitleset
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlayerTitleset(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsPlayerTitleset>>> {
            const localVarAxiosArgs = await PlayerTitlesetApiAxiosParamCreator(configuration).getPlayerTitleset(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists PlayerTitlesets
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPlayerTitlesets(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsPlayerTitleset>>> {
            const localVarAxiosArgs = await PlayerTitlesetApiAxiosParamCreator(configuration).listPlayerTitlesets(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates PlayerTitleset
         * @param {number} id Id
         * @param {ModelsPlayerTitleset} playerTitleset PlayerTitleset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePlayerTitleset(id: number, playerTitleset: ModelsPlayerTitleset, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsPlayerTitleset>>> {
            const localVarAxiosArgs = await PlayerTitlesetApiAxiosParamCreator(configuration).updatePlayerTitleset(id, playerTitleset, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PlayerTitlesetApi - factory interface
 * @export
 */
export const PlayerTitlesetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates PlayerTitleset
         * @param {ModelsPlayerTitleset} playerTitleset PlayerTitleset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlayerTitleset(playerTitleset: ModelsPlayerTitleset, options?: any): AxiosPromise<Array<ModelsPlayerTitleset>> {
            return PlayerTitlesetApiFp(configuration).createPlayerTitleset(playerTitleset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes PlayerTitleset
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlayerTitleset(id: number, options?: any): AxiosPromise<string> {
            return PlayerTitlesetApiFp(configuration).deletePlayerTitleset(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets PlayerTitleset
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayerTitleset(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsPlayerTitleset>> {
            return PlayerTitlesetApiFp(configuration).getPlayerTitleset(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists PlayerTitlesets
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlayerTitlesets(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsPlayerTitleset>> {
            return PlayerTitlesetApiFp(configuration).listPlayerTitlesets(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates PlayerTitleset
         * @param {number} id Id
         * @param {ModelsPlayerTitleset} playerTitleset PlayerTitleset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlayerTitleset(id: number, playerTitleset: ModelsPlayerTitleset, options?: any): AxiosPromise<Array<ModelsPlayerTitleset>> {
            return PlayerTitlesetApiFp(configuration).updatePlayerTitleset(id, playerTitleset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createPlayerTitleset operation in PlayerTitlesetApi.
 * @export
 * @interface PlayerTitlesetApiCreatePlayerTitlesetRequest
 */
export interface PlayerTitlesetApiCreatePlayerTitlesetRequest {
    /**
     * PlayerTitleset
     * @type {ModelsPlayerTitleset}
     * @memberof PlayerTitlesetApiCreatePlayerTitleset
     */
    readonly playerTitleset: ModelsPlayerTitleset
}

/**
 * Request parameters for deletePlayerTitleset operation in PlayerTitlesetApi.
 * @export
 * @interface PlayerTitlesetApiDeletePlayerTitlesetRequest
 */
export interface PlayerTitlesetApiDeletePlayerTitlesetRequest {
    /**
     * Id
     * @type {number}
     * @memberof PlayerTitlesetApiDeletePlayerTitleset
     */
    readonly id: number
}

/**
 * Request parameters for getPlayerTitleset operation in PlayerTitlesetApi.
 * @export
 * @interface PlayerTitlesetApiGetPlayerTitlesetRequest
 */
export interface PlayerTitlesetApiGetPlayerTitlesetRequest {
    /**
     * Id
     * @type {number}
     * @memberof PlayerTitlesetApiGetPlayerTitleset
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof PlayerTitlesetApiGetPlayerTitleset
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof PlayerTitlesetApiGetPlayerTitleset
     */
    readonly select?: string
}

/**
 * Request parameters for listPlayerTitlesets operation in PlayerTitlesetApi.
 * @export
 * @interface PlayerTitlesetApiListPlayerTitlesetsRequest
 */
export interface PlayerTitlesetApiListPlayerTitlesetsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof PlayerTitlesetApiListPlayerTitlesets
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof PlayerTitlesetApiListPlayerTitlesets
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof PlayerTitlesetApiListPlayerTitlesets
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof PlayerTitlesetApiListPlayerTitlesets
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof PlayerTitlesetApiListPlayerTitlesets
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof PlayerTitlesetApiListPlayerTitlesets
     */
    readonly select?: string
}

/**
 * Request parameters for updatePlayerTitleset operation in PlayerTitlesetApi.
 * @export
 * @interface PlayerTitlesetApiUpdatePlayerTitlesetRequest
 */
export interface PlayerTitlesetApiUpdatePlayerTitlesetRequest {
    /**
     * Id
     * @type {number}
     * @memberof PlayerTitlesetApiUpdatePlayerTitleset
     */
    readonly id: number

    /**
     * PlayerTitleset
     * @type {ModelsPlayerTitleset}
     * @memberof PlayerTitlesetApiUpdatePlayerTitleset
     */
    readonly playerTitleset: ModelsPlayerTitleset
}

/**
 * PlayerTitlesetApi - object-oriented interface
 * @export
 * @class PlayerTitlesetApi
 * @extends {BaseAPI}
 */
export class PlayerTitlesetApi extends BaseAPI {
    /**
     * 
     * @summary Creates PlayerTitleset
     * @param {PlayerTitlesetApiCreatePlayerTitlesetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerTitlesetApi
     */
    public createPlayerTitleset(requestParameters: PlayerTitlesetApiCreatePlayerTitlesetRequest, options?: any) {
        return PlayerTitlesetApiFp(this.configuration).createPlayerTitleset(requestParameters.playerTitleset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes PlayerTitleset
     * @param {PlayerTitlesetApiDeletePlayerTitlesetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerTitlesetApi
     */
    public deletePlayerTitleset(requestParameters: PlayerTitlesetApiDeletePlayerTitlesetRequest, options?: any) {
        return PlayerTitlesetApiFp(this.configuration).deletePlayerTitleset(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets PlayerTitleset
     * @param {PlayerTitlesetApiGetPlayerTitlesetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerTitlesetApi
     */
    public getPlayerTitleset(requestParameters: PlayerTitlesetApiGetPlayerTitlesetRequest, options?: any) {
        return PlayerTitlesetApiFp(this.configuration).getPlayerTitleset(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists PlayerTitlesets
     * @param {PlayerTitlesetApiListPlayerTitlesetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerTitlesetApi
     */
    public listPlayerTitlesets(requestParameters: PlayerTitlesetApiListPlayerTitlesetsRequest = {}, options?: any) {
        return PlayerTitlesetApiFp(this.configuration).listPlayerTitlesets(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates PlayerTitleset
     * @param {PlayerTitlesetApiUpdatePlayerTitlesetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerTitlesetApi
     */
    public updatePlayerTitleset(requestParameters: PlayerTitlesetApiUpdatePlayerTitlesetRequest, options?: any) {
        return PlayerTitlesetApiFp(this.configuration).updatePlayerTitleset(requestParameters.id, requestParameters.playerTitleset, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QuestGlobalApi - axios parameter creator
 * @export
 */
export const QuestGlobalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates QuestGlobal
         * @param {ModelsQuestGlobal} questGlobal QuestGlobal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuestGlobal: async (questGlobal: ModelsQuestGlobal, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'questGlobal' is not null or undefined
            if (questGlobal === null || questGlobal === undefined) {
                throw new RequiredError('questGlobal','Required parameter questGlobal was null or undefined when calling createQuestGlobal.');
            }
            const localVarPath = `/quest_global`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof questGlobal !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(questGlobal !== undefined ? questGlobal : {})
                : (questGlobal || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes QuestGlobal
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuestGlobal: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteQuestGlobal.');
            }
            const localVarPath = `/quest_global/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets QuestGlobal
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestGlobal: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getQuestGlobal.');
            }
            const localVarPath = `/quest_global/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists QuestGlobals
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQuestGlobals: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/quest_globals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates QuestGlobal
         * @param {number} id Id
         * @param {ModelsQuestGlobal} questGlobal QuestGlobal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQuestGlobal: async (id: number, questGlobal: ModelsQuestGlobal, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateQuestGlobal.');
            }
            // verify required parameter 'questGlobal' is not null or undefined
            if (questGlobal === null || questGlobal === undefined) {
                throw new RequiredError('questGlobal','Required parameter questGlobal was null or undefined when calling updateQuestGlobal.');
            }
            const localVarPath = `/quest_global/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof questGlobal !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(questGlobal !== undefined ? questGlobal : {})
                : (questGlobal || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuestGlobalApi - functional programming interface
 * @export
 */
export const QuestGlobalApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates QuestGlobal
         * @param {ModelsQuestGlobal} questGlobal QuestGlobal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createQuestGlobal(questGlobal: ModelsQuestGlobal, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsQuestGlobal>>> {
            const localVarAxiosArgs = await QuestGlobalApiAxiosParamCreator(configuration).createQuestGlobal(questGlobal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes QuestGlobal
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteQuestGlobal(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await QuestGlobalApiAxiosParamCreator(configuration).deleteQuestGlobal(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets QuestGlobal
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQuestGlobal(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsQuestGlobal>>> {
            const localVarAxiosArgs = await QuestGlobalApiAxiosParamCreator(configuration).getQuestGlobal(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists QuestGlobals
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listQuestGlobals(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsQuestGlobal>>> {
            const localVarAxiosArgs = await QuestGlobalApiAxiosParamCreator(configuration).listQuestGlobals(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates QuestGlobal
         * @param {number} id Id
         * @param {ModelsQuestGlobal} questGlobal QuestGlobal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateQuestGlobal(id: number, questGlobal: ModelsQuestGlobal, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsQuestGlobal>>> {
            const localVarAxiosArgs = await QuestGlobalApiAxiosParamCreator(configuration).updateQuestGlobal(id, questGlobal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * QuestGlobalApi - factory interface
 * @export
 */
export const QuestGlobalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates QuestGlobal
         * @param {ModelsQuestGlobal} questGlobal QuestGlobal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuestGlobal(questGlobal: ModelsQuestGlobal, options?: any): AxiosPromise<Array<ModelsQuestGlobal>> {
            return QuestGlobalApiFp(configuration).createQuestGlobal(questGlobal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes QuestGlobal
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuestGlobal(id: number, options?: any): AxiosPromise<string> {
            return QuestGlobalApiFp(configuration).deleteQuestGlobal(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets QuestGlobal
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestGlobal(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsQuestGlobal>> {
            return QuestGlobalApiFp(configuration).getQuestGlobal(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists QuestGlobals
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQuestGlobals(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsQuestGlobal>> {
            return QuestGlobalApiFp(configuration).listQuestGlobals(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates QuestGlobal
         * @param {number} id Id
         * @param {ModelsQuestGlobal} questGlobal QuestGlobal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQuestGlobal(id: number, questGlobal: ModelsQuestGlobal, options?: any): AxiosPromise<Array<ModelsQuestGlobal>> {
            return QuestGlobalApiFp(configuration).updateQuestGlobal(id, questGlobal, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createQuestGlobal operation in QuestGlobalApi.
 * @export
 * @interface QuestGlobalApiCreateQuestGlobalRequest
 */
export interface QuestGlobalApiCreateQuestGlobalRequest {
    /**
     * QuestGlobal
     * @type {ModelsQuestGlobal}
     * @memberof QuestGlobalApiCreateQuestGlobal
     */
    readonly questGlobal: ModelsQuestGlobal
}

/**
 * Request parameters for deleteQuestGlobal operation in QuestGlobalApi.
 * @export
 * @interface QuestGlobalApiDeleteQuestGlobalRequest
 */
export interface QuestGlobalApiDeleteQuestGlobalRequest {
    /**
     * Id
     * @type {number}
     * @memberof QuestGlobalApiDeleteQuestGlobal
     */
    readonly id: number
}

/**
 * Request parameters for getQuestGlobal operation in QuestGlobalApi.
 * @export
 * @interface QuestGlobalApiGetQuestGlobalRequest
 */
export interface QuestGlobalApiGetQuestGlobalRequest {
    /**
     * Id
     * @type {number}
     * @memberof QuestGlobalApiGetQuestGlobal
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof QuestGlobalApiGetQuestGlobal
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof QuestGlobalApiGetQuestGlobal
     */
    readonly select?: string
}

/**
 * Request parameters for listQuestGlobals operation in QuestGlobalApi.
 * @export
 * @interface QuestGlobalApiListQuestGlobalsRequest
 */
export interface QuestGlobalApiListQuestGlobalsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof QuestGlobalApiListQuestGlobals
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof QuestGlobalApiListQuestGlobals
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof QuestGlobalApiListQuestGlobals
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof QuestGlobalApiListQuestGlobals
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof QuestGlobalApiListQuestGlobals
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof QuestGlobalApiListQuestGlobals
     */
    readonly select?: string
}

/**
 * Request parameters for updateQuestGlobal operation in QuestGlobalApi.
 * @export
 * @interface QuestGlobalApiUpdateQuestGlobalRequest
 */
export interface QuestGlobalApiUpdateQuestGlobalRequest {
    /**
     * Id
     * @type {number}
     * @memberof QuestGlobalApiUpdateQuestGlobal
     */
    readonly id: number

    /**
     * QuestGlobal
     * @type {ModelsQuestGlobal}
     * @memberof QuestGlobalApiUpdateQuestGlobal
     */
    readonly questGlobal: ModelsQuestGlobal
}

/**
 * QuestGlobalApi - object-oriented interface
 * @export
 * @class QuestGlobalApi
 * @extends {BaseAPI}
 */
export class QuestGlobalApi extends BaseAPI {
    /**
     * 
     * @summary Creates QuestGlobal
     * @param {QuestGlobalApiCreateQuestGlobalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestGlobalApi
     */
    public createQuestGlobal(requestParameters: QuestGlobalApiCreateQuestGlobalRequest, options?: any) {
        return QuestGlobalApiFp(this.configuration).createQuestGlobal(requestParameters.questGlobal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes QuestGlobal
     * @param {QuestGlobalApiDeleteQuestGlobalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestGlobalApi
     */
    public deleteQuestGlobal(requestParameters: QuestGlobalApiDeleteQuestGlobalRequest, options?: any) {
        return QuestGlobalApiFp(this.configuration).deleteQuestGlobal(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets QuestGlobal
     * @param {QuestGlobalApiGetQuestGlobalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestGlobalApi
     */
    public getQuestGlobal(requestParameters: QuestGlobalApiGetQuestGlobalRequest, options?: any) {
        return QuestGlobalApiFp(this.configuration).getQuestGlobal(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists QuestGlobals
     * @param {QuestGlobalApiListQuestGlobalsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestGlobalApi
     */
    public listQuestGlobals(requestParameters: QuestGlobalApiListQuestGlobalsRequest = {}, options?: any) {
        return QuestGlobalApiFp(this.configuration).listQuestGlobals(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates QuestGlobal
     * @param {QuestGlobalApiUpdateQuestGlobalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestGlobalApi
     */
    public updateQuestGlobal(requestParameters: QuestGlobalApiUpdateQuestGlobalRequest, options?: any) {
        return QuestGlobalApiFp(this.configuration).updateQuestGlobal(requestParameters.id, requestParameters.questGlobal, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RaidDetailApi - axios parameter creator
 * @export
 */
export const RaidDetailApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates RaidDetail
         * @param {ModelsRaidDetail} raidDetail RaidDetail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRaidDetail: async (raidDetail: ModelsRaidDetail, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'raidDetail' is not null or undefined
            if (raidDetail === null || raidDetail === undefined) {
                throw new RequiredError('raidDetail','Required parameter raidDetail was null or undefined when calling createRaidDetail.');
            }
            const localVarPath = `/raid_detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof raidDetail !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(raidDetail !== undefined ? raidDetail : {})
                : (raidDetail || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes RaidDetail
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRaidDetail: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteRaidDetail.');
            }
            const localVarPath = `/raid_detail/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets RaidDetail
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;RaidLeaders&lt;br&gt;RaidMembers
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRaidDetail: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRaidDetail.');
            }
            const localVarPath = `/raid_detail/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists RaidDetails
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;RaidLeaders&lt;br&gt;RaidMembers
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRaidDetails: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/raid_details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates RaidDetail
         * @param {number} id Id
         * @param {ModelsRaidDetail} raidDetail RaidDetail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRaidDetail: async (id: number, raidDetail: ModelsRaidDetail, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateRaidDetail.');
            }
            // verify required parameter 'raidDetail' is not null or undefined
            if (raidDetail === null || raidDetail === undefined) {
                throw new RequiredError('raidDetail','Required parameter raidDetail was null or undefined when calling updateRaidDetail.');
            }
            const localVarPath = `/raid_detail/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof raidDetail !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(raidDetail !== undefined ? raidDetail : {})
                : (raidDetail || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RaidDetailApi - functional programming interface
 * @export
 */
export const RaidDetailApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates RaidDetail
         * @param {ModelsRaidDetail} raidDetail RaidDetail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRaidDetail(raidDetail: ModelsRaidDetail, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsRaidDetail>>> {
            const localVarAxiosArgs = await RaidDetailApiAxiosParamCreator(configuration).createRaidDetail(raidDetail, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes RaidDetail
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRaidDetail(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await RaidDetailApiAxiosParamCreator(configuration).deleteRaidDetail(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets RaidDetail
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;RaidLeaders&lt;br&gt;RaidMembers
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRaidDetail(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsRaidDetail>>> {
            const localVarAxiosArgs = await RaidDetailApiAxiosParamCreator(configuration).getRaidDetail(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists RaidDetails
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;RaidLeaders&lt;br&gt;RaidMembers
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRaidDetails(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsRaidDetail>>> {
            const localVarAxiosArgs = await RaidDetailApiAxiosParamCreator(configuration).listRaidDetails(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates RaidDetail
         * @param {number} id Id
         * @param {ModelsRaidDetail} raidDetail RaidDetail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRaidDetail(id: number, raidDetail: ModelsRaidDetail, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsRaidDetail>>> {
            const localVarAxiosArgs = await RaidDetailApiAxiosParamCreator(configuration).updateRaidDetail(id, raidDetail, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RaidDetailApi - factory interface
 * @export
 */
export const RaidDetailApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates RaidDetail
         * @param {ModelsRaidDetail} raidDetail RaidDetail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRaidDetail(raidDetail: ModelsRaidDetail, options?: any): AxiosPromise<Array<ModelsRaidDetail>> {
            return RaidDetailApiFp(configuration).createRaidDetail(raidDetail, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes RaidDetail
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRaidDetail(id: number, options?: any): AxiosPromise<string> {
            return RaidDetailApiFp(configuration).deleteRaidDetail(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets RaidDetail
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;RaidLeaders&lt;br&gt;RaidMembers
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRaidDetail(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsRaidDetail>> {
            return RaidDetailApiFp(configuration).getRaidDetail(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists RaidDetails
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;RaidLeaders&lt;br&gt;RaidMembers
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRaidDetails(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsRaidDetail>> {
            return RaidDetailApiFp(configuration).listRaidDetails(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates RaidDetail
         * @param {number} id Id
         * @param {ModelsRaidDetail} raidDetail RaidDetail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRaidDetail(id: number, raidDetail: ModelsRaidDetail, options?: any): AxiosPromise<Array<ModelsRaidDetail>> {
            return RaidDetailApiFp(configuration).updateRaidDetail(id, raidDetail, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createRaidDetail operation in RaidDetailApi.
 * @export
 * @interface RaidDetailApiCreateRaidDetailRequest
 */
export interface RaidDetailApiCreateRaidDetailRequest {
    /**
     * RaidDetail
     * @type {ModelsRaidDetail}
     * @memberof RaidDetailApiCreateRaidDetail
     */
    readonly raidDetail: ModelsRaidDetail
}

/**
 * Request parameters for deleteRaidDetail operation in RaidDetailApi.
 * @export
 * @interface RaidDetailApiDeleteRaidDetailRequest
 */
export interface RaidDetailApiDeleteRaidDetailRequest {
    /**
     * Id
     * @type {number}
     * @memberof RaidDetailApiDeleteRaidDetail
     */
    readonly id: number
}

/**
 * Request parameters for getRaidDetail operation in RaidDetailApi.
 * @export
 * @interface RaidDetailApiGetRaidDetailRequest
 */
export interface RaidDetailApiGetRaidDetailRequest {
    /**
     * Id
     * @type {number}
     * @memberof RaidDetailApiGetRaidDetail
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;RaidLeaders&lt;br&gt;RaidMembers
     * @type {string}
     * @memberof RaidDetailApiGetRaidDetail
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof RaidDetailApiGetRaidDetail
     */
    readonly select?: string
}

/**
 * Request parameters for listRaidDetails operation in RaidDetailApi.
 * @export
 * @interface RaidDetailApiListRaidDetailsRequest
 */
export interface RaidDetailApiListRaidDetailsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;RaidLeaders&lt;br&gt;RaidMembers
     * @type {string}
     * @memberof RaidDetailApiListRaidDetails
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof RaidDetailApiListRaidDetails
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof RaidDetailApiListRaidDetails
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof RaidDetailApiListRaidDetails
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof RaidDetailApiListRaidDetails
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof RaidDetailApiListRaidDetails
     */
    readonly select?: string
}

/**
 * Request parameters for updateRaidDetail operation in RaidDetailApi.
 * @export
 * @interface RaidDetailApiUpdateRaidDetailRequest
 */
export interface RaidDetailApiUpdateRaidDetailRequest {
    /**
     * Id
     * @type {number}
     * @memberof RaidDetailApiUpdateRaidDetail
     */
    readonly id: number

    /**
     * RaidDetail
     * @type {ModelsRaidDetail}
     * @memberof RaidDetailApiUpdateRaidDetail
     */
    readonly raidDetail: ModelsRaidDetail
}

/**
 * RaidDetailApi - object-oriented interface
 * @export
 * @class RaidDetailApi
 * @extends {BaseAPI}
 */
export class RaidDetailApi extends BaseAPI {
    /**
     * 
     * @summary Creates RaidDetail
     * @param {RaidDetailApiCreateRaidDetailRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaidDetailApi
     */
    public createRaidDetail(requestParameters: RaidDetailApiCreateRaidDetailRequest, options?: any) {
        return RaidDetailApiFp(this.configuration).createRaidDetail(requestParameters.raidDetail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes RaidDetail
     * @param {RaidDetailApiDeleteRaidDetailRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaidDetailApi
     */
    public deleteRaidDetail(requestParameters: RaidDetailApiDeleteRaidDetailRequest, options?: any) {
        return RaidDetailApiFp(this.configuration).deleteRaidDetail(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets RaidDetail
     * @param {RaidDetailApiGetRaidDetailRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaidDetailApi
     */
    public getRaidDetail(requestParameters: RaidDetailApiGetRaidDetailRequest, options?: any) {
        return RaidDetailApiFp(this.configuration).getRaidDetail(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists RaidDetails
     * @param {RaidDetailApiListRaidDetailsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaidDetailApi
     */
    public listRaidDetails(requestParameters: RaidDetailApiListRaidDetailsRequest = {}, options?: any) {
        return RaidDetailApiFp(this.configuration).listRaidDetails(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates RaidDetail
     * @param {RaidDetailApiUpdateRaidDetailRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaidDetailApi
     */
    public updateRaidDetail(requestParameters: RaidDetailApiUpdateRaidDetailRequest, options?: any) {
        return RaidDetailApiFp(this.configuration).updateRaidDetail(requestParameters.id, requestParameters.raidDetail, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReportApi - axios parameter creator
 * @export
 */
export const ReportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Report
         * @param {ModelsReport} report Report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReport: async (report: ModelsReport, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'report' is not null or undefined
            if (report === null || report === undefined) {
                throw new RequiredError('report','Required parameter report was null or undefined when calling createReport.');
            }
            const localVarPath = `/report`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof report !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(report !== undefined ? report : {})
                : (report || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes Report
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReport: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteReport.');
            }
            const localVarPath = `/report/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Report
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReport: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getReport.');
            }
            const localVarPath = `/report/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists Reports
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReports: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates Report
         * @param {number} id Id
         * @param {ModelsReport} report Report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReport: async (id: number, report: ModelsReport, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateReport.');
            }
            // verify required parameter 'report' is not null or undefined
            if (report === null || report === undefined) {
                throw new RequiredError('report','Required parameter report was null or undefined when calling updateReport.');
            }
            const localVarPath = `/report/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof report !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(report !== undefined ? report : {})
                : (report || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportApi - functional programming interface
 * @export
 */
export const ReportApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Report
         * @param {ModelsReport} report Report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createReport(report: ModelsReport, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsReport>>> {
            const localVarAxiosArgs = await ReportApiAxiosParamCreator(configuration).createReport(report, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes Report
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteReport(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await ReportApiAxiosParamCreator(configuration).deleteReport(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Report
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReport(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsReport>>> {
            const localVarAxiosArgs = await ReportApiAxiosParamCreator(configuration).getReport(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists Reports
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listReports(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsReport>>> {
            const localVarAxiosArgs = await ReportApiAxiosParamCreator(configuration).listReports(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates Report
         * @param {number} id Id
         * @param {ModelsReport} report Report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateReport(id: number, report: ModelsReport, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsReport>>> {
            const localVarAxiosArgs = await ReportApiAxiosParamCreator(configuration).updateReport(id, report, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ReportApi - factory interface
 * @export
 */
export const ReportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates Report
         * @param {ModelsReport} report Report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReport(report: ModelsReport, options?: any): AxiosPromise<Array<ModelsReport>> {
            return ReportApiFp(configuration).createReport(report, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes Report
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReport(id: number, options?: any): AxiosPromise<string> {
            return ReportApiFp(configuration).deleteReport(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Report
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReport(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsReport>> {
            return ReportApiFp(configuration).getReport(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists Reports
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReports(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsReport>> {
            return ReportApiFp(configuration).listReports(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates Report
         * @param {number} id Id
         * @param {ModelsReport} report Report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReport(id: number, report: ModelsReport, options?: any): AxiosPromise<Array<ModelsReport>> {
            return ReportApiFp(configuration).updateReport(id, report, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createReport operation in ReportApi.
 * @export
 * @interface ReportApiCreateReportRequest
 */
export interface ReportApiCreateReportRequest {
    /**
     * Report
     * @type {ModelsReport}
     * @memberof ReportApiCreateReport
     */
    readonly report: ModelsReport
}

/**
 * Request parameters for deleteReport operation in ReportApi.
 * @export
 * @interface ReportApiDeleteReportRequest
 */
export interface ReportApiDeleteReportRequest {
    /**
     * Id
     * @type {number}
     * @memberof ReportApiDeleteReport
     */
    readonly id: number
}

/**
 * Request parameters for getReport operation in ReportApi.
 * @export
 * @interface ReportApiGetReportRequest
 */
export interface ReportApiGetReportRequest {
    /**
     * Id
     * @type {number}
     * @memberof ReportApiGetReport
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof ReportApiGetReport
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof ReportApiGetReport
     */
    readonly select?: string
}

/**
 * Request parameters for listReports operation in ReportApi.
 * @export
 * @interface ReportApiListReportsRequest
 */
export interface ReportApiListReportsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof ReportApiListReports
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof ReportApiListReports
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof ReportApiListReports
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof ReportApiListReports
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof ReportApiListReports
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof ReportApiListReports
     */
    readonly select?: string
}

/**
 * Request parameters for updateReport operation in ReportApi.
 * @export
 * @interface ReportApiUpdateReportRequest
 */
export interface ReportApiUpdateReportRequest {
    /**
     * Id
     * @type {number}
     * @memberof ReportApiUpdateReport
     */
    readonly id: number

    /**
     * Report
     * @type {ModelsReport}
     * @memberof ReportApiUpdateReport
     */
    readonly report: ModelsReport
}

/**
 * ReportApi - object-oriented interface
 * @export
 * @class ReportApi
 * @extends {BaseAPI}
 */
export class ReportApi extends BaseAPI {
    /**
     * 
     * @summary Creates Report
     * @param {ReportApiCreateReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public createReport(requestParameters: ReportApiCreateReportRequest, options?: any) {
        return ReportApiFp(this.configuration).createReport(requestParameters.report, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes Report
     * @param {ReportApiDeleteReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public deleteReport(requestParameters: ReportApiDeleteReportRequest, options?: any) {
        return ReportApiFp(this.configuration).deleteReport(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Report
     * @param {ReportApiGetReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public getReport(requestParameters: ReportApiGetReportRequest, options?: any) {
        return ReportApiFp(this.configuration).getReport(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists Reports
     * @param {ReportApiListReportsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public listReports(requestParameters: ReportApiListReportsRequest = {}, options?: any) {
        return ReportApiFp(this.configuration).listReports(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates Report
     * @param {ReportApiUpdateReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public updateReport(requestParameters: ReportApiUpdateReportRequest, options?: any) {
        return ReportApiFp(this.configuration).updateReport(requestParameters.id, requestParameters.report, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RespawnTimeApi - axios parameter creator
 * @export
 */
export const RespawnTimeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates RespawnTime
         * @param {ModelsRespawnTime} respawnTime RespawnTime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRespawnTime: async (respawnTime: ModelsRespawnTime, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'respawnTime' is not null or undefined
            if (respawnTime === null || respawnTime === undefined) {
                throw new RequiredError('respawnTime','Required parameter respawnTime was null or undefined when calling createRespawnTime.');
            }
            const localVarPath = `/respawn_time`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof respawnTime !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(respawnTime !== undefined ? respawnTime : {})
                : (respawnTime || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes RespawnTime
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRespawnTime: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteRespawnTime.');
            }
            const localVarPath = `/respawn_time/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets RespawnTime
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRespawnTime: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRespawnTime.');
            }
            const localVarPath = `/respawn_time/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists RespawnTimes
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRespawnTimes: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/respawn_times`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates RespawnTime
         * @param {number} id Id
         * @param {ModelsRespawnTime} respawnTime RespawnTime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRespawnTime: async (id: number, respawnTime: ModelsRespawnTime, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateRespawnTime.');
            }
            // verify required parameter 'respawnTime' is not null or undefined
            if (respawnTime === null || respawnTime === undefined) {
                throw new RequiredError('respawnTime','Required parameter respawnTime was null or undefined when calling updateRespawnTime.');
            }
            const localVarPath = `/respawn_time/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof respawnTime !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(respawnTime !== undefined ? respawnTime : {})
                : (respawnTime || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RespawnTimeApi - functional programming interface
 * @export
 */
export const RespawnTimeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates RespawnTime
         * @param {ModelsRespawnTime} respawnTime RespawnTime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRespawnTime(respawnTime: ModelsRespawnTime, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsRespawnTime>>> {
            const localVarAxiosArgs = await RespawnTimeApiAxiosParamCreator(configuration).createRespawnTime(respawnTime, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes RespawnTime
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRespawnTime(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await RespawnTimeApiAxiosParamCreator(configuration).deleteRespawnTime(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets RespawnTime
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRespawnTime(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsRespawnTime>>> {
            const localVarAxiosArgs = await RespawnTimeApiAxiosParamCreator(configuration).getRespawnTime(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists RespawnTimes
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRespawnTimes(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsRespawnTime>>> {
            const localVarAxiosArgs = await RespawnTimeApiAxiosParamCreator(configuration).listRespawnTimes(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates RespawnTime
         * @param {number} id Id
         * @param {ModelsRespawnTime} respawnTime RespawnTime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRespawnTime(id: number, respawnTime: ModelsRespawnTime, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsRespawnTime>>> {
            const localVarAxiosArgs = await RespawnTimeApiAxiosParamCreator(configuration).updateRespawnTime(id, respawnTime, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RespawnTimeApi - factory interface
 * @export
 */
export const RespawnTimeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates RespawnTime
         * @param {ModelsRespawnTime} respawnTime RespawnTime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRespawnTime(respawnTime: ModelsRespawnTime, options?: any): AxiosPromise<Array<ModelsRespawnTime>> {
            return RespawnTimeApiFp(configuration).createRespawnTime(respawnTime, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes RespawnTime
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRespawnTime(id: number, options?: any): AxiosPromise<string> {
            return RespawnTimeApiFp(configuration).deleteRespawnTime(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets RespawnTime
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRespawnTime(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsRespawnTime>> {
            return RespawnTimeApiFp(configuration).getRespawnTime(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists RespawnTimes
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRespawnTimes(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsRespawnTime>> {
            return RespawnTimeApiFp(configuration).listRespawnTimes(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates RespawnTime
         * @param {number} id Id
         * @param {ModelsRespawnTime} respawnTime RespawnTime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRespawnTime(id: number, respawnTime: ModelsRespawnTime, options?: any): AxiosPromise<Array<ModelsRespawnTime>> {
            return RespawnTimeApiFp(configuration).updateRespawnTime(id, respawnTime, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createRespawnTime operation in RespawnTimeApi.
 * @export
 * @interface RespawnTimeApiCreateRespawnTimeRequest
 */
export interface RespawnTimeApiCreateRespawnTimeRequest {
    /**
     * RespawnTime
     * @type {ModelsRespawnTime}
     * @memberof RespawnTimeApiCreateRespawnTime
     */
    readonly respawnTime: ModelsRespawnTime
}

/**
 * Request parameters for deleteRespawnTime operation in RespawnTimeApi.
 * @export
 * @interface RespawnTimeApiDeleteRespawnTimeRequest
 */
export interface RespawnTimeApiDeleteRespawnTimeRequest {
    /**
     * Id
     * @type {number}
     * @memberof RespawnTimeApiDeleteRespawnTime
     */
    readonly id: number
}

/**
 * Request parameters for getRespawnTime operation in RespawnTimeApi.
 * @export
 * @interface RespawnTimeApiGetRespawnTimeRequest
 */
export interface RespawnTimeApiGetRespawnTimeRequest {
    /**
     * Id
     * @type {number}
     * @memberof RespawnTimeApiGetRespawnTime
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof RespawnTimeApiGetRespawnTime
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof RespawnTimeApiGetRespawnTime
     */
    readonly select?: string
}

/**
 * Request parameters for listRespawnTimes operation in RespawnTimeApi.
 * @export
 * @interface RespawnTimeApiListRespawnTimesRequest
 */
export interface RespawnTimeApiListRespawnTimesRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof RespawnTimeApiListRespawnTimes
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof RespawnTimeApiListRespawnTimes
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof RespawnTimeApiListRespawnTimes
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof RespawnTimeApiListRespawnTimes
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof RespawnTimeApiListRespawnTimes
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof RespawnTimeApiListRespawnTimes
     */
    readonly select?: string
}

/**
 * Request parameters for updateRespawnTime operation in RespawnTimeApi.
 * @export
 * @interface RespawnTimeApiUpdateRespawnTimeRequest
 */
export interface RespawnTimeApiUpdateRespawnTimeRequest {
    /**
     * Id
     * @type {number}
     * @memberof RespawnTimeApiUpdateRespawnTime
     */
    readonly id: number

    /**
     * RespawnTime
     * @type {ModelsRespawnTime}
     * @memberof RespawnTimeApiUpdateRespawnTime
     */
    readonly respawnTime: ModelsRespawnTime
}

/**
 * RespawnTimeApi - object-oriented interface
 * @export
 * @class RespawnTimeApi
 * @extends {BaseAPI}
 */
export class RespawnTimeApi extends BaseAPI {
    /**
     * 
     * @summary Creates RespawnTime
     * @param {RespawnTimeApiCreateRespawnTimeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RespawnTimeApi
     */
    public createRespawnTime(requestParameters: RespawnTimeApiCreateRespawnTimeRequest, options?: any) {
        return RespawnTimeApiFp(this.configuration).createRespawnTime(requestParameters.respawnTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes RespawnTime
     * @param {RespawnTimeApiDeleteRespawnTimeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RespawnTimeApi
     */
    public deleteRespawnTime(requestParameters: RespawnTimeApiDeleteRespawnTimeRequest, options?: any) {
        return RespawnTimeApiFp(this.configuration).deleteRespawnTime(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets RespawnTime
     * @param {RespawnTimeApiGetRespawnTimeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RespawnTimeApi
     */
    public getRespawnTime(requestParameters: RespawnTimeApiGetRespawnTimeRequest, options?: any) {
        return RespawnTimeApiFp(this.configuration).getRespawnTime(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists RespawnTimes
     * @param {RespawnTimeApiListRespawnTimesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RespawnTimeApi
     */
    public listRespawnTimes(requestParameters: RespawnTimeApiListRespawnTimesRequest = {}, options?: any) {
        return RespawnTimeApiFp(this.configuration).listRespawnTimes(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates RespawnTime
     * @param {RespawnTimeApiUpdateRespawnTimeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RespawnTimeApi
     */
    public updateRespawnTime(requestParameters: RespawnTimeApiUpdateRespawnTimeRequest, options?: any) {
        return RespawnTimeApiFp(this.configuration).updateRespawnTime(requestParameters.id, requestParameters.respawnTime, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SaylinkApi - axios parameter creator
 * @export
 */
export const SaylinkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Saylink
         * @param {ModelsSaylink} saylink Saylink
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSaylink: async (saylink: ModelsSaylink, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'saylink' is not null or undefined
            if (saylink === null || saylink === undefined) {
                throw new RequiredError('saylink','Required parameter saylink was null or undefined when calling createSaylink.');
            }
            const localVarPath = `/saylink`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof saylink !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(saylink !== undefined ? saylink : {})
                : (saylink || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes Saylink
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSaylink: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteSaylink.');
            }
            const localVarPath = `/saylink/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Saylink
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSaylink: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSaylink.');
            }
            const localVarPath = `/saylink/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists Saylinks
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSaylinks: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/saylinks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates Saylink
         * @param {number} id Id
         * @param {ModelsSaylink} saylink Saylink
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSaylink: async (id: number, saylink: ModelsSaylink, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateSaylink.');
            }
            // verify required parameter 'saylink' is not null or undefined
            if (saylink === null || saylink === undefined) {
                throw new RequiredError('saylink','Required parameter saylink was null or undefined when calling updateSaylink.');
            }
            const localVarPath = `/saylink/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof saylink !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(saylink !== undefined ? saylink : {})
                : (saylink || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SaylinkApi - functional programming interface
 * @export
 */
export const SaylinkApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Saylink
         * @param {ModelsSaylink} saylink Saylink
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSaylink(saylink: ModelsSaylink, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsSaylink>>> {
            const localVarAxiosArgs = await SaylinkApiAxiosParamCreator(configuration).createSaylink(saylink, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes Saylink
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSaylink(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await SaylinkApiAxiosParamCreator(configuration).deleteSaylink(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Saylink
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSaylink(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsSaylink>>> {
            const localVarAxiosArgs = await SaylinkApiAxiosParamCreator(configuration).getSaylink(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists Saylinks
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSaylinks(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsSaylink>>> {
            const localVarAxiosArgs = await SaylinkApiAxiosParamCreator(configuration).listSaylinks(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates Saylink
         * @param {number} id Id
         * @param {ModelsSaylink} saylink Saylink
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSaylink(id: number, saylink: ModelsSaylink, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsSaylink>>> {
            const localVarAxiosArgs = await SaylinkApiAxiosParamCreator(configuration).updateSaylink(id, saylink, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SaylinkApi - factory interface
 * @export
 */
export const SaylinkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates Saylink
         * @param {ModelsSaylink} saylink Saylink
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSaylink(saylink: ModelsSaylink, options?: any): AxiosPromise<Array<ModelsSaylink>> {
            return SaylinkApiFp(configuration).createSaylink(saylink, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes Saylink
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSaylink(id: number, options?: any): AxiosPromise<string> {
            return SaylinkApiFp(configuration).deleteSaylink(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Saylink
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSaylink(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsSaylink>> {
            return SaylinkApiFp(configuration).getSaylink(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists Saylinks
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSaylinks(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsSaylink>> {
            return SaylinkApiFp(configuration).listSaylinks(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates Saylink
         * @param {number} id Id
         * @param {ModelsSaylink} saylink Saylink
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSaylink(id: number, saylink: ModelsSaylink, options?: any): AxiosPromise<Array<ModelsSaylink>> {
            return SaylinkApiFp(configuration).updateSaylink(id, saylink, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createSaylink operation in SaylinkApi.
 * @export
 * @interface SaylinkApiCreateSaylinkRequest
 */
export interface SaylinkApiCreateSaylinkRequest {
    /**
     * Saylink
     * @type {ModelsSaylink}
     * @memberof SaylinkApiCreateSaylink
     */
    readonly saylink: ModelsSaylink
}

/**
 * Request parameters for deleteSaylink operation in SaylinkApi.
 * @export
 * @interface SaylinkApiDeleteSaylinkRequest
 */
export interface SaylinkApiDeleteSaylinkRequest {
    /**
     * Id
     * @type {number}
     * @memberof SaylinkApiDeleteSaylink
     */
    readonly id: number
}

/**
 * Request parameters for getSaylink operation in SaylinkApi.
 * @export
 * @interface SaylinkApiGetSaylinkRequest
 */
export interface SaylinkApiGetSaylinkRequest {
    /**
     * Id
     * @type {number}
     * @memberof SaylinkApiGetSaylink
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof SaylinkApiGetSaylink
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof SaylinkApiGetSaylink
     */
    readonly select?: string
}

/**
 * Request parameters for listSaylinks operation in SaylinkApi.
 * @export
 * @interface SaylinkApiListSaylinksRequest
 */
export interface SaylinkApiListSaylinksRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof SaylinkApiListSaylinks
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof SaylinkApiListSaylinks
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof SaylinkApiListSaylinks
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof SaylinkApiListSaylinks
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof SaylinkApiListSaylinks
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof SaylinkApiListSaylinks
     */
    readonly select?: string
}

/**
 * Request parameters for updateSaylink operation in SaylinkApi.
 * @export
 * @interface SaylinkApiUpdateSaylinkRequest
 */
export interface SaylinkApiUpdateSaylinkRequest {
    /**
     * Id
     * @type {number}
     * @memberof SaylinkApiUpdateSaylink
     */
    readonly id: number

    /**
     * Saylink
     * @type {ModelsSaylink}
     * @memberof SaylinkApiUpdateSaylink
     */
    readonly saylink: ModelsSaylink
}

/**
 * SaylinkApi - object-oriented interface
 * @export
 * @class SaylinkApi
 * @extends {BaseAPI}
 */
export class SaylinkApi extends BaseAPI {
    /**
     * 
     * @summary Creates Saylink
     * @param {SaylinkApiCreateSaylinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SaylinkApi
     */
    public createSaylink(requestParameters: SaylinkApiCreateSaylinkRequest, options?: any) {
        return SaylinkApiFp(this.configuration).createSaylink(requestParameters.saylink, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes Saylink
     * @param {SaylinkApiDeleteSaylinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SaylinkApi
     */
    public deleteSaylink(requestParameters: SaylinkApiDeleteSaylinkRequest, options?: any) {
        return SaylinkApiFp(this.configuration).deleteSaylink(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Saylink
     * @param {SaylinkApiGetSaylinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SaylinkApi
     */
    public getSaylink(requestParameters: SaylinkApiGetSaylinkRequest, options?: any) {
        return SaylinkApiFp(this.configuration).getSaylink(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists Saylinks
     * @param {SaylinkApiListSaylinksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SaylinkApi
     */
    public listSaylinks(requestParameters: SaylinkApiListSaylinksRequest = {}, options?: any) {
        return SaylinkApiFp(this.configuration).listSaylinks(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates Saylink
     * @param {SaylinkApiUpdateSaylinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SaylinkApi
     */
    public updateSaylink(requestParameters: SaylinkApiUpdateSaylinkRequest, options?: any) {
        return SaylinkApiFp(this.configuration).updateSaylink(requestParameters.id, requestParameters.saylink, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Spawn2Api - axios parameter creator
 * @export
 */
export const Spawn2ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Spawn2
         * @param {ModelsSpawn2} spawn2 Spawn2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSpawn2: async (spawn2: ModelsSpawn2, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'spawn2' is not null or undefined
            if (spawn2 === null || spawn2 === undefined) {
                throw new RequiredError('spawn2','Required parameter spawn2 was null or undefined when calling createSpawn2.');
            }
            const localVarPath = `/spawn_2`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof spawn2 !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(spawn2 !== undefined ? spawn2 : {})
                : (spawn2 || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes Spawn2
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpawn2: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteSpawn2.');
            }
            const localVarPath = `/spawn_2/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Spawn2
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpawn2: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSpawn2.');
            }
            const localVarPath = `/spawn_2/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists Spawn2s
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpawn2s: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/spawn_2s`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates Spawn2
         * @param {number} id Id
         * @param {ModelsSpawn2} spawn2 Spawn2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSpawn2: async (id: number, spawn2: ModelsSpawn2, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateSpawn2.');
            }
            // verify required parameter 'spawn2' is not null or undefined
            if (spawn2 === null || spawn2 === undefined) {
                throw new RequiredError('spawn2','Required parameter spawn2 was null or undefined when calling updateSpawn2.');
            }
            const localVarPath = `/spawn_2/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof spawn2 !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(spawn2 !== undefined ? spawn2 : {})
                : (spawn2 || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Spawn2Api - functional programming interface
 * @export
 */
export const Spawn2ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Spawn2
         * @param {ModelsSpawn2} spawn2 Spawn2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSpawn2(spawn2: ModelsSpawn2, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsSpawn2>>> {
            const localVarAxiosArgs = await Spawn2ApiAxiosParamCreator(configuration).createSpawn2(spawn2, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes Spawn2
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSpawn2(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await Spawn2ApiAxiosParamCreator(configuration).deleteSpawn2(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Spawn2
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSpawn2(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsSpawn2>>> {
            const localVarAxiosArgs = await Spawn2ApiAxiosParamCreator(configuration).getSpawn2(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists Spawn2s
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSpawn2s(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsSpawn2>>> {
            const localVarAxiosArgs = await Spawn2ApiAxiosParamCreator(configuration).listSpawn2s(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates Spawn2
         * @param {number} id Id
         * @param {ModelsSpawn2} spawn2 Spawn2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSpawn2(id: number, spawn2: ModelsSpawn2, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsSpawn2>>> {
            const localVarAxiosArgs = await Spawn2ApiAxiosParamCreator(configuration).updateSpawn2(id, spawn2, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * Spawn2Api - factory interface
 * @export
 */
export const Spawn2ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates Spawn2
         * @param {ModelsSpawn2} spawn2 Spawn2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSpawn2(spawn2: ModelsSpawn2, options?: any): AxiosPromise<Array<ModelsSpawn2>> {
            return Spawn2ApiFp(configuration).createSpawn2(spawn2, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes Spawn2
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpawn2(id: number, options?: any): AxiosPromise<string> {
            return Spawn2ApiFp(configuration).deleteSpawn2(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Spawn2
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpawn2(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsSpawn2>> {
            return Spawn2ApiFp(configuration).getSpawn2(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists Spawn2s
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpawn2s(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsSpawn2>> {
            return Spawn2ApiFp(configuration).listSpawn2s(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates Spawn2
         * @param {number} id Id
         * @param {ModelsSpawn2} spawn2 Spawn2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSpawn2(id: number, spawn2: ModelsSpawn2, options?: any): AxiosPromise<Array<ModelsSpawn2>> {
            return Spawn2ApiFp(configuration).updateSpawn2(id, spawn2, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createSpawn2 operation in Spawn2Api.
 * @export
 * @interface Spawn2ApiCreateSpawn2Request
 */
export interface Spawn2ApiCreateSpawn2Request {
    /**
     * Spawn2
     * @type {ModelsSpawn2}
     * @memberof Spawn2ApiCreateSpawn2
     */
    readonly spawn2: ModelsSpawn2
}

/**
 * Request parameters for deleteSpawn2 operation in Spawn2Api.
 * @export
 * @interface Spawn2ApiDeleteSpawn2Request
 */
export interface Spawn2ApiDeleteSpawn2Request {
    /**
     * Id
     * @type {number}
     * @memberof Spawn2ApiDeleteSpawn2
     */
    readonly id: number
}

/**
 * Request parameters for getSpawn2 operation in Spawn2Api.
 * @export
 * @interface Spawn2ApiGetSpawn2Request
 */
export interface Spawn2ApiGetSpawn2Request {
    /**
     * Id
     * @type {number}
     * @memberof Spawn2ApiGetSpawn2
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof Spawn2ApiGetSpawn2
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof Spawn2ApiGetSpawn2
     */
    readonly select?: string
}

/**
 * Request parameters for listSpawn2s operation in Spawn2Api.
 * @export
 * @interface Spawn2ApiListSpawn2sRequest
 */
export interface Spawn2ApiListSpawn2sRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof Spawn2ApiListSpawn2s
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof Spawn2ApiListSpawn2s
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof Spawn2ApiListSpawn2s
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof Spawn2ApiListSpawn2s
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof Spawn2ApiListSpawn2s
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof Spawn2ApiListSpawn2s
     */
    readonly select?: string
}

/**
 * Request parameters for updateSpawn2 operation in Spawn2Api.
 * @export
 * @interface Spawn2ApiUpdateSpawn2Request
 */
export interface Spawn2ApiUpdateSpawn2Request {
    /**
     * Id
     * @type {number}
     * @memberof Spawn2ApiUpdateSpawn2
     */
    readonly id: number

    /**
     * Spawn2
     * @type {ModelsSpawn2}
     * @memberof Spawn2ApiUpdateSpawn2
     */
    readonly spawn2: ModelsSpawn2
}

/**
 * Spawn2Api - object-oriented interface
 * @export
 * @class Spawn2Api
 * @extends {BaseAPI}
 */
export class Spawn2Api extends BaseAPI {
    /**
     * 
     * @summary Creates Spawn2
     * @param {Spawn2ApiCreateSpawn2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Spawn2Api
     */
    public createSpawn2(requestParameters: Spawn2ApiCreateSpawn2Request, options?: any) {
        return Spawn2ApiFp(this.configuration).createSpawn2(requestParameters.spawn2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes Spawn2
     * @param {Spawn2ApiDeleteSpawn2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Spawn2Api
     */
    public deleteSpawn2(requestParameters: Spawn2ApiDeleteSpawn2Request, options?: any) {
        return Spawn2ApiFp(this.configuration).deleteSpawn2(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Spawn2
     * @param {Spawn2ApiGetSpawn2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Spawn2Api
     */
    public getSpawn2(requestParameters: Spawn2ApiGetSpawn2Request, options?: any) {
        return Spawn2ApiFp(this.configuration).getSpawn2(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists Spawn2s
     * @param {Spawn2ApiListSpawn2sRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Spawn2Api
     */
    public listSpawn2s(requestParameters: Spawn2ApiListSpawn2sRequest = {}, options?: any) {
        return Spawn2ApiFp(this.configuration).listSpawn2s(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates Spawn2
     * @param {Spawn2ApiUpdateSpawn2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Spawn2Api
     */
    public updateSpawn2(requestParameters: Spawn2ApiUpdateSpawn2Request, options?: any) {
        return Spawn2ApiFp(this.configuration).updateSpawn2(requestParameters.id, requestParameters.spawn2, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SpawnConditionApi - axios parameter creator
 * @export
 */
export const SpawnConditionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates SpawnCondition
         * @param {ModelsSpawnCondition} spawnCondition SpawnCondition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSpawnCondition: async (spawnCondition: ModelsSpawnCondition, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'spawnCondition' is not null or undefined
            if (spawnCondition === null || spawnCondition === undefined) {
                throw new RequiredError('spawnCondition','Required parameter spawnCondition was null or undefined when calling createSpawnCondition.');
            }
            const localVarPath = `/spawn_condition`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof spawnCondition !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(spawnCondition !== undefined ? spawnCondition : {})
                : (spawnCondition || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes SpawnCondition
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpawnCondition: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteSpawnCondition.');
            }
            const localVarPath = `/spawn_condition/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets SpawnCondition
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpawnCondition: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSpawnCondition.');
            }
            const localVarPath = `/spawn_condition/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists SpawnConditions
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpawnConditions: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/spawn_conditions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates SpawnCondition
         * @param {number} id Id
         * @param {ModelsSpawnCondition} spawnCondition SpawnCondition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSpawnCondition: async (id: number, spawnCondition: ModelsSpawnCondition, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateSpawnCondition.');
            }
            // verify required parameter 'spawnCondition' is not null or undefined
            if (spawnCondition === null || spawnCondition === undefined) {
                throw new RequiredError('spawnCondition','Required parameter spawnCondition was null or undefined when calling updateSpawnCondition.');
            }
            const localVarPath = `/spawn_condition/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof spawnCondition !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(spawnCondition !== undefined ? spawnCondition : {})
                : (spawnCondition || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SpawnConditionApi - functional programming interface
 * @export
 */
export const SpawnConditionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates SpawnCondition
         * @param {ModelsSpawnCondition} spawnCondition SpawnCondition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSpawnCondition(spawnCondition: ModelsSpawnCondition, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsSpawnCondition>>> {
            const localVarAxiosArgs = await SpawnConditionApiAxiosParamCreator(configuration).createSpawnCondition(spawnCondition, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes SpawnCondition
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSpawnCondition(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await SpawnConditionApiAxiosParamCreator(configuration).deleteSpawnCondition(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets SpawnCondition
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSpawnCondition(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsSpawnCondition>>> {
            const localVarAxiosArgs = await SpawnConditionApiAxiosParamCreator(configuration).getSpawnCondition(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists SpawnConditions
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSpawnConditions(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsSpawnCondition>>> {
            const localVarAxiosArgs = await SpawnConditionApiAxiosParamCreator(configuration).listSpawnConditions(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates SpawnCondition
         * @param {number} id Id
         * @param {ModelsSpawnCondition} spawnCondition SpawnCondition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSpawnCondition(id: number, spawnCondition: ModelsSpawnCondition, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsSpawnCondition>>> {
            const localVarAxiosArgs = await SpawnConditionApiAxiosParamCreator(configuration).updateSpawnCondition(id, spawnCondition, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SpawnConditionApi - factory interface
 * @export
 */
export const SpawnConditionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates SpawnCondition
         * @param {ModelsSpawnCondition} spawnCondition SpawnCondition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSpawnCondition(spawnCondition: ModelsSpawnCondition, options?: any): AxiosPromise<Array<ModelsSpawnCondition>> {
            return SpawnConditionApiFp(configuration).createSpawnCondition(spawnCondition, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes SpawnCondition
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpawnCondition(id: number, options?: any): AxiosPromise<string> {
            return SpawnConditionApiFp(configuration).deleteSpawnCondition(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets SpawnCondition
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpawnCondition(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsSpawnCondition>> {
            return SpawnConditionApiFp(configuration).getSpawnCondition(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists SpawnConditions
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpawnConditions(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsSpawnCondition>> {
            return SpawnConditionApiFp(configuration).listSpawnConditions(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates SpawnCondition
         * @param {number} id Id
         * @param {ModelsSpawnCondition} spawnCondition SpawnCondition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSpawnCondition(id: number, spawnCondition: ModelsSpawnCondition, options?: any): AxiosPromise<Array<ModelsSpawnCondition>> {
            return SpawnConditionApiFp(configuration).updateSpawnCondition(id, spawnCondition, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createSpawnCondition operation in SpawnConditionApi.
 * @export
 * @interface SpawnConditionApiCreateSpawnConditionRequest
 */
export interface SpawnConditionApiCreateSpawnConditionRequest {
    /**
     * SpawnCondition
     * @type {ModelsSpawnCondition}
     * @memberof SpawnConditionApiCreateSpawnCondition
     */
    readonly spawnCondition: ModelsSpawnCondition
}

/**
 * Request parameters for deleteSpawnCondition operation in SpawnConditionApi.
 * @export
 * @interface SpawnConditionApiDeleteSpawnConditionRequest
 */
export interface SpawnConditionApiDeleteSpawnConditionRequest {
    /**
     * Id
     * @type {number}
     * @memberof SpawnConditionApiDeleteSpawnCondition
     */
    readonly id: number
}

/**
 * Request parameters for getSpawnCondition operation in SpawnConditionApi.
 * @export
 * @interface SpawnConditionApiGetSpawnConditionRequest
 */
export interface SpawnConditionApiGetSpawnConditionRequest {
    /**
     * Id
     * @type {number}
     * @memberof SpawnConditionApiGetSpawnCondition
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof SpawnConditionApiGetSpawnCondition
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof SpawnConditionApiGetSpawnCondition
     */
    readonly select?: string
}

/**
 * Request parameters for listSpawnConditions operation in SpawnConditionApi.
 * @export
 * @interface SpawnConditionApiListSpawnConditionsRequest
 */
export interface SpawnConditionApiListSpawnConditionsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof SpawnConditionApiListSpawnConditions
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof SpawnConditionApiListSpawnConditions
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof SpawnConditionApiListSpawnConditions
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof SpawnConditionApiListSpawnConditions
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof SpawnConditionApiListSpawnConditions
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof SpawnConditionApiListSpawnConditions
     */
    readonly select?: string
}

/**
 * Request parameters for updateSpawnCondition operation in SpawnConditionApi.
 * @export
 * @interface SpawnConditionApiUpdateSpawnConditionRequest
 */
export interface SpawnConditionApiUpdateSpawnConditionRequest {
    /**
     * Id
     * @type {number}
     * @memberof SpawnConditionApiUpdateSpawnCondition
     */
    readonly id: number

    /**
     * SpawnCondition
     * @type {ModelsSpawnCondition}
     * @memberof SpawnConditionApiUpdateSpawnCondition
     */
    readonly spawnCondition: ModelsSpawnCondition
}

/**
 * SpawnConditionApi - object-oriented interface
 * @export
 * @class SpawnConditionApi
 * @extends {BaseAPI}
 */
export class SpawnConditionApi extends BaseAPI {
    /**
     * 
     * @summary Creates SpawnCondition
     * @param {SpawnConditionApiCreateSpawnConditionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpawnConditionApi
     */
    public createSpawnCondition(requestParameters: SpawnConditionApiCreateSpawnConditionRequest, options?: any) {
        return SpawnConditionApiFp(this.configuration).createSpawnCondition(requestParameters.spawnCondition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes SpawnCondition
     * @param {SpawnConditionApiDeleteSpawnConditionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpawnConditionApi
     */
    public deleteSpawnCondition(requestParameters: SpawnConditionApiDeleteSpawnConditionRequest, options?: any) {
        return SpawnConditionApiFp(this.configuration).deleteSpawnCondition(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets SpawnCondition
     * @param {SpawnConditionApiGetSpawnConditionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpawnConditionApi
     */
    public getSpawnCondition(requestParameters: SpawnConditionApiGetSpawnConditionRequest, options?: any) {
        return SpawnConditionApiFp(this.configuration).getSpawnCondition(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists SpawnConditions
     * @param {SpawnConditionApiListSpawnConditionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpawnConditionApi
     */
    public listSpawnConditions(requestParameters: SpawnConditionApiListSpawnConditionsRequest = {}, options?: any) {
        return SpawnConditionApiFp(this.configuration).listSpawnConditions(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates SpawnCondition
     * @param {SpawnConditionApiUpdateSpawnConditionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpawnConditionApi
     */
    public updateSpawnCondition(requestParameters: SpawnConditionApiUpdateSpawnConditionRequest, options?: any) {
        return SpawnConditionApiFp(this.configuration).updateSpawnCondition(requestParameters.id, requestParameters.spawnCondition, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SpawnConditionValueApi - axios parameter creator
 * @export
 */
export const SpawnConditionValueApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates SpawnConditionValue
         * @param {ModelsSpawnConditionValue} spawnConditionValue SpawnConditionValue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSpawnConditionValue: async (spawnConditionValue: ModelsSpawnConditionValue, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'spawnConditionValue' is not null or undefined
            if (spawnConditionValue === null || spawnConditionValue === undefined) {
                throw new RequiredError('spawnConditionValue','Required parameter spawnConditionValue was null or undefined when calling createSpawnConditionValue.');
            }
            const localVarPath = `/spawn_condition_value`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof spawnConditionValue !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(spawnConditionValue !== undefined ? spawnConditionValue : {})
                : (spawnConditionValue || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes SpawnConditionValue
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpawnConditionValue: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteSpawnConditionValue.');
            }
            const localVarPath = `/spawn_condition_value/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets SpawnConditionValue
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpawnConditionValue: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSpawnConditionValue.');
            }
            const localVarPath = `/spawn_condition_value/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists SpawnConditionValues
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpawnConditionValues: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/spawn_condition_values`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates SpawnConditionValue
         * @param {number} id Id
         * @param {ModelsSpawnConditionValue} spawnConditionValue SpawnConditionValue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSpawnConditionValue: async (id: number, spawnConditionValue: ModelsSpawnConditionValue, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateSpawnConditionValue.');
            }
            // verify required parameter 'spawnConditionValue' is not null or undefined
            if (spawnConditionValue === null || spawnConditionValue === undefined) {
                throw new RequiredError('spawnConditionValue','Required parameter spawnConditionValue was null or undefined when calling updateSpawnConditionValue.');
            }
            const localVarPath = `/spawn_condition_value/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof spawnConditionValue !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(spawnConditionValue !== undefined ? spawnConditionValue : {})
                : (spawnConditionValue || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SpawnConditionValueApi - functional programming interface
 * @export
 */
export const SpawnConditionValueApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates SpawnConditionValue
         * @param {ModelsSpawnConditionValue} spawnConditionValue SpawnConditionValue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSpawnConditionValue(spawnConditionValue: ModelsSpawnConditionValue, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsSpawnConditionValue>>> {
            const localVarAxiosArgs = await SpawnConditionValueApiAxiosParamCreator(configuration).createSpawnConditionValue(spawnConditionValue, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes SpawnConditionValue
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSpawnConditionValue(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await SpawnConditionValueApiAxiosParamCreator(configuration).deleteSpawnConditionValue(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets SpawnConditionValue
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSpawnConditionValue(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsSpawnConditionValue>>> {
            const localVarAxiosArgs = await SpawnConditionValueApiAxiosParamCreator(configuration).getSpawnConditionValue(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists SpawnConditionValues
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSpawnConditionValues(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsSpawnConditionValue>>> {
            const localVarAxiosArgs = await SpawnConditionValueApiAxiosParamCreator(configuration).listSpawnConditionValues(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates SpawnConditionValue
         * @param {number} id Id
         * @param {ModelsSpawnConditionValue} spawnConditionValue SpawnConditionValue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSpawnConditionValue(id: number, spawnConditionValue: ModelsSpawnConditionValue, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsSpawnConditionValue>>> {
            const localVarAxiosArgs = await SpawnConditionValueApiAxiosParamCreator(configuration).updateSpawnConditionValue(id, spawnConditionValue, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SpawnConditionValueApi - factory interface
 * @export
 */
export const SpawnConditionValueApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates SpawnConditionValue
         * @param {ModelsSpawnConditionValue} spawnConditionValue SpawnConditionValue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSpawnConditionValue(spawnConditionValue: ModelsSpawnConditionValue, options?: any): AxiosPromise<Array<ModelsSpawnConditionValue>> {
            return SpawnConditionValueApiFp(configuration).createSpawnConditionValue(spawnConditionValue, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes SpawnConditionValue
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpawnConditionValue(id: number, options?: any): AxiosPromise<string> {
            return SpawnConditionValueApiFp(configuration).deleteSpawnConditionValue(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets SpawnConditionValue
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpawnConditionValue(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsSpawnConditionValue>> {
            return SpawnConditionValueApiFp(configuration).getSpawnConditionValue(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists SpawnConditionValues
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpawnConditionValues(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsSpawnConditionValue>> {
            return SpawnConditionValueApiFp(configuration).listSpawnConditionValues(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates SpawnConditionValue
         * @param {number} id Id
         * @param {ModelsSpawnConditionValue} spawnConditionValue SpawnConditionValue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSpawnConditionValue(id: number, spawnConditionValue: ModelsSpawnConditionValue, options?: any): AxiosPromise<Array<ModelsSpawnConditionValue>> {
            return SpawnConditionValueApiFp(configuration).updateSpawnConditionValue(id, spawnConditionValue, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createSpawnConditionValue operation in SpawnConditionValueApi.
 * @export
 * @interface SpawnConditionValueApiCreateSpawnConditionValueRequest
 */
export interface SpawnConditionValueApiCreateSpawnConditionValueRequest {
    /**
     * SpawnConditionValue
     * @type {ModelsSpawnConditionValue}
     * @memberof SpawnConditionValueApiCreateSpawnConditionValue
     */
    readonly spawnConditionValue: ModelsSpawnConditionValue
}

/**
 * Request parameters for deleteSpawnConditionValue operation in SpawnConditionValueApi.
 * @export
 * @interface SpawnConditionValueApiDeleteSpawnConditionValueRequest
 */
export interface SpawnConditionValueApiDeleteSpawnConditionValueRequest {
    /**
     * Id
     * @type {number}
     * @memberof SpawnConditionValueApiDeleteSpawnConditionValue
     */
    readonly id: number
}

/**
 * Request parameters for getSpawnConditionValue operation in SpawnConditionValueApi.
 * @export
 * @interface SpawnConditionValueApiGetSpawnConditionValueRequest
 */
export interface SpawnConditionValueApiGetSpawnConditionValueRequest {
    /**
     * Id
     * @type {number}
     * @memberof SpawnConditionValueApiGetSpawnConditionValue
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof SpawnConditionValueApiGetSpawnConditionValue
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof SpawnConditionValueApiGetSpawnConditionValue
     */
    readonly select?: string
}

/**
 * Request parameters for listSpawnConditionValues operation in SpawnConditionValueApi.
 * @export
 * @interface SpawnConditionValueApiListSpawnConditionValuesRequest
 */
export interface SpawnConditionValueApiListSpawnConditionValuesRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof SpawnConditionValueApiListSpawnConditionValues
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof SpawnConditionValueApiListSpawnConditionValues
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof SpawnConditionValueApiListSpawnConditionValues
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof SpawnConditionValueApiListSpawnConditionValues
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof SpawnConditionValueApiListSpawnConditionValues
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof SpawnConditionValueApiListSpawnConditionValues
     */
    readonly select?: string
}

/**
 * Request parameters for updateSpawnConditionValue operation in SpawnConditionValueApi.
 * @export
 * @interface SpawnConditionValueApiUpdateSpawnConditionValueRequest
 */
export interface SpawnConditionValueApiUpdateSpawnConditionValueRequest {
    /**
     * Id
     * @type {number}
     * @memberof SpawnConditionValueApiUpdateSpawnConditionValue
     */
    readonly id: number

    /**
     * SpawnConditionValue
     * @type {ModelsSpawnConditionValue}
     * @memberof SpawnConditionValueApiUpdateSpawnConditionValue
     */
    readonly spawnConditionValue: ModelsSpawnConditionValue
}

/**
 * SpawnConditionValueApi - object-oriented interface
 * @export
 * @class SpawnConditionValueApi
 * @extends {BaseAPI}
 */
export class SpawnConditionValueApi extends BaseAPI {
    /**
     * 
     * @summary Creates SpawnConditionValue
     * @param {SpawnConditionValueApiCreateSpawnConditionValueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpawnConditionValueApi
     */
    public createSpawnConditionValue(requestParameters: SpawnConditionValueApiCreateSpawnConditionValueRequest, options?: any) {
        return SpawnConditionValueApiFp(this.configuration).createSpawnConditionValue(requestParameters.spawnConditionValue, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes SpawnConditionValue
     * @param {SpawnConditionValueApiDeleteSpawnConditionValueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpawnConditionValueApi
     */
    public deleteSpawnConditionValue(requestParameters: SpawnConditionValueApiDeleteSpawnConditionValueRequest, options?: any) {
        return SpawnConditionValueApiFp(this.configuration).deleteSpawnConditionValue(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets SpawnConditionValue
     * @param {SpawnConditionValueApiGetSpawnConditionValueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpawnConditionValueApi
     */
    public getSpawnConditionValue(requestParameters: SpawnConditionValueApiGetSpawnConditionValueRequest, options?: any) {
        return SpawnConditionValueApiFp(this.configuration).getSpawnConditionValue(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists SpawnConditionValues
     * @param {SpawnConditionValueApiListSpawnConditionValuesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpawnConditionValueApi
     */
    public listSpawnConditionValues(requestParameters: SpawnConditionValueApiListSpawnConditionValuesRequest = {}, options?: any) {
        return SpawnConditionValueApiFp(this.configuration).listSpawnConditionValues(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates SpawnConditionValue
     * @param {SpawnConditionValueApiUpdateSpawnConditionValueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpawnConditionValueApi
     */
    public updateSpawnConditionValue(requestParameters: SpawnConditionValueApiUpdateSpawnConditionValueRequest, options?: any) {
        return SpawnConditionValueApiFp(this.configuration).updateSpawnConditionValue(requestParameters.id, requestParameters.spawnConditionValue, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SpawnEventApi - axios parameter creator
 * @export
 */
export const SpawnEventApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates SpawnEvent
         * @param {ModelsSpawnEvent} spawnEvent SpawnEvent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSpawnEvent: async (spawnEvent: ModelsSpawnEvent, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'spawnEvent' is not null or undefined
            if (spawnEvent === null || spawnEvent === undefined) {
                throw new RequiredError('spawnEvent','Required parameter spawnEvent was null or undefined when calling createSpawnEvent.');
            }
            const localVarPath = `/spawn_event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof spawnEvent !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(spawnEvent !== undefined ? spawnEvent : {})
                : (spawnEvent || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes SpawnEvent
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpawnEvent: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteSpawnEvent.');
            }
            const localVarPath = `/spawn_event/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets SpawnEvent
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpawnEvent: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSpawnEvent.');
            }
            const localVarPath = `/spawn_event/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists SpawnEvents
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpawnEvents: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/spawn_events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates SpawnEvent
         * @param {number} id Id
         * @param {ModelsSpawnEvent} spawnEvent SpawnEvent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSpawnEvent: async (id: number, spawnEvent: ModelsSpawnEvent, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateSpawnEvent.');
            }
            // verify required parameter 'spawnEvent' is not null or undefined
            if (spawnEvent === null || spawnEvent === undefined) {
                throw new RequiredError('spawnEvent','Required parameter spawnEvent was null or undefined when calling updateSpawnEvent.');
            }
            const localVarPath = `/spawn_event/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof spawnEvent !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(spawnEvent !== undefined ? spawnEvent : {})
                : (spawnEvent || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SpawnEventApi - functional programming interface
 * @export
 */
export const SpawnEventApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates SpawnEvent
         * @param {ModelsSpawnEvent} spawnEvent SpawnEvent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSpawnEvent(spawnEvent: ModelsSpawnEvent, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsSpawnEvent>>> {
            const localVarAxiosArgs = await SpawnEventApiAxiosParamCreator(configuration).createSpawnEvent(spawnEvent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes SpawnEvent
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSpawnEvent(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await SpawnEventApiAxiosParamCreator(configuration).deleteSpawnEvent(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets SpawnEvent
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSpawnEvent(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsSpawnEvent>>> {
            const localVarAxiosArgs = await SpawnEventApiAxiosParamCreator(configuration).getSpawnEvent(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists SpawnEvents
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSpawnEvents(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsSpawnEvent>>> {
            const localVarAxiosArgs = await SpawnEventApiAxiosParamCreator(configuration).listSpawnEvents(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates SpawnEvent
         * @param {number} id Id
         * @param {ModelsSpawnEvent} spawnEvent SpawnEvent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSpawnEvent(id: number, spawnEvent: ModelsSpawnEvent, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsSpawnEvent>>> {
            const localVarAxiosArgs = await SpawnEventApiAxiosParamCreator(configuration).updateSpawnEvent(id, spawnEvent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SpawnEventApi - factory interface
 * @export
 */
export const SpawnEventApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates SpawnEvent
         * @param {ModelsSpawnEvent} spawnEvent SpawnEvent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSpawnEvent(spawnEvent: ModelsSpawnEvent, options?: any): AxiosPromise<Array<ModelsSpawnEvent>> {
            return SpawnEventApiFp(configuration).createSpawnEvent(spawnEvent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes SpawnEvent
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpawnEvent(id: number, options?: any): AxiosPromise<string> {
            return SpawnEventApiFp(configuration).deleteSpawnEvent(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets SpawnEvent
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpawnEvent(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsSpawnEvent>> {
            return SpawnEventApiFp(configuration).getSpawnEvent(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists SpawnEvents
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpawnEvents(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsSpawnEvent>> {
            return SpawnEventApiFp(configuration).listSpawnEvents(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates SpawnEvent
         * @param {number} id Id
         * @param {ModelsSpawnEvent} spawnEvent SpawnEvent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSpawnEvent(id: number, spawnEvent: ModelsSpawnEvent, options?: any): AxiosPromise<Array<ModelsSpawnEvent>> {
            return SpawnEventApiFp(configuration).updateSpawnEvent(id, spawnEvent, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createSpawnEvent operation in SpawnEventApi.
 * @export
 * @interface SpawnEventApiCreateSpawnEventRequest
 */
export interface SpawnEventApiCreateSpawnEventRequest {
    /**
     * SpawnEvent
     * @type {ModelsSpawnEvent}
     * @memberof SpawnEventApiCreateSpawnEvent
     */
    readonly spawnEvent: ModelsSpawnEvent
}

/**
 * Request parameters for deleteSpawnEvent operation in SpawnEventApi.
 * @export
 * @interface SpawnEventApiDeleteSpawnEventRequest
 */
export interface SpawnEventApiDeleteSpawnEventRequest {
    /**
     * Id
     * @type {number}
     * @memberof SpawnEventApiDeleteSpawnEvent
     */
    readonly id: number
}

/**
 * Request parameters for getSpawnEvent operation in SpawnEventApi.
 * @export
 * @interface SpawnEventApiGetSpawnEventRequest
 */
export interface SpawnEventApiGetSpawnEventRequest {
    /**
     * Id
     * @type {number}
     * @memberof SpawnEventApiGetSpawnEvent
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof SpawnEventApiGetSpawnEvent
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof SpawnEventApiGetSpawnEvent
     */
    readonly select?: string
}

/**
 * Request parameters for listSpawnEvents operation in SpawnEventApi.
 * @export
 * @interface SpawnEventApiListSpawnEventsRequest
 */
export interface SpawnEventApiListSpawnEventsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof SpawnEventApiListSpawnEvents
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof SpawnEventApiListSpawnEvents
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof SpawnEventApiListSpawnEvents
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof SpawnEventApiListSpawnEvents
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof SpawnEventApiListSpawnEvents
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof SpawnEventApiListSpawnEvents
     */
    readonly select?: string
}

/**
 * Request parameters for updateSpawnEvent operation in SpawnEventApi.
 * @export
 * @interface SpawnEventApiUpdateSpawnEventRequest
 */
export interface SpawnEventApiUpdateSpawnEventRequest {
    /**
     * Id
     * @type {number}
     * @memberof SpawnEventApiUpdateSpawnEvent
     */
    readonly id: number

    /**
     * SpawnEvent
     * @type {ModelsSpawnEvent}
     * @memberof SpawnEventApiUpdateSpawnEvent
     */
    readonly spawnEvent: ModelsSpawnEvent
}

/**
 * SpawnEventApi - object-oriented interface
 * @export
 * @class SpawnEventApi
 * @extends {BaseAPI}
 */
export class SpawnEventApi extends BaseAPI {
    /**
     * 
     * @summary Creates SpawnEvent
     * @param {SpawnEventApiCreateSpawnEventRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpawnEventApi
     */
    public createSpawnEvent(requestParameters: SpawnEventApiCreateSpawnEventRequest, options?: any) {
        return SpawnEventApiFp(this.configuration).createSpawnEvent(requestParameters.spawnEvent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes SpawnEvent
     * @param {SpawnEventApiDeleteSpawnEventRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpawnEventApi
     */
    public deleteSpawnEvent(requestParameters: SpawnEventApiDeleteSpawnEventRequest, options?: any) {
        return SpawnEventApiFp(this.configuration).deleteSpawnEvent(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets SpawnEvent
     * @param {SpawnEventApiGetSpawnEventRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpawnEventApi
     */
    public getSpawnEvent(requestParameters: SpawnEventApiGetSpawnEventRequest, options?: any) {
        return SpawnEventApiFp(this.configuration).getSpawnEvent(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists SpawnEvents
     * @param {SpawnEventApiListSpawnEventsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpawnEventApi
     */
    public listSpawnEvents(requestParameters: SpawnEventApiListSpawnEventsRequest = {}, options?: any) {
        return SpawnEventApiFp(this.configuration).listSpawnEvents(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates SpawnEvent
     * @param {SpawnEventApiUpdateSpawnEventRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpawnEventApi
     */
    public updateSpawnEvent(requestParameters: SpawnEventApiUpdateSpawnEventRequest, options?: any) {
        return SpawnEventApiFp(this.configuration).updateSpawnEvent(requestParameters.id, requestParameters.spawnEvent, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SpawnentryApi - axios parameter creator
 * @export
 */
export const SpawnentryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Spawnentry
         * @param {ModelsSpawnentry} spawnentry Spawnentry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSpawnentry: async (spawnentry: ModelsSpawnentry, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'spawnentry' is not null or undefined
            if (spawnentry === null || spawnentry === undefined) {
                throw new RequiredError('spawnentry','Required parameter spawnentry was null or undefined when calling createSpawnentry.');
            }
            const localVarPath = `/spawnentry`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof spawnentry !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(spawnentry !== undefined ? spawnentry : {})
                : (spawnentry || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes Spawnentry
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpawnentry: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteSpawnentry.');
            }
            const localVarPath = `/spawnentry/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Spawnentry
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;Spawngroup&lt;br&gt;Spawngroup.Spawn2
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpawnentry: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSpawnentry.');
            }
            const localVarPath = `/spawnentry/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists Spawnentries
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;Spawngroup&lt;br&gt;Spawngroup.Spawn2
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpawnentries: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/spawnentries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates Spawnentry
         * @param {number} id Id
         * @param {ModelsSpawnentry} spawnentry Spawnentry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSpawnentry: async (id: number, spawnentry: ModelsSpawnentry, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateSpawnentry.');
            }
            // verify required parameter 'spawnentry' is not null or undefined
            if (spawnentry === null || spawnentry === undefined) {
                throw new RequiredError('spawnentry','Required parameter spawnentry was null or undefined when calling updateSpawnentry.');
            }
            const localVarPath = `/spawnentry/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof spawnentry !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(spawnentry !== undefined ? spawnentry : {})
                : (spawnentry || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SpawnentryApi - functional programming interface
 * @export
 */
export const SpawnentryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Spawnentry
         * @param {ModelsSpawnentry} spawnentry Spawnentry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSpawnentry(spawnentry: ModelsSpawnentry, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsSpawnentry>>> {
            const localVarAxiosArgs = await SpawnentryApiAxiosParamCreator(configuration).createSpawnentry(spawnentry, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes Spawnentry
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSpawnentry(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await SpawnentryApiAxiosParamCreator(configuration).deleteSpawnentry(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Spawnentry
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;Spawngroup&lt;br&gt;Spawngroup.Spawn2
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSpawnentry(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsSpawnentry>>> {
            const localVarAxiosArgs = await SpawnentryApiAxiosParamCreator(configuration).getSpawnentry(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists Spawnentries
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;Spawngroup&lt;br&gt;Spawngroup.Spawn2
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSpawnentries(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsSpawnentry>>> {
            const localVarAxiosArgs = await SpawnentryApiAxiosParamCreator(configuration).listSpawnentries(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates Spawnentry
         * @param {number} id Id
         * @param {ModelsSpawnentry} spawnentry Spawnentry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSpawnentry(id: number, spawnentry: ModelsSpawnentry, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsSpawnentry>>> {
            const localVarAxiosArgs = await SpawnentryApiAxiosParamCreator(configuration).updateSpawnentry(id, spawnentry, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SpawnentryApi - factory interface
 * @export
 */
export const SpawnentryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates Spawnentry
         * @param {ModelsSpawnentry} spawnentry Spawnentry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSpawnentry(spawnentry: ModelsSpawnentry, options?: any): AxiosPromise<Array<ModelsSpawnentry>> {
            return SpawnentryApiFp(configuration).createSpawnentry(spawnentry, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes Spawnentry
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpawnentry(id: number, options?: any): AxiosPromise<string> {
            return SpawnentryApiFp(configuration).deleteSpawnentry(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Spawnentry
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;Spawngroup&lt;br&gt;Spawngroup.Spawn2
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpawnentry(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsSpawnentry>> {
            return SpawnentryApiFp(configuration).getSpawnentry(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists Spawnentries
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;Spawngroup&lt;br&gt;Spawngroup.Spawn2
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpawnentries(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsSpawnentry>> {
            return SpawnentryApiFp(configuration).listSpawnentries(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates Spawnentry
         * @param {number} id Id
         * @param {ModelsSpawnentry} spawnentry Spawnentry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSpawnentry(id: number, spawnentry: ModelsSpawnentry, options?: any): AxiosPromise<Array<ModelsSpawnentry>> {
            return SpawnentryApiFp(configuration).updateSpawnentry(id, spawnentry, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createSpawnentry operation in SpawnentryApi.
 * @export
 * @interface SpawnentryApiCreateSpawnentryRequest
 */
export interface SpawnentryApiCreateSpawnentryRequest {
    /**
     * Spawnentry
     * @type {ModelsSpawnentry}
     * @memberof SpawnentryApiCreateSpawnentry
     */
    readonly spawnentry: ModelsSpawnentry
}

/**
 * Request parameters for deleteSpawnentry operation in SpawnentryApi.
 * @export
 * @interface SpawnentryApiDeleteSpawnentryRequest
 */
export interface SpawnentryApiDeleteSpawnentryRequest {
    /**
     * Id
     * @type {number}
     * @memberof SpawnentryApiDeleteSpawnentry
     */
    readonly id: number
}

/**
 * Request parameters for getSpawnentry operation in SpawnentryApi.
 * @export
 * @interface SpawnentryApiGetSpawnentryRequest
 */
export interface SpawnentryApiGetSpawnentryRequest {
    /**
     * Id
     * @type {number}
     * @memberof SpawnentryApiGetSpawnentry
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;Spawngroup&lt;br&gt;Spawngroup.Spawn2
     * @type {string}
     * @memberof SpawnentryApiGetSpawnentry
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof SpawnentryApiGetSpawnentry
     */
    readonly select?: string
}

/**
 * Request parameters for listSpawnentries operation in SpawnentryApi.
 * @export
 * @interface SpawnentryApiListSpawnentriesRequest
 */
export interface SpawnentryApiListSpawnentriesRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;Spawngroup&lt;br&gt;Spawngroup.Spawn2
     * @type {string}
     * @memberof SpawnentryApiListSpawnentries
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof SpawnentryApiListSpawnentries
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof SpawnentryApiListSpawnentries
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof SpawnentryApiListSpawnentries
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof SpawnentryApiListSpawnentries
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof SpawnentryApiListSpawnentries
     */
    readonly select?: string
}

/**
 * Request parameters for updateSpawnentry operation in SpawnentryApi.
 * @export
 * @interface SpawnentryApiUpdateSpawnentryRequest
 */
export interface SpawnentryApiUpdateSpawnentryRequest {
    /**
     * Id
     * @type {number}
     * @memberof SpawnentryApiUpdateSpawnentry
     */
    readonly id: number

    /**
     * Spawnentry
     * @type {ModelsSpawnentry}
     * @memberof SpawnentryApiUpdateSpawnentry
     */
    readonly spawnentry: ModelsSpawnentry
}

/**
 * SpawnentryApi - object-oriented interface
 * @export
 * @class SpawnentryApi
 * @extends {BaseAPI}
 */
export class SpawnentryApi extends BaseAPI {
    /**
     * 
     * @summary Creates Spawnentry
     * @param {SpawnentryApiCreateSpawnentryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpawnentryApi
     */
    public createSpawnentry(requestParameters: SpawnentryApiCreateSpawnentryRequest, options?: any) {
        return SpawnentryApiFp(this.configuration).createSpawnentry(requestParameters.spawnentry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes Spawnentry
     * @param {SpawnentryApiDeleteSpawnentryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpawnentryApi
     */
    public deleteSpawnentry(requestParameters: SpawnentryApiDeleteSpawnentryRequest, options?: any) {
        return SpawnentryApiFp(this.configuration).deleteSpawnentry(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Spawnentry
     * @param {SpawnentryApiGetSpawnentryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpawnentryApi
     */
    public getSpawnentry(requestParameters: SpawnentryApiGetSpawnentryRequest, options?: any) {
        return SpawnentryApiFp(this.configuration).getSpawnentry(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists Spawnentries
     * @param {SpawnentryApiListSpawnentriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpawnentryApi
     */
    public listSpawnentries(requestParameters: SpawnentryApiListSpawnentriesRequest = {}, options?: any) {
        return SpawnentryApiFp(this.configuration).listSpawnentries(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates Spawnentry
     * @param {SpawnentryApiUpdateSpawnentryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpawnentryApi
     */
    public updateSpawnentry(requestParameters: SpawnentryApiUpdateSpawnentryRequest, options?: any) {
        return SpawnentryApiFp(this.configuration).updateSpawnentry(requestParameters.id, requestParameters.spawnentry, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SpawngroupApi - axios parameter creator
 * @export
 */
export const SpawngroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Spawngroup
         * @param {ModelsSpawngroup} spawngroup Spawngroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSpawngroup: async (spawngroup: ModelsSpawngroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'spawngroup' is not null or undefined
            if (spawngroup === null || spawngroup === undefined) {
                throw new RequiredError('spawngroup','Required parameter spawngroup was null or undefined when calling createSpawngroup.');
            }
            const localVarPath = `/spawngroup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof spawngroup !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(spawngroup !== undefined ? spawngroup : {})
                : (spawngroup || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes Spawngroup
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpawngroup: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteSpawngroup.');
            }
            const localVarPath = `/spawngroup/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Spawngroup
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;Spawn2
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpawngroup: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSpawngroup.');
            }
            const localVarPath = `/spawngroup/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists Spawngroups
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;Spawn2
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpawngroups: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/spawngroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates Spawngroup
         * @param {number} id Id
         * @param {ModelsSpawngroup} spawngroup Spawngroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSpawngroup: async (id: number, spawngroup: ModelsSpawngroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateSpawngroup.');
            }
            // verify required parameter 'spawngroup' is not null or undefined
            if (spawngroup === null || spawngroup === undefined) {
                throw new RequiredError('spawngroup','Required parameter spawngroup was null or undefined when calling updateSpawngroup.');
            }
            const localVarPath = `/spawngroup/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof spawngroup !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(spawngroup !== undefined ? spawngroup : {})
                : (spawngroup || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SpawngroupApi - functional programming interface
 * @export
 */
export const SpawngroupApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Spawngroup
         * @param {ModelsSpawngroup} spawngroup Spawngroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSpawngroup(spawngroup: ModelsSpawngroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsSpawngroup>>> {
            const localVarAxiosArgs = await SpawngroupApiAxiosParamCreator(configuration).createSpawngroup(spawngroup, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes Spawngroup
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSpawngroup(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await SpawngroupApiAxiosParamCreator(configuration).deleteSpawngroup(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Spawngroup
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;Spawn2
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSpawngroup(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsSpawngroup>>> {
            const localVarAxiosArgs = await SpawngroupApiAxiosParamCreator(configuration).getSpawngroup(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists Spawngroups
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;Spawn2
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSpawngroups(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsSpawngroup>>> {
            const localVarAxiosArgs = await SpawngroupApiAxiosParamCreator(configuration).listSpawngroups(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates Spawngroup
         * @param {number} id Id
         * @param {ModelsSpawngroup} spawngroup Spawngroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSpawngroup(id: number, spawngroup: ModelsSpawngroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsSpawngroup>>> {
            const localVarAxiosArgs = await SpawngroupApiAxiosParamCreator(configuration).updateSpawngroup(id, spawngroup, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SpawngroupApi - factory interface
 * @export
 */
export const SpawngroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates Spawngroup
         * @param {ModelsSpawngroup} spawngroup Spawngroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSpawngroup(spawngroup: ModelsSpawngroup, options?: any): AxiosPromise<Array<ModelsSpawngroup>> {
            return SpawngroupApiFp(configuration).createSpawngroup(spawngroup, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes Spawngroup
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpawngroup(id: number, options?: any): AxiosPromise<string> {
            return SpawngroupApiFp(configuration).deleteSpawngroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Spawngroup
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;Spawn2
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpawngroup(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsSpawngroup>> {
            return SpawngroupApiFp(configuration).getSpawngroup(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists Spawngroups
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;Spawn2
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpawngroups(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsSpawngroup>> {
            return SpawngroupApiFp(configuration).listSpawngroups(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates Spawngroup
         * @param {number} id Id
         * @param {ModelsSpawngroup} spawngroup Spawngroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSpawngroup(id: number, spawngroup: ModelsSpawngroup, options?: any): AxiosPromise<Array<ModelsSpawngroup>> {
            return SpawngroupApiFp(configuration).updateSpawngroup(id, spawngroup, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createSpawngroup operation in SpawngroupApi.
 * @export
 * @interface SpawngroupApiCreateSpawngroupRequest
 */
export interface SpawngroupApiCreateSpawngroupRequest {
    /**
     * Spawngroup
     * @type {ModelsSpawngroup}
     * @memberof SpawngroupApiCreateSpawngroup
     */
    readonly spawngroup: ModelsSpawngroup
}

/**
 * Request parameters for deleteSpawngroup operation in SpawngroupApi.
 * @export
 * @interface SpawngroupApiDeleteSpawngroupRequest
 */
export interface SpawngroupApiDeleteSpawngroupRequest {
    /**
     * Id
     * @type {number}
     * @memberof SpawngroupApiDeleteSpawngroup
     */
    readonly id: number
}

/**
 * Request parameters for getSpawngroup operation in SpawngroupApi.
 * @export
 * @interface SpawngroupApiGetSpawngroupRequest
 */
export interface SpawngroupApiGetSpawngroupRequest {
    /**
     * Id
     * @type {number}
     * @memberof SpawngroupApiGetSpawngroup
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;Spawn2
     * @type {string}
     * @memberof SpawngroupApiGetSpawngroup
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof SpawngroupApiGetSpawngroup
     */
    readonly select?: string
}

/**
 * Request parameters for listSpawngroups operation in SpawngroupApi.
 * @export
 * @interface SpawngroupApiListSpawngroupsRequest
 */
export interface SpawngroupApiListSpawngroupsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;Spawn2
     * @type {string}
     * @memberof SpawngroupApiListSpawngroups
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof SpawngroupApiListSpawngroups
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof SpawngroupApiListSpawngroups
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof SpawngroupApiListSpawngroups
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof SpawngroupApiListSpawngroups
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof SpawngroupApiListSpawngroups
     */
    readonly select?: string
}

/**
 * Request parameters for updateSpawngroup operation in SpawngroupApi.
 * @export
 * @interface SpawngroupApiUpdateSpawngroupRequest
 */
export interface SpawngroupApiUpdateSpawngroupRequest {
    /**
     * Id
     * @type {number}
     * @memberof SpawngroupApiUpdateSpawngroup
     */
    readonly id: number

    /**
     * Spawngroup
     * @type {ModelsSpawngroup}
     * @memberof SpawngroupApiUpdateSpawngroup
     */
    readonly spawngroup: ModelsSpawngroup
}

/**
 * SpawngroupApi - object-oriented interface
 * @export
 * @class SpawngroupApi
 * @extends {BaseAPI}
 */
export class SpawngroupApi extends BaseAPI {
    /**
     * 
     * @summary Creates Spawngroup
     * @param {SpawngroupApiCreateSpawngroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpawngroupApi
     */
    public createSpawngroup(requestParameters: SpawngroupApiCreateSpawngroupRequest, options?: any) {
        return SpawngroupApiFp(this.configuration).createSpawngroup(requestParameters.spawngroup, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes Spawngroup
     * @param {SpawngroupApiDeleteSpawngroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpawngroupApi
     */
    public deleteSpawngroup(requestParameters: SpawngroupApiDeleteSpawngroupRequest, options?: any) {
        return SpawngroupApiFp(this.configuration).deleteSpawngroup(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Spawngroup
     * @param {SpawngroupApiGetSpawngroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpawngroupApi
     */
    public getSpawngroup(requestParameters: SpawngroupApiGetSpawngroupRequest, options?: any) {
        return SpawngroupApiFp(this.configuration).getSpawngroup(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists Spawngroups
     * @param {SpawngroupApiListSpawngroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpawngroupApi
     */
    public listSpawngroups(requestParameters: SpawngroupApiListSpawngroupsRequest = {}, options?: any) {
        return SpawngroupApiFp(this.configuration).listSpawngroups(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates Spawngroup
     * @param {SpawngroupApiUpdateSpawngroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpawngroupApi
     */
    public updateSpawngroup(requestParameters: SpawngroupApiUpdateSpawngroupRequest, options?: any) {
        return SpawngroupApiFp(this.configuration).updateSpawngroup(requestParameters.id, requestParameters.spawngroup, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SpellGlobalApi - axios parameter creator
 * @export
 */
export const SpellGlobalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates SpellGlobal
         * @param {ModelsSpellGlobal} spellGlobal SpellGlobal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSpellGlobal: async (spellGlobal: ModelsSpellGlobal, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'spellGlobal' is not null or undefined
            if (spellGlobal === null || spellGlobal === undefined) {
                throw new RequiredError('spellGlobal','Required parameter spellGlobal was null or undefined when calling createSpellGlobal.');
            }
            const localVarPath = `/spell_global`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof spellGlobal !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(spellGlobal !== undefined ? spellGlobal : {})
                : (spellGlobal || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes SpellGlobal
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpellGlobal: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteSpellGlobal.');
            }
            const localVarPath = `/spell_global/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets SpellGlobal
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpellGlobal: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSpellGlobal.');
            }
            const localVarPath = `/spell_global/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists SpellGlobals
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpellGlobals: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/spell_globals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates SpellGlobal
         * @param {number} id Id
         * @param {ModelsSpellGlobal} spellGlobal SpellGlobal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSpellGlobal: async (id: number, spellGlobal: ModelsSpellGlobal, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateSpellGlobal.');
            }
            // verify required parameter 'spellGlobal' is not null or undefined
            if (spellGlobal === null || spellGlobal === undefined) {
                throw new RequiredError('spellGlobal','Required parameter spellGlobal was null or undefined when calling updateSpellGlobal.');
            }
            const localVarPath = `/spell_global/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof spellGlobal !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(spellGlobal !== undefined ? spellGlobal : {})
                : (spellGlobal || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SpellGlobalApi - functional programming interface
 * @export
 */
export const SpellGlobalApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates SpellGlobal
         * @param {ModelsSpellGlobal} spellGlobal SpellGlobal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSpellGlobal(spellGlobal: ModelsSpellGlobal, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsSpellGlobal>>> {
            const localVarAxiosArgs = await SpellGlobalApiAxiosParamCreator(configuration).createSpellGlobal(spellGlobal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes SpellGlobal
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSpellGlobal(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await SpellGlobalApiAxiosParamCreator(configuration).deleteSpellGlobal(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets SpellGlobal
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSpellGlobal(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsSpellGlobal>>> {
            const localVarAxiosArgs = await SpellGlobalApiAxiosParamCreator(configuration).getSpellGlobal(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists SpellGlobals
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSpellGlobals(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsSpellGlobal>>> {
            const localVarAxiosArgs = await SpellGlobalApiAxiosParamCreator(configuration).listSpellGlobals(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates SpellGlobal
         * @param {number} id Id
         * @param {ModelsSpellGlobal} spellGlobal SpellGlobal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSpellGlobal(id: number, spellGlobal: ModelsSpellGlobal, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsSpellGlobal>>> {
            const localVarAxiosArgs = await SpellGlobalApiAxiosParamCreator(configuration).updateSpellGlobal(id, spellGlobal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SpellGlobalApi - factory interface
 * @export
 */
export const SpellGlobalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates SpellGlobal
         * @param {ModelsSpellGlobal} spellGlobal SpellGlobal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSpellGlobal(spellGlobal: ModelsSpellGlobal, options?: any): AxiosPromise<Array<ModelsSpellGlobal>> {
            return SpellGlobalApiFp(configuration).createSpellGlobal(spellGlobal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes SpellGlobal
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpellGlobal(id: number, options?: any): AxiosPromise<string> {
            return SpellGlobalApiFp(configuration).deleteSpellGlobal(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets SpellGlobal
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpellGlobal(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsSpellGlobal>> {
            return SpellGlobalApiFp(configuration).getSpellGlobal(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists SpellGlobals
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpellGlobals(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsSpellGlobal>> {
            return SpellGlobalApiFp(configuration).listSpellGlobals(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates SpellGlobal
         * @param {number} id Id
         * @param {ModelsSpellGlobal} spellGlobal SpellGlobal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSpellGlobal(id: number, spellGlobal: ModelsSpellGlobal, options?: any): AxiosPromise<Array<ModelsSpellGlobal>> {
            return SpellGlobalApiFp(configuration).updateSpellGlobal(id, spellGlobal, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createSpellGlobal operation in SpellGlobalApi.
 * @export
 * @interface SpellGlobalApiCreateSpellGlobalRequest
 */
export interface SpellGlobalApiCreateSpellGlobalRequest {
    /**
     * SpellGlobal
     * @type {ModelsSpellGlobal}
     * @memberof SpellGlobalApiCreateSpellGlobal
     */
    readonly spellGlobal: ModelsSpellGlobal
}

/**
 * Request parameters for deleteSpellGlobal operation in SpellGlobalApi.
 * @export
 * @interface SpellGlobalApiDeleteSpellGlobalRequest
 */
export interface SpellGlobalApiDeleteSpellGlobalRequest {
    /**
     * Id
     * @type {number}
     * @memberof SpellGlobalApiDeleteSpellGlobal
     */
    readonly id: number
}

/**
 * Request parameters for getSpellGlobal operation in SpellGlobalApi.
 * @export
 * @interface SpellGlobalApiGetSpellGlobalRequest
 */
export interface SpellGlobalApiGetSpellGlobalRequest {
    /**
     * Id
     * @type {number}
     * @memberof SpellGlobalApiGetSpellGlobal
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof SpellGlobalApiGetSpellGlobal
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof SpellGlobalApiGetSpellGlobal
     */
    readonly select?: string
}

/**
 * Request parameters for listSpellGlobals operation in SpellGlobalApi.
 * @export
 * @interface SpellGlobalApiListSpellGlobalsRequest
 */
export interface SpellGlobalApiListSpellGlobalsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof SpellGlobalApiListSpellGlobals
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof SpellGlobalApiListSpellGlobals
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof SpellGlobalApiListSpellGlobals
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof SpellGlobalApiListSpellGlobals
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof SpellGlobalApiListSpellGlobals
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof SpellGlobalApiListSpellGlobals
     */
    readonly select?: string
}

/**
 * Request parameters for updateSpellGlobal operation in SpellGlobalApi.
 * @export
 * @interface SpellGlobalApiUpdateSpellGlobalRequest
 */
export interface SpellGlobalApiUpdateSpellGlobalRequest {
    /**
     * Id
     * @type {number}
     * @memberof SpellGlobalApiUpdateSpellGlobal
     */
    readonly id: number

    /**
     * SpellGlobal
     * @type {ModelsSpellGlobal}
     * @memberof SpellGlobalApiUpdateSpellGlobal
     */
    readonly spellGlobal: ModelsSpellGlobal
}

/**
 * SpellGlobalApi - object-oriented interface
 * @export
 * @class SpellGlobalApi
 * @extends {BaseAPI}
 */
export class SpellGlobalApi extends BaseAPI {
    /**
     * 
     * @summary Creates SpellGlobal
     * @param {SpellGlobalApiCreateSpellGlobalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpellGlobalApi
     */
    public createSpellGlobal(requestParameters: SpellGlobalApiCreateSpellGlobalRequest, options?: any) {
        return SpellGlobalApiFp(this.configuration).createSpellGlobal(requestParameters.spellGlobal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes SpellGlobal
     * @param {SpellGlobalApiDeleteSpellGlobalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpellGlobalApi
     */
    public deleteSpellGlobal(requestParameters: SpellGlobalApiDeleteSpellGlobalRequest, options?: any) {
        return SpellGlobalApiFp(this.configuration).deleteSpellGlobal(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets SpellGlobal
     * @param {SpellGlobalApiGetSpellGlobalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpellGlobalApi
     */
    public getSpellGlobal(requestParameters: SpellGlobalApiGetSpellGlobalRequest, options?: any) {
        return SpellGlobalApiFp(this.configuration).getSpellGlobal(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists SpellGlobals
     * @param {SpellGlobalApiListSpellGlobalsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpellGlobalApi
     */
    public listSpellGlobals(requestParameters: SpellGlobalApiListSpellGlobalsRequest = {}, options?: any) {
        return SpellGlobalApiFp(this.configuration).listSpellGlobals(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates SpellGlobal
     * @param {SpellGlobalApiUpdateSpellGlobalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpellGlobalApi
     */
    public updateSpellGlobal(requestParameters: SpellGlobalApiUpdateSpellGlobalRequest, options?: any) {
        return SpellGlobalApiFp(this.configuration).updateSpellGlobal(requestParameters.id, requestParameters.spellGlobal, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SpellsNewApi - axios parameter creator
 * @export
 */
export const SpellsNewApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates SpellsNew
         * @param {ModelsSpellsNew} spellsNew SpellsNew
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSpellsNew: async (spellsNew: ModelsSpellsNew, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'spellsNew' is not null or undefined
            if (spellsNew === null || spellsNew === undefined) {
                throw new RequiredError('spellsNew','Required parameter spellsNew was null or undefined when calling createSpellsNew.');
            }
            const localVarPath = `/spells_new`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof spellsNew !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(spellsNew !== undefined ? spellsNew : {})
                : (spellsNew || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes SpellsNew
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpellsNew: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteSpellsNew.');
            }
            const localVarPath = `/spells_new/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets SpellsNew
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;Aura&lt;br&gt;BlockedSpells&lt;br&gt;Damageshieldtypes&lt;br&gt;SpellBuckets&lt;br&gt;SpellGlobals
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpellsNew: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSpellsNew.');
            }
            const localVarPath = `/spells_new/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists SpellsNews
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;Aura&lt;br&gt;BlockedSpells&lt;br&gt;Damageshieldtypes&lt;br&gt;SpellBuckets&lt;br&gt;SpellGlobals
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpellsNews: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/spells_news`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates SpellsNew
         * @param {number} id Id
         * @param {ModelsSpellsNew} spellsNew SpellsNew
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSpellsNew: async (id: number, spellsNew: ModelsSpellsNew, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateSpellsNew.');
            }
            // verify required parameter 'spellsNew' is not null or undefined
            if (spellsNew === null || spellsNew === undefined) {
                throw new RequiredError('spellsNew','Required parameter spellsNew was null or undefined when calling updateSpellsNew.');
            }
            const localVarPath = `/spells_new/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof spellsNew !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(spellsNew !== undefined ? spellsNew : {})
                : (spellsNew || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SpellsNewApi - functional programming interface
 * @export
 */
export const SpellsNewApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates SpellsNew
         * @param {ModelsSpellsNew} spellsNew SpellsNew
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSpellsNew(spellsNew: ModelsSpellsNew, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsSpellsNew>>> {
            const localVarAxiosArgs = await SpellsNewApiAxiosParamCreator(configuration).createSpellsNew(spellsNew, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes SpellsNew
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSpellsNew(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await SpellsNewApiAxiosParamCreator(configuration).deleteSpellsNew(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets SpellsNew
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;Aura&lt;br&gt;BlockedSpells&lt;br&gt;Damageshieldtypes&lt;br&gt;SpellBuckets&lt;br&gt;SpellGlobals
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSpellsNew(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsSpellsNew>>> {
            const localVarAxiosArgs = await SpellsNewApiAxiosParamCreator(configuration).getSpellsNew(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists SpellsNews
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;Aura&lt;br&gt;BlockedSpells&lt;br&gt;Damageshieldtypes&lt;br&gt;SpellBuckets&lt;br&gt;SpellGlobals
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSpellsNews(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsSpellsNew>>> {
            const localVarAxiosArgs = await SpellsNewApiAxiosParamCreator(configuration).listSpellsNews(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates SpellsNew
         * @param {number} id Id
         * @param {ModelsSpellsNew} spellsNew SpellsNew
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSpellsNew(id: number, spellsNew: ModelsSpellsNew, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsSpellsNew>>> {
            const localVarAxiosArgs = await SpellsNewApiAxiosParamCreator(configuration).updateSpellsNew(id, spellsNew, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SpellsNewApi - factory interface
 * @export
 */
export const SpellsNewApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates SpellsNew
         * @param {ModelsSpellsNew} spellsNew SpellsNew
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSpellsNew(spellsNew: ModelsSpellsNew, options?: any): AxiosPromise<Array<ModelsSpellsNew>> {
            return SpellsNewApiFp(configuration).createSpellsNew(spellsNew, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes SpellsNew
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpellsNew(id: number, options?: any): AxiosPromise<string> {
            return SpellsNewApiFp(configuration).deleteSpellsNew(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets SpellsNew
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;Aura&lt;br&gt;BlockedSpells&lt;br&gt;Damageshieldtypes&lt;br&gt;SpellBuckets&lt;br&gt;SpellGlobals
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpellsNew(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsSpellsNew>> {
            return SpellsNewApiFp(configuration).getSpellsNew(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists SpellsNews
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;Aura&lt;br&gt;BlockedSpells&lt;br&gt;Damageshieldtypes&lt;br&gt;SpellBuckets&lt;br&gt;SpellGlobals
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpellsNews(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsSpellsNew>> {
            return SpellsNewApiFp(configuration).listSpellsNews(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates SpellsNew
         * @param {number} id Id
         * @param {ModelsSpellsNew} spellsNew SpellsNew
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSpellsNew(id: number, spellsNew: ModelsSpellsNew, options?: any): AxiosPromise<Array<ModelsSpellsNew>> {
            return SpellsNewApiFp(configuration).updateSpellsNew(id, spellsNew, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createSpellsNew operation in SpellsNewApi.
 * @export
 * @interface SpellsNewApiCreateSpellsNewRequest
 */
export interface SpellsNewApiCreateSpellsNewRequest {
    /**
     * SpellsNew
     * @type {ModelsSpellsNew}
     * @memberof SpellsNewApiCreateSpellsNew
     */
    readonly spellsNew: ModelsSpellsNew
}

/**
 * Request parameters for deleteSpellsNew operation in SpellsNewApi.
 * @export
 * @interface SpellsNewApiDeleteSpellsNewRequest
 */
export interface SpellsNewApiDeleteSpellsNewRequest {
    /**
     * Id
     * @type {number}
     * @memberof SpellsNewApiDeleteSpellsNew
     */
    readonly id: number
}

/**
 * Request parameters for getSpellsNew operation in SpellsNewApi.
 * @export
 * @interface SpellsNewApiGetSpellsNewRequest
 */
export interface SpellsNewApiGetSpellsNewRequest {
    /**
     * Id
     * @type {number}
     * @memberof SpellsNewApiGetSpellsNew
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;Aura&lt;br&gt;BlockedSpells&lt;br&gt;Damageshieldtypes&lt;br&gt;SpellBuckets&lt;br&gt;SpellGlobals
     * @type {string}
     * @memberof SpellsNewApiGetSpellsNew
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof SpellsNewApiGetSpellsNew
     */
    readonly select?: string
}

/**
 * Request parameters for listSpellsNews operation in SpellsNewApi.
 * @export
 * @interface SpellsNewApiListSpellsNewsRequest
 */
export interface SpellsNewApiListSpellsNewsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;Aura&lt;br&gt;BlockedSpells&lt;br&gt;Damageshieldtypes&lt;br&gt;SpellBuckets&lt;br&gt;SpellGlobals
     * @type {string}
     * @memberof SpellsNewApiListSpellsNews
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof SpellsNewApiListSpellsNews
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof SpellsNewApiListSpellsNews
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof SpellsNewApiListSpellsNews
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof SpellsNewApiListSpellsNews
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof SpellsNewApiListSpellsNews
     */
    readonly select?: string
}

/**
 * Request parameters for updateSpellsNew operation in SpellsNewApi.
 * @export
 * @interface SpellsNewApiUpdateSpellsNewRequest
 */
export interface SpellsNewApiUpdateSpellsNewRequest {
    /**
     * Id
     * @type {number}
     * @memberof SpellsNewApiUpdateSpellsNew
     */
    readonly id: number

    /**
     * SpellsNew
     * @type {ModelsSpellsNew}
     * @memberof SpellsNewApiUpdateSpellsNew
     */
    readonly spellsNew: ModelsSpellsNew
}

/**
 * SpellsNewApi - object-oriented interface
 * @export
 * @class SpellsNewApi
 * @extends {BaseAPI}
 */
export class SpellsNewApi extends BaseAPI {
    /**
     * 
     * @summary Creates SpellsNew
     * @param {SpellsNewApiCreateSpellsNewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpellsNewApi
     */
    public createSpellsNew(requestParameters: SpellsNewApiCreateSpellsNewRequest, options?: any) {
        return SpellsNewApiFp(this.configuration).createSpellsNew(requestParameters.spellsNew, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes SpellsNew
     * @param {SpellsNewApiDeleteSpellsNewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpellsNewApi
     */
    public deleteSpellsNew(requestParameters: SpellsNewApiDeleteSpellsNewRequest, options?: any) {
        return SpellsNewApiFp(this.configuration).deleteSpellsNew(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets SpellsNew
     * @param {SpellsNewApiGetSpellsNewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpellsNewApi
     */
    public getSpellsNew(requestParameters: SpellsNewApiGetSpellsNewRequest, options?: any) {
        return SpellsNewApiFp(this.configuration).getSpellsNew(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists SpellsNews
     * @param {SpellsNewApiListSpellsNewsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpellsNewApi
     */
    public listSpellsNews(requestParameters: SpellsNewApiListSpellsNewsRequest = {}, options?: any) {
        return SpellsNewApiFp(this.configuration).listSpellsNews(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates SpellsNew
     * @param {SpellsNewApiUpdateSpellsNewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpellsNewApi
     */
    public updateSpellsNew(requestParameters: SpellsNewApiUpdateSpellsNewRequest, options?: any) {
        return SpellsNewApiFp(this.configuration).updateSpellsNew(requestParameters.id, requestParameters.spellsNew, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StartingItemApi - axios parameter creator
 * @export
 */
export const StartingItemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates StartingItem
         * @param {ModelsStartingItem} startingItem StartingItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStartingItem: async (startingItem: ModelsStartingItem, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'startingItem' is not null or undefined
            if (startingItem === null || startingItem === undefined) {
                throw new RequiredError('startingItem','Required parameter startingItem was null or undefined when calling createStartingItem.');
            }
            const localVarPath = `/starting_item`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof startingItem !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(startingItem !== undefined ? startingItem : {})
                : (startingItem || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes StartingItem
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStartingItem: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteStartingItem.');
            }
            const localVarPath = `/starting_item/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets StartingItem
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartingItem: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getStartingItem.');
            }
            const localVarPath = `/starting_item/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists StartingItems
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStartingItems: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/starting_items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates StartingItem
         * @param {number} id Id
         * @param {ModelsStartingItem} startingItem StartingItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStartingItem: async (id: number, startingItem: ModelsStartingItem, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateStartingItem.');
            }
            // verify required parameter 'startingItem' is not null or undefined
            if (startingItem === null || startingItem === undefined) {
                throw new RequiredError('startingItem','Required parameter startingItem was null or undefined when calling updateStartingItem.');
            }
            const localVarPath = `/starting_item/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof startingItem !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(startingItem !== undefined ? startingItem : {})
                : (startingItem || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StartingItemApi - functional programming interface
 * @export
 */
export const StartingItemApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates StartingItem
         * @param {ModelsStartingItem} startingItem StartingItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStartingItem(startingItem: ModelsStartingItem, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsStartingItem>>> {
            const localVarAxiosArgs = await StartingItemApiAxiosParamCreator(configuration).createStartingItem(startingItem, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes StartingItem
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteStartingItem(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await StartingItemApiAxiosParamCreator(configuration).deleteStartingItem(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets StartingItem
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStartingItem(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsStartingItem>>> {
            const localVarAxiosArgs = await StartingItemApiAxiosParamCreator(configuration).getStartingItem(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists StartingItems
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listStartingItems(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsStartingItem>>> {
            const localVarAxiosArgs = await StartingItemApiAxiosParamCreator(configuration).listStartingItems(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates StartingItem
         * @param {number} id Id
         * @param {ModelsStartingItem} startingItem StartingItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStartingItem(id: number, startingItem: ModelsStartingItem, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsStartingItem>>> {
            const localVarAxiosArgs = await StartingItemApiAxiosParamCreator(configuration).updateStartingItem(id, startingItem, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * StartingItemApi - factory interface
 * @export
 */
export const StartingItemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates StartingItem
         * @param {ModelsStartingItem} startingItem StartingItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStartingItem(startingItem: ModelsStartingItem, options?: any): AxiosPromise<Array<ModelsStartingItem>> {
            return StartingItemApiFp(configuration).createStartingItem(startingItem, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes StartingItem
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStartingItem(id: number, options?: any): AxiosPromise<string> {
            return StartingItemApiFp(configuration).deleteStartingItem(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets StartingItem
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartingItem(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsStartingItem>> {
            return StartingItemApiFp(configuration).getStartingItem(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists StartingItems
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStartingItems(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsStartingItem>> {
            return StartingItemApiFp(configuration).listStartingItems(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates StartingItem
         * @param {number} id Id
         * @param {ModelsStartingItem} startingItem StartingItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStartingItem(id: number, startingItem: ModelsStartingItem, options?: any): AxiosPromise<Array<ModelsStartingItem>> {
            return StartingItemApiFp(configuration).updateStartingItem(id, startingItem, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createStartingItem operation in StartingItemApi.
 * @export
 * @interface StartingItemApiCreateStartingItemRequest
 */
export interface StartingItemApiCreateStartingItemRequest {
    /**
     * StartingItem
     * @type {ModelsStartingItem}
     * @memberof StartingItemApiCreateStartingItem
     */
    readonly startingItem: ModelsStartingItem
}

/**
 * Request parameters for deleteStartingItem operation in StartingItemApi.
 * @export
 * @interface StartingItemApiDeleteStartingItemRequest
 */
export interface StartingItemApiDeleteStartingItemRequest {
    /**
     * Id
     * @type {number}
     * @memberof StartingItemApiDeleteStartingItem
     */
    readonly id: number
}

/**
 * Request parameters for getStartingItem operation in StartingItemApi.
 * @export
 * @interface StartingItemApiGetStartingItemRequest
 */
export interface StartingItemApiGetStartingItemRequest {
    /**
     * Id
     * @type {number}
     * @memberof StartingItemApiGetStartingItem
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof StartingItemApiGetStartingItem
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof StartingItemApiGetStartingItem
     */
    readonly select?: string
}

/**
 * Request parameters for listStartingItems operation in StartingItemApi.
 * @export
 * @interface StartingItemApiListStartingItemsRequest
 */
export interface StartingItemApiListStartingItemsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof StartingItemApiListStartingItems
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof StartingItemApiListStartingItems
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof StartingItemApiListStartingItems
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof StartingItemApiListStartingItems
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof StartingItemApiListStartingItems
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof StartingItemApiListStartingItems
     */
    readonly select?: string
}

/**
 * Request parameters for updateStartingItem operation in StartingItemApi.
 * @export
 * @interface StartingItemApiUpdateStartingItemRequest
 */
export interface StartingItemApiUpdateStartingItemRequest {
    /**
     * Id
     * @type {number}
     * @memberof StartingItemApiUpdateStartingItem
     */
    readonly id: number

    /**
     * StartingItem
     * @type {ModelsStartingItem}
     * @memberof StartingItemApiUpdateStartingItem
     */
    readonly startingItem: ModelsStartingItem
}

/**
 * StartingItemApi - object-oriented interface
 * @export
 * @class StartingItemApi
 * @extends {BaseAPI}
 */
export class StartingItemApi extends BaseAPI {
    /**
     * 
     * @summary Creates StartingItem
     * @param {StartingItemApiCreateStartingItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StartingItemApi
     */
    public createStartingItem(requestParameters: StartingItemApiCreateStartingItemRequest, options?: any) {
        return StartingItemApiFp(this.configuration).createStartingItem(requestParameters.startingItem, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes StartingItem
     * @param {StartingItemApiDeleteStartingItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StartingItemApi
     */
    public deleteStartingItem(requestParameters: StartingItemApiDeleteStartingItemRequest, options?: any) {
        return StartingItemApiFp(this.configuration).deleteStartingItem(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets StartingItem
     * @param {StartingItemApiGetStartingItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StartingItemApi
     */
    public getStartingItem(requestParameters: StartingItemApiGetStartingItemRequest, options?: any) {
        return StartingItemApiFp(this.configuration).getStartingItem(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists StartingItems
     * @param {StartingItemApiListStartingItemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StartingItemApi
     */
    public listStartingItems(requestParameters: StartingItemApiListStartingItemsRequest = {}, options?: any) {
        return StartingItemApiFp(this.configuration).listStartingItems(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates StartingItem
     * @param {StartingItemApiUpdateStartingItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StartingItemApi
     */
    public updateStartingItem(requestParameters: StartingItemApiUpdateStartingItemRequest, options?: any) {
        return StartingItemApiFp(this.configuration).updateStartingItem(requestParameters.id, requestParameters.startingItem, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TaskApi - axios parameter creator
 * @export
 */
export const TaskApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Task
         * @param {ModelsTask} task Task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTask: async (task: ModelsTask, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'task' is not null or undefined
            if (task === null || task === undefined) {
                throw new RequiredError('task','Required parameter task was null or undefined when calling createTask.');
            }
            const localVarPath = `/task`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof task !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(task !== undefined ? task : {})
                : (task || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes Task
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTask: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteTask.');
            }
            const localVarPath = `/task/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Task
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;TaskActivities&lt;br&gt;TaskActivities.Goallists&lt;br&gt;TaskActivities.NpcType&lt;br&gt;TaskActivities.NpcType.AlternateCurrency&lt;br&gt;TaskActivities.NpcType.Merchantlists&lt;br&gt;TaskActivities.NpcType.NpcEmotes&lt;br&gt;TaskActivities.NpcType.NpcFactions&lt;br&gt;TaskActivities.NpcType.NpcFactions.NpcFactionEntries&lt;br&gt;TaskActivities.NpcType.NpcSpells&lt;br&gt;TaskActivities.NpcType.NpcSpells.NpcSpellsEntries&lt;br&gt;TaskActivities.NpcType.NpcTypesTint&lt;br&gt;TaskActivities.NpcType.Spawnentries&lt;br&gt;TaskActivities.NpcType.Spawnentries.Spawngroup&lt;br&gt;TaskActivities.NpcType.Spawnentries.Spawngroup.Spawn2&lt;br&gt;Tasksets
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getTask.');
            }
            const localVarPath = `/task/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists Tasks
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;TaskActivities&lt;br&gt;TaskActivities.Goallists&lt;br&gt;TaskActivities.NpcType&lt;br&gt;TaskActivities.NpcType.AlternateCurrency&lt;br&gt;TaskActivities.NpcType.Merchantlists&lt;br&gt;TaskActivities.NpcType.NpcEmotes&lt;br&gt;TaskActivities.NpcType.NpcFactions&lt;br&gt;TaskActivities.NpcType.NpcFactions.NpcFactionEntries&lt;br&gt;TaskActivities.NpcType.NpcSpells&lt;br&gt;TaskActivities.NpcType.NpcSpells.NpcSpellsEntries&lt;br&gt;TaskActivities.NpcType.NpcTypesTint&lt;br&gt;TaskActivities.NpcType.Spawnentries&lt;br&gt;TaskActivities.NpcType.Spawnentries.Spawngroup&lt;br&gt;TaskActivities.NpcType.Spawnentries.Spawngroup.Spawn2&lt;br&gt;Tasksets
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTasks: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates Task
         * @param {number} id Id
         * @param {ModelsTask} task Task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTask: async (id: number, task: ModelsTask, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateTask.');
            }
            // verify required parameter 'task' is not null or undefined
            if (task === null || task === undefined) {
                throw new RequiredError('task','Required parameter task was null or undefined when calling updateTask.');
            }
            const localVarPath = `/task/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof task !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(task !== undefined ? task : {})
                : (task || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaskApi - functional programming interface
 * @export
 */
export const TaskApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Task
         * @param {ModelsTask} task Task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTask(task: ModelsTask, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsTask>>> {
            const localVarAxiosArgs = await TaskApiAxiosParamCreator(configuration).createTask(task, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes Task
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTask(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await TaskApiAxiosParamCreator(configuration).deleteTask(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Task
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;TaskActivities&lt;br&gt;TaskActivities.Goallists&lt;br&gt;TaskActivities.NpcType&lt;br&gt;TaskActivities.NpcType.AlternateCurrency&lt;br&gt;TaskActivities.NpcType.Merchantlists&lt;br&gt;TaskActivities.NpcType.NpcEmotes&lt;br&gt;TaskActivities.NpcType.NpcFactions&lt;br&gt;TaskActivities.NpcType.NpcFactions.NpcFactionEntries&lt;br&gt;TaskActivities.NpcType.NpcSpells&lt;br&gt;TaskActivities.NpcType.NpcSpells.NpcSpellsEntries&lt;br&gt;TaskActivities.NpcType.NpcTypesTint&lt;br&gt;TaskActivities.NpcType.Spawnentries&lt;br&gt;TaskActivities.NpcType.Spawnentries.Spawngroup&lt;br&gt;TaskActivities.NpcType.Spawnentries.Spawngroup.Spawn2&lt;br&gt;Tasksets
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTask(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsTask>>> {
            const localVarAxiosArgs = await TaskApiAxiosParamCreator(configuration).getTask(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists Tasks
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;TaskActivities&lt;br&gt;TaskActivities.Goallists&lt;br&gt;TaskActivities.NpcType&lt;br&gt;TaskActivities.NpcType.AlternateCurrency&lt;br&gt;TaskActivities.NpcType.Merchantlists&lt;br&gt;TaskActivities.NpcType.NpcEmotes&lt;br&gt;TaskActivities.NpcType.NpcFactions&lt;br&gt;TaskActivities.NpcType.NpcFactions.NpcFactionEntries&lt;br&gt;TaskActivities.NpcType.NpcSpells&lt;br&gt;TaskActivities.NpcType.NpcSpells.NpcSpellsEntries&lt;br&gt;TaskActivities.NpcType.NpcTypesTint&lt;br&gt;TaskActivities.NpcType.Spawnentries&lt;br&gt;TaskActivities.NpcType.Spawnentries.Spawngroup&lt;br&gt;TaskActivities.NpcType.Spawnentries.Spawngroup.Spawn2&lt;br&gt;Tasksets
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTasks(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsTask>>> {
            const localVarAxiosArgs = await TaskApiAxiosParamCreator(configuration).listTasks(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates Task
         * @param {number} id Id
         * @param {ModelsTask} task Task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTask(id: number, task: ModelsTask, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsTask>>> {
            const localVarAxiosArgs = await TaskApiAxiosParamCreator(configuration).updateTask(id, task, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TaskApi - factory interface
 * @export
 */
export const TaskApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates Task
         * @param {ModelsTask} task Task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTask(task: ModelsTask, options?: any): AxiosPromise<Array<ModelsTask>> {
            return TaskApiFp(configuration).createTask(task, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes Task
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTask(id: number, options?: any): AxiosPromise<string> {
            return TaskApiFp(configuration).deleteTask(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Task
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;TaskActivities&lt;br&gt;TaskActivities.Goallists&lt;br&gt;TaskActivities.NpcType&lt;br&gt;TaskActivities.NpcType.AlternateCurrency&lt;br&gt;TaskActivities.NpcType.Merchantlists&lt;br&gt;TaskActivities.NpcType.NpcEmotes&lt;br&gt;TaskActivities.NpcType.NpcFactions&lt;br&gt;TaskActivities.NpcType.NpcFactions.NpcFactionEntries&lt;br&gt;TaskActivities.NpcType.NpcSpells&lt;br&gt;TaskActivities.NpcType.NpcSpells.NpcSpellsEntries&lt;br&gt;TaskActivities.NpcType.NpcTypesTint&lt;br&gt;TaskActivities.NpcType.Spawnentries&lt;br&gt;TaskActivities.NpcType.Spawnentries.Spawngroup&lt;br&gt;TaskActivities.NpcType.Spawnentries.Spawngroup.Spawn2&lt;br&gt;Tasksets
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsTask>> {
            return TaskApiFp(configuration).getTask(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists Tasks
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;TaskActivities&lt;br&gt;TaskActivities.Goallists&lt;br&gt;TaskActivities.NpcType&lt;br&gt;TaskActivities.NpcType.AlternateCurrency&lt;br&gt;TaskActivities.NpcType.Merchantlists&lt;br&gt;TaskActivities.NpcType.NpcEmotes&lt;br&gt;TaskActivities.NpcType.NpcFactions&lt;br&gt;TaskActivities.NpcType.NpcFactions.NpcFactionEntries&lt;br&gt;TaskActivities.NpcType.NpcSpells&lt;br&gt;TaskActivities.NpcType.NpcSpells.NpcSpellsEntries&lt;br&gt;TaskActivities.NpcType.NpcTypesTint&lt;br&gt;TaskActivities.NpcType.Spawnentries&lt;br&gt;TaskActivities.NpcType.Spawnentries.Spawngroup&lt;br&gt;TaskActivities.NpcType.Spawnentries.Spawngroup.Spawn2&lt;br&gt;Tasksets
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTasks(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsTask>> {
            return TaskApiFp(configuration).listTasks(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates Task
         * @param {number} id Id
         * @param {ModelsTask} task Task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTask(id: number, task: ModelsTask, options?: any): AxiosPromise<Array<ModelsTask>> {
            return TaskApiFp(configuration).updateTask(id, task, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createTask operation in TaskApi.
 * @export
 * @interface TaskApiCreateTaskRequest
 */
export interface TaskApiCreateTaskRequest {
    /**
     * Task
     * @type {ModelsTask}
     * @memberof TaskApiCreateTask
     */
    readonly task: ModelsTask
}

/**
 * Request parameters for deleteTask operation in TaskApi.
 * @export
 * @interface TaskApiDeleteTaskRequest
 */
export interface TaskApiDeleteTaskRequest {
    /**
     * Id
     * @type {number}
     * @memberof TaskApiDeleteTask
     */
    readonly id: number
}

/**
 * Request parameters for getTask operation in TaskApi.
 * @export
 * @interface TaskApiGetTaskRequest
 */
export interface TaskApiGetTaskRequest {
    /**
     * Id
     * @type {number}
     * @memberof TaskApiGetTask
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;TaskActivities&lt;br&gt;TaskActivities.Goallists&lt;br&gt;TaskActivities.NpcType&lt;br&gt;TaskActivities.NpcType.AlternateCurrency&lt;br&gt;TaskActivities.NpcType.Merchantlists&lt;br&gt;TaskActivities.NpcType.NpcEmotes&lt;br&gt;TaskActivities.NpcType.NpcFactions&lt;br&gt;TaskActivities.NpcType.NpcFactions.NpcFactionEntries&lt;br&gt;TaskActivities.NpcType.NpcSpells&lt;br&gt;TaskActivities.NpcType.NpcSpells.NpcSpellsEntries&lt;br&gt;TaskActivities.NpcType.NpcTypesTint&lt;br&gt;TaskActivities.NpcType.Spawnentries&lt;br&gt;TaskActivities.NpcType.Spawnentries.Spawngroup&lt;br&gt;TaskActivities.NpcType.Spawnentries.Spawngroup.Spawn2&lt;br&gt;Tasksets
     * @type {string}
     * @memberof TaskApiGetTask
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof TaskApiGetTask
     */
    readonly select?: string
}

/**
 * Request parameters for listTasks operation in TaskApi.
 * @export
 * @interface TaskApiListTasksRequest
 */
export interface TaskApiListTasksRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names &lt;h4&gt;Relationships&lt;/h4&gt;TaskActivities&lt;br&gt;TaskActivities.Goallists&lt;br&gt;TaskActivities.NpcType&lt;br&gt;TaskActivities.NpcType.AlternateCurrency&lt;br&gt;TaskActivities.NpcType.Merchantlists&lt;br&gt;TaskActivities.NpcType.NpcEmotes&lt;br&gt;TaskActivities.NpcType.NpcFactions&lt;br&gt;TaskActivities.NpcType.NpcFactions.NpcFactionEntries&lt;br&gt;TaskActivities.NpcType.NpcSpells&lt;br&gt;TaskActivities.NpcType.NpcSpells.NpcSpellsEntries&lt;br&gt;TaskActivities.NpcType.NpcTypesTint&lt;br&gt;TaskActivities.NpcType.Spawnentries&lt;br&gt;TaskActivities.NpcType.Spawnentries.Spawngroup&lt;br&gt;TaskActivities.NpcType.Spawnentries.Spawngroup.Spawn2&lt;br&gt;Tasksets
     * @type {string}
     * @memberof TaskApiListTasks
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof TaskApiListTasks
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof TaskApiListTasks
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof TaskApiListTasks
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof TaskApiListTasks
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof TaskApiListTasks
     */
    readonly select?: string
}

/**
 * Request parameters for updateTask operation in TaskApi.
 * @export
 * @interface TaskApiUpdateTaskRequest
 */
export interface TaskApiUpdateTaskRequest {
    /**
     * Id
     * @type {number}
     * @memberof TaskApiUpdateTask
     */
    readonly id: number

    /**
     * Task
     * @type {ModelsTask}
     * @memberof TaskApiUpdateTask
     */
    readonly task: ModelsTask
}

/**
 * TaskApi - object-oriented interface
 * @export
 * @class TaskApi
 * @extends {BaseAPI}
 */
export class TaskApi extends BaseAPI {
    /**
     * 
     * @summary Creates Task
     * @param {TaskApiCreateTaskRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public createTask(requestParameters: TaskApiCreateTaskRequest, options?: any) {
        return TaskApiFp(this.configuration).createTask(requestParameters.task, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes Task
     * @param {TaskApiDeleteTaskRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public deleteTask(requestParameters: TaskApiDeleteTaskRequest, options?: any) {
        return TaskApiFp(this.configuration).deleteTask(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Task
     * @param {TaskApiGetTaskRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public getTask(requestParameters: TaskApiGetTaskRequest, options?: any) {
        return TaskApiFp(this.configuration).getTask(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists Tasks
     * @param {TaskApiListTasksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public listTasks(requestParameters: TaskApiListTasksRequest = {}, options?: any) {
        return TaskApiFp(this.configuration).listTasks(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates Task
     * @param {TaskApiUpdateTaskRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public updateTask(requestParameters: TaskApiUpdateTaskRequest, options?: any) {
        return TaskApiFp(this.configuration).updateTask(requestParameters.id, requestParameters.task, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TasksetApi - axios parameter creator
 * @export
 */
export const TasksetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Taskset
         * @param {ModelsTaskset} taskset Taskset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaskset: async (taskset: ModelsTaskset, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskset' is not null or undefined
            if (taskset === null || taskset === undefined) {
                throw new RequiredError('taskset','Required parameter taskset was null or undefined when calling createTaskset.');
            }
            const localVarPath = `/taskset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof taskset !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(taskset !== undefined ? taskset : {})
                : (taskset || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes Taskset
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaskset: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteTaskset.');
            }
            const localVarPath = `/taskset/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Taskset
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskset: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getTaskset.');
            }
            const localVarPath = `/taskset/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists Tasksets
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTasksets: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/tasksets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates Taskset
         * @param {number} id Id
         * @param {ModelsTaskset} taskset Taskset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaskset: async (id: number, taskset: ModelsTaskset, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateTaskset.');
            }
            // verify required parameter 'taskset' is not null or undefined
            if (taskset === null || taskset === undefined) {
                throw new RequiredError('taskset','Required parameter taskset was null or undefined when calling updateTaskset.');
            }
            const localVarPath = `/taskset/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof taskset !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(taskset !== undefined ? taskset : {})
                : (taskset || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TasksetApi - functional programming interface
 * @export
 */
export const TasksetApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Taskset
         * @param {ModelsTaskset} taskset Taskset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTaskset(taskset: ModelsTaskset, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsTaskset>>> {
            const localVarAxiosArgs = await TasksetApiAxiosParamCreator(configuration).createTaskset(taskset, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes Taskset
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTaskset(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await TasksetApiAxiosParamCreator(configuration).deleteTaskset(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Taskset
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskset(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsTaskset>>> {
            const localVarAxiosArgs = await TasksetApiAxiosParamCreator(configuration).getTaskset(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists Tasksets
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTasksets(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsTaskset>>> {
            const localVarAxiosArgs = await TasksetApiAxiosParamCreator(configuration).listTasksets(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates Taskset
         * @param {number} id Id
         * @param {ModelsTaskset} taskset Taskset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTaskset(id: number, taskset: ModelsTaskset, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsTaskset>>> {
            const localVarAxiosArgs = await TasksetApiAxiosParamCreator(configuration).updateTaskset(id, taskset, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TasksetApi - factory interface
 * @export
 */
export const TasksetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates Taskset
         * @param {ModelsTaskset} taskset Taskset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaskset(taskset: ModelsTaskset, options?: any): AxiosPromise<Array<ModelsTaskset>> {
            return TasksetApiFp(configuration).createTaskset(taskset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes Taskset
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaskset(id: number, options?: any): AxiosPromise<string> {
            return TasksetApiFp(configuration).deleteTaskset(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Taskset
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskset(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsTaskset>> {
            return TasksetApiFp(configuration).getTaskset(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists Tasksets
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTasksets(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsTaskset>> {
            return TasksetApiFp(configuration).listTasksets(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates Taskset
         * @param {number} id Id
         * @param {ModelsTaskset} taskset Taskset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaskset(id: number, taskset: ModelsTaskset, options?: any): AxiosPromise<Array<ModelsTaskset>> {
            return TasksetApiFp(configuration).updateTaskset(id, taskset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createTaskset operation in TasksetApi.
 * @export
 * @interface TasksetApiCreateTasksetRequest
 */
export interface TasksetApiCreateTasksetRequest {
    /**
     * Taskset
     * @type {ModelsTaskset}
     * @memberof TasksetApiCreateTaskset
     */
    readonly taskset: ModelsTaskset
}

/**
 * Request parameters for deleteTaskset operation in TasksetApi.
 * @export
 * @interface TasksetApiDeleteTasksetRequest
 */
export interface TasksetApiDeleteTasksetRequest {
    /**
     * Id
     * @type {number}
     * @memberof TasksetApiDeleteTaskset
     */
    readonly id: number
}

/**
 * Request parameters for getTaskset operation in TasksetApi.
 * @export
 * @interface TasksetApiGetTasksetRequest
 */
export interface TasksetApiGetTasksetRequest {
    /**
     * Id
     * @type {number}
     * @memberof TasksetApiGetTaskset
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof TasksetApiGetTaskset
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof TasksetApiGetTaskset
     */
    readonly select?: string
}

/**
 * Request parameters for listTasksets operation in TasksetApi.
 * @export
 * @interface TasksetApiListTasksetsRequest
 */
export interface TasksetApiListTasksetsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof TasksetApiListTasksets
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof TasksetApiListTasksets
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof TasksetApiListTasksets
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof TasksetApiListTasksets
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof TasksetApiListTasksets
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof TasksetApiListTasksets
     */
    readonly select?: string
}

/**
 * Request parameters for updateTaskset operation in TasksetApi.
 * @export
 * @interface TasksetApiUpdateTasksetRequest
 */
export interface TasksetApiUpdateTasksetRequest {
    /**
     * Id
     * @type {number}
     * @memberof TasksetApiUpdateTaskset
     */
    readonly id: number

    /**
     * Taskset
     * @type {ModelsTaskset}
     * @memberof TasksetApiUpdateTaskset
     */
    readonly taskset: ModelsTaskset
}

/**
 * TasksetApi - object-oriented interface
 * @export
 * @class TasksetApi
 * @extends {BaseAPI}
 */
export class TasksetApi extends BaseAPI {
    /**
     * 
     * @summary Creates Taskset
     * @param {TasksetApiCreateTasksetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksetApi
     */
    public createTaskset(requestParameters: TasksetApiCreateTasksetRequest, options?: any) {
        return TasksetApiFp(this.configuration).createTaskset(requestParameters.taskset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes Taskset
     * @param {TasksetApiDeleteTasksetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksetApi
     */
    public deleteTaskset(requestParameters: TasksetApiDeleteTasksetRequest, options?: any) {
        return TasksetApiFp(this.configuration).deleteTaskset(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Taskset
     * @param {TasksetApiGetTasksetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksetApi
     */
    public getTaskset(requestParameters: TasksetApiGetTasksetRequest, options?: any) {
        return TasksetApiFp(this.configuration).getTaskset(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists Tasksets
     * @param {TasksetApiListTasksetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksetApi
     */
    public listTasksets(requestParameters: TasksetApiListTasksetsRequest = {}, options?: any) {
        return TasksetApiFp(this.configuration).listTasksets(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates Taskset
     * @param {TasksetApiUpdateTasksetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksetApi
     */
    public updateTaskset(requestParameters: TasksetApiUpdateTasksetRequest, options?: any) {
        return TasksetApiFp(this.configuration).updateTaskset(requestParameters.id, requestParameters.taskset, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TimerApi - axios parameter creator
 * @export
 */
export const TimerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Timer
         * @param {ModelsTimer} timer Timer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTimer: async (timer: ModelsTimer, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'timer' is not null or undefined
            if (timer === null || timer === undefined) {
                throw new RequiredError('timer','Required parameter timer was null or undefined when calling createTimer.');
            }
            const localVarPath = `/timer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof timer !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(timer !== undefined ? timer : {})
                : (timer || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes Timer
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTimer: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteTimer.');
            }
            const localVarPath = `/timer/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Timer
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimer: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getTimer.');
            }
            const localVarPath = `/timer/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists Timers
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTimers: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/timers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates Timer
         * @param {number} id Id
         * @param {ModelsTimer} timer Timer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTimer: async (id: number, timer: ModelsTimer, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateTimer.');
            }
            // verify required parameter 'timer' is not null or undefined
            if (timer === null || timer === undefined) {
                throw new RequiredError('timer','Required parameter timer was null or undefined when calling updateTimer.');
            }
            const localVarPath = `/timer/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof timer !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(timer !== undefined ? timer : {})
                : (timer || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TimerApi - functional programming interface
 * @export
 */
export const TimerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Timer
         * @param {ModelsTimer} timer Timer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTimer(timer: ModelsTimer, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsTimer>>> {
            const localVarAxiosArgs = await TimerApiAxiosParamCreator(configuration).createTimer(timer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes Timer
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTimer(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await TimerApiAxiosParamCreator(configuration).deleteTimer(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Timer
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTimer(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsTimer>>> {
            const localVarAxiosArgs = await TimerApiAxiosParamCreator(configuration).getTimer(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists Timers
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTimers(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsTimer>>> {
            const localVarAxiosArgs = await TimerApiAxiosParamCreator(configuration).listTimers(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates Timer
         * @param {number} id Id
         * @param {ModelsTimer} timer Timer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTimer(id: number, timer: ModelsTimer, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsTimer>>> {
            const localVarAxiosArgs = await TimerApiAxiosParamCreator(configuration).updateTimer(id, timer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TimerApi - factory interface
 * @export
 */
export const TimerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates Timer
         * @param {ModelsTimer} timer Timer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTimer(timer: ModelsTimer, options?: any): AxiosPromise<Array<ModelsTimer>> {
            return TimerApiFp(configuration).createTimer(timer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes Timer
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTimer(id: number, options?: any): AxiosPromise<string> {
            return TimerApiFp(configuration).deleteTimer(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Timer
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimer(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsTimer>> {
            return TimerApiFp(configuration).getTimer(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists Timers
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTimers(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsTimer>> {
            return TimerApiFp(configuration).listTimers(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates Timer
         * @param {number} id Id
         * @param {ModelsTimer} timer Timer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTimer(id: number, timer: ModelsTimer, options?: any): AxiosPromise<Array<ModelsTimer>> {
            return TimerApiFp(configuration).updateTimer(id, timer, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createTimer operation in TimerApi.
 * @export
 * @interface TimerApiCreateTimerRequest
 */
export interface TimerApiCreateTimerRequest {
    /**
     * Timer
     * @type {ModelsTimer}
     * @memberof TimerApiCreateTimer
     */
    readonly timer: ModelsTimer
}

/**
 * Request parameters for deleteTimer operation in TimerApi.
 * @export
 * @interface TimerApiDeleteTimerRequest
 */
export interface TimerApiDeleteTimerRequest {
    /**
     * Id
     * @type {number}
     * @memberof TimerApiDeleteTimer
     */
    readonly id: number
}

/**
 * Request parameters for getTimer operation in TimerApi.
 * @export
 * @interface TimerApiGetTimerRequest
 */
export interface TimerApiGetTimerRequest {
    /**
     * Id
     * @type {number}
     * @memberof TimerApiGetTimer
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof TimerApiGetTimer
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof TimerApiGetTimer
     */
    readonly select?: string
}

/**
 * Request parameters for listTimers operation in TimerApi.
 * @export
 * @interface TimerApiListTimersRequest
 */
export interface TimerApiListTimersRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof TimerApiListTimers
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof TimerApiListTimers
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof TimerApiListTimers
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof TimerApiListTimers
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof TimerApiListTimers
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof TimerApiListTimers
     */
    readonly select?: string
}

/**
 * Request parameters for updateTimer operation in TimerApi.
 * @export
 * @interface TimerApiUpdateTimerRequest
 */
export interface TimerApiUpdateTimerRequest {
    /**
     * Id
     * @type {number}
     * @memberof TimerApiUpdateTimer
     */
    readonly id: number

    /**
     * Timer
     * @type {ModelsTimer}
     * @memberof TimerApiUpdateTimer
     */
    readonly timer: ModelsTimer
}

/**
 * TimerApi - object-oriented interface
 * @export
 * @class TimerApi
 * @extends {BaseAPI}
 */
export class TimerApi extends BaseAPI {
    /**
     * 
     * @summary Creates Timer
     * @param {TimerApiCreateTimerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimerApi
     */
    public createTimer(requestParameters: TimerApiCreateTimerRequest, options?: any) {
        return TimerApiFp(this.configuration).createTimer(requestParameters.timer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes Timer
     * @param {TimerApiDeleteTimerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimerApi
     */
    public deleteTimer(requestParameters: TimerApiDeleteTimerRequest, options?: any) {
        return TimerApiFp(this.configuration).deleteTimer(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Timer
     * @param {TimerApiGetTimerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimerApi
     */
    public getTimer(requestParameters: TimerApiGetTimerRequest, options?: any) {
        return TimerApiFp(this.configuration).getTimer(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists Timers
     * @param {TimerApiListTimersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimerApi
     */
    public listTimers(requestParameters: TimerApiListTimersRequest = {}, options?: any) {
        return TimerApiFp(this.configuration).listTimers(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates Timer
     * @param {TimerApiUpdateTimerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimerApi
     */
    public updateTimer(requestParameters: TimerApiUpdateTimerRequest, options?: any) {
        return TimerApiFp(this.configuration).updateTimer(requestParameters.id, requestParameters.timer, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TitleApi - axios parameter creator
 * @export
 */
export const TitleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Title
         * @param {ModelsTitle} title Title
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTitle: async (title: ModelsTitle, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'title' is not null or undefined
            if (title === null || title === undefined) {
                throw new RequiredError('title','Required parameter title was null or undefined when calling createTitle.');
            }
            const localVarPath = `/title`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof title !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(title !== undefined ? title : {})
                : (title || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes Title
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTitle: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteTitle.');
            }
            const localVarPath = `/title/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Title
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTitle: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getTitle.');
            }
            const localVarPath = `/title/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists Titles
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTitles: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/titles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates Title
         * @param {number} id Id
         * @param {ModelsTitle} title Title
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTitle: async (id: number, title: ModelsTitle, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateTitle.');
            }
            // verify required parameter 'title' is not null or undefined
            if (title === null || title === undefined) {
                throw new RequiredError('title','Required parameter title was null or undefined when calling updateTitle.');
            }
            const localVarPath = `/title/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof title !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(title !== undefined ? title : {})
                : (title || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TitleApi - functional programming interface
 * @export
 */
export const TitleApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Title
         * @param {ModelsTitle} title Title
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTitle(title: ModelsTitle, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsTitle>>> {
            const localVarAxiosArgs = await TitleApiAxiosParamCreator(configuration).createTitle(title, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes Title
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTitle(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await TitleApiAxiosParamCreator(configuration).deleteTitle(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Title
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTitle(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsTitle>>> {
            const localVarAxiosArgs = await TitleApiAxiosParamCreator(configuration).getTitle(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists Titles
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTitles(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsTitle>>> {
            const localVarAxiosArgs = await TitleApiAxiosParamCreator(configuration).listTitles(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates Title
         * @param {number} id Id
         * @param {ModelsTitle} title Title
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTitle(id: number, title: ModelsTitle, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsTitle>>> {
            const localVarAxiosArgs = await TitleApiAxiosParamCreator(configuration).updateTitle(id, title, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TitleApi - factory interface
 * @export
 */
export const TitleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates Title
         * @param {ModelsTitle} title Title
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTitle(title: ModelsTitle, options?: any): AxiosPromise<Array<ModelsTitle>> {
            return TitleApiFp(configuration).createTitle(title, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes Title
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTitle(id: number, options?: any): AxiosPromise<string> {
            return TitleApiFp(configuration).deleteTitle(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Title
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTitle(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsTitle>> {
            return TitleApiFp(configuration).getTitle(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists Titles
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTitles(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsTitle>> {
            return TitleApiFp(configuration).listTitles(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates Title
         * @param {number} id Id
         * @param {ModelsTitle} title Title
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTitle(id: number, title: ModelsTitle, options?: any): AxiosPromise<Array<ModelsTitle>> {
            return TitleApiFp(configuration).updateTitle(id, title, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createTitle operation in TitleApi.
 * @export
 * @interface TitleApiCreateTitleRequest
 */
export interface TitleApiCreateTitleRequest {
    /**
     * Title
     * @type {ModelsTitle}
     * @memberof TitleApiCreateTitle
     */
    readonly title: ModelsTitle
}

/**
 * Request parameters for deleteTitle operation in TitleApi.
 * @export
 * @interface TitleApiDeleteTitleRequest
 */
export interface TitleApiDeleteTitleRequest {
    /**
     * Id
     * @type {number}
     * @memberof TitleApiDeleteTitle
     */
    readonly id: number
}

/**
 * Request parameters for getTitle operation in TitleApi.
 * @export
 * @interface TitleApiGetTitleRequest
 */
export interface TitleApiGetTitleRequest {
    /**
     * Id
     * @type {number}
     * @memberof TitleApiGetTitle
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof TitleApiGetTitle
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof TitleApiGetTitle
     */
    readonly select?: string
}

/**
 * Request parameters for listTitles operation in TitleApi.
 * @export
 * @interface TitleApiListTitlesRequest
 */
export interface TitleApiListTitlesRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof TitleApiListTitles
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof TitleApiListTitles
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof TitleApiListTitles
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof TitleApiListTitles
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof TitleApiListTitles
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof TitleApiListTitles
     */
    readonly select?: string
}

/**
 * Request parameters for updateTitle operation in TitleApi.
 * @export
 * @interface TitleApiUpdateTitleRequest
 */
export interface TitleApiUpdateTitleRequest {
    /**
     * Id
     * @type {number}
     * @memberof TitleApiUpdateTitle
     */
    readonly id: number

    /**
     * Title
     * @type {ModelsTitle}
     * @memberof TitleApiUpdateTitle
     */
    readonly title: ModelsTitle
}

/**
 * TitleApi - object-oriented interface
 * @export
 * @class TitleApi
 * @extends {BaseAPI}
 */
export class TitleApi extends BaseAPI {
    /**
     * 
     * @summary Creates Title
     * @param {TitleApiCreateTitleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TitleApi
     */
    public createTitle(requestParameters: TitleApiCreateTitleRequest, options?: any) {
        return TitleApiFp(this.configuration).createTitle(requestParameters.title, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes Title
     * @param {TitleApiDeleteTitleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TitleApi
     */
    public deleteTitle(requestParameters: TitleApiDeleteTitleRequest, options?: any) {
        return TitleApiFp(this.configuration).deleteTitle(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Title
     * @param {TitleApiGetTitleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TitleApi
     */
    public getTitle(requestParameters: TitleApiGetTitleRequest, options?: any) {
        return TitleApiFp(this.configuration).getTitle(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists Titles
     * @param {TitleApiListTitlesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TitleApi
     */
    public listTitles(requestParameters: TitleApiListTitlesRequest = {}, options?: any) {
        return TitleApiFp(this.configuration).listTitles(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates Title
     * @param {TitleApiUpdateTitleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TitleApi
     */
    public updateTitle(requestParameters: TitleApiUpdateTitleRequest, options?: any) {
        return TitleApiFp(this.configuration).updateTitle(requestParameters.id, requestParameters.title, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TradeskillRecipeApi - axios parameter creator
 * @export
 */
export const TradeskillRecipeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates TradeskillRecipe
         * @param {ModelsTradeskillRecipe} tradeskillRecipe TradeskillRecipe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTradeskillRecipe: async (tradeskillRecipe: ModelsTradeskillRecipe, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tradeskillRecipe' is not null or undefined
            if (tradeskillRecipe === null || tradeskillRecipe === undefined) {
                throw new RequiredError('tradeskillRecipe','Required parameter tradeskillRecipe was null or undefined when calling createTradeskillRecipe.');
            }
            const localVarPath = `/tradeskill_recipe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof tradeskillRecipe !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(tradeskillRecipe !== undefined ? tradeskillRecipe : {})
                : (tradeskillRecipe || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes TradeskillRecipe
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTradeskillRecipe: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteTradeskillRecipe.');
            }
            const localVarPath = `/tradeskill_recipe/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets TradeskillRecipe
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTradeskillRecipe: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getTradeskillRecipe.');
            }
            const localVarPath = `/tradeskill_recipe/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists TradeskillRecipes
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTradeskillRecipes: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/tradeskill_recipes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates TradeskillRecipe
         * @param {number} id Id
         * @param {ModelsTradeskillRecipe} tradeskillRecipe TradeskillRecipe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTradeskillRecipe: async (id: number, tradeskillRecipe: ModelsTradeskillRecipe, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateTradeskillRecipe.');
            }
            // verify required parameter 'tradeskillRecipe' is not null or undefined
            if (tradeskillRecipe === null || tradeskillRecipe === undefined) {
                throw new RequiredError('tradeskillRecipe','Required parameter tradeskillRecipe was null or undefined when calling updateTradeskillRecipe.');
            }
            const localVarPath = `/tradeskill_recipe/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof tradeskillRecipe !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(tradeskillRecipe !== undefined ? tradeskillRecipe : {})
                : (tradeskillRecipe || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TradeskillRecipeApi - functional programming interface
 * @export
 */
export const TradeskillRecipeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates TradeskillRecipe
         * @param {ModelsTradeskillRecipe} tradeskillRecipe TradeskillRecipe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTradeskillRecipe(tradeskillRecipe: ModelsTradeskillRecipe, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsTradeskillRecipe>>> {
            const localVarAxiosArgs = await TradeskillRecipeApiAxiosParamCreator(configuration).createTradeskillRecipe(tradeskillRecipe, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes TradeskillRecipe
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTradeskillRecipe(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await TradeskillRecipeApiAxiosParamCreator(configuration).deleteTradeskillRecipe(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets TradeskillRecipe
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTradeskillRecipe(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsTradeskillRecipe>>> {
            const localVarAxiosArgs = await TradeskillRecipeApiAxiosParamCreator(configuration).getTradeskillRecipe(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists TradeskillRecipes
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTradeskillRecipes(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsTradeskillRecipe>>> {
            const localVarAxiosArgs = await TradeskillRecipeApiAxiosParamCreator(configuration).listTradeskillRecipes(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates TradeskillRecipe
         * @param {number} id Id
         * @param {ModelsTradeskillRecipe} tradeskillRecipe TradeskillRecipe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTradeskillRecipe(id: number, tradeskillRecipe: ModelsTradeskillRecipe, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsTradeskillRecipe>>> {
            const localVarAxiosArgs = await TradeskillRecipeApiAxiosParamCreator(configuration).updateTradeskillRecipe(id, tradeskillRecipe, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TradeskillRecipeApi - factory interface
 * @export
 */
export const TradeskillRecipeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates TradeskillRecipe
         * @param {ModelsTradeskillRecipe} tradeskillRecipe TradeskillRecipe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTradeskillRecipe(tradeskillRecipe: ModelsTradeskillRecipe, options?: any): AxiosPromise<Array<ModelsTradeskillRecipe>> {
            return TradeskillRecipeApiFp(configuration).createTradeskillRecipe(tradeskillRecipe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes TradeskillRecipe
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTradeskillRecipe(id: number, options?: any): AxiosPromise<string> {
            return TradeskillRecipeApiFp(configuration).deleteTradeskillRecipe(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets TradeskillRecipe
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTradeskillRecipe(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsTradeskillRecipe>> {
            return TradeskillRecipeApiFp(configuration).getTradeskillRecipe(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists TradeskillRecipes
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTradeskillRecipes(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsTradeskillRecipe>> {
            return TradeskillRecipeApiFp(configuration).listTradeskillRecipes(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates TradeskillRecipe
         * @param {number} id Id
         * @param {ModelsTradeskillRecipe} tradeskillRecipe TradeskillRecipe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTradeskillRecipe(id: number, tradeskillRecipe: ModelsTradeskillRecipe, options?: any): AxiosPromise<Array<ModelsTradeskillRecipe>> {
            return TradeskillRecipeApiFp(configuration).updateTradeskillRecipe(id, tradeskillRecipe, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createTradeskillRecipe operation in TradeskillRecipeApi.
 * @export
 * @interface TradeskillRecipeApiCreateTradeskillRecipeRequest
 */
export interface TradeskillRecipeApiCreateTradeskillRecipeRequest {
    /**
     * TradeskillRecipe
     * @type {ModelsTradeskillRecipe}
     * @memberof TradeskillRecipeApiCreateTradeskillRecipe
     */
    readonly tradeskillRecipe: ModelsTradeskillRecipe
}

/**
 * Request parameters for deleteTradeskillRecipe operation in TradeskillRecipeApi.
 * @export
 * @interface TradeskillRecipeApiDeleteTradeskillRecipeRequest
 */
export interface TradeskillRecipeApiDeleteTradeskillRecipeRequest {
    /**
     * Id
     * @type {number}
     * @memberof TradeskillRecipeApiDeleteTradeskillRecipe
     */
    readonly id: number
}

/**
 * Request parameters for getTradeskillRecipe operation in TradeskillRecipeApi.
 * @export
 * @interface TradeskillRecipeApiGetTradeskillRecipeRequest
 */
export interface TradeskillRecipeApiGetTradeskillRecipeRequest {
    /**
     * Id
     * @type {number}
     * @memberof TradeskillRecipeApiGetTradeskillRecipe
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof TradeskillRecipeApiGetTradeskillRecipe
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof TradeskillRecipeApiGetTradeskillRecipe
     */
    readonly select?: string
}

/**
 * Request parameters for listTradeskillRecipes operation in TradeskillRecipeApi.
 * @export
 * @interface TradeskillRecipeApiListTradeskillRecipesRequest
 */
export interface TradeskillRecipeApiListTradeskillRecipesRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof TradeskillRecipeApiListTradeskillRecipes
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof TradeskillRecipeApiListTradeskillRecipes
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof TradeskillRecipeApiListTradeskillRecipes
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof TradeskillRecipeApiListTradeskillRecipes
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof TradeskillRecipeApiListTradeskillRecipes
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof TradeskillRecipeApiListTradeskillRecipes
     */
    readonly select?: string
}

/**
 * Request parameters for updateTradeskillRecipe operation in TradeskillRecipeApi.
 * @export
 * @interface TradeskillRecipeApiUpdateTradeskillRecipeRequest
 */
export interface TradeskillRecipeApiUpdateTradeskillRecipeRequest {
    /**
     * Id
     * @type {number}
     * @memberof TradeskillRecipeApiUpdateTradeskillRecipe
     */
    readonly id: number

    /**
     * TradeskillRecipe
     * @type {ModelsTradeskillRecipe}
     * @memberof TradeskillRecipeApiUpdateTradeskillRecipe
     */
    readonly tradeskillRecipe: ModelsTradeskillRecipe
}

/**
 * TradeskillRecipeApi - object-oriented interface
 * @export
 * @class TradeskillRecipeApi
 * @extends {BaseAPI}
 */
export class TradeskillRecipeApi extends BaseAPI {
    /**
     * 
     * @summary Creates TradeskillRecipe
     * @param {TradeskillRecipeApiCreateTradeskillRecipeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeskillRecipeApi
     */
    public createTradeskillRecipe(requestParameters: TradeskillRecipeApiCreateTradeskillRecipeRequest, options?: any) {
        return TradeskillRecipeApiFp(this.configuration).createTradeskillRecipe(requestParameters.tradeskillRecipe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes TradeskillRecipe
     * @param {TradeskillRecipeApiDeleteTradeskillRecipeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeskillRecipeApi
     */
    public deleteTradeskillRecipe(requestParameters: TradeskillRecipeApiDeleteTradeskillRecipeRequest, options?: any) {
        return TradeskillRecipeApiFp(this.configuration).deleteTradeskillRecipe(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets TradeskillRecipe
     * @param {TradeskillRecipeApiGetTradeskillRecipeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeskillRecipeApi
     */
    public getTradeskillRecipe(requestParameters: TradeskillRecipeApiGetTradeskillRecipeRequest, options?: any) {
        return TradeskillRecipeApiFp(this.configuration).getTradeskillRecipe(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists TradeskillRecipes
     * @param {TradeskillRecipeApiListTradeskillRecipesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeskillRecipeApi
     */
    public listTradeskillRecipes(requestParameters: TradeskillRecipeApiListTradeskillRecipesRequest = {}, options?: any) {
        return TradeskillRecipeApiFp(this.configuration).listTradeskillRecipes(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates TradeskillRecipe
     * @param {TradeskillRecipeApiUpdateTradeskillRecipeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeskillRecipeApi
     */
    public updateTradeskillRecipe(requestParameters: TradeskillRecipeApiUpdateTradeskillRecipeRequest, options?: any) {
        return TradeskillRecipeApiFp(this.configuration).updateTradeskillRecipe(requestParameters.id, requestParameters.tradeskillRecipe, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TradeskillRecipeEntryApi - axios parameter creator
 * @export
 */
export const TradeskillRecipeEntryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates TradeskillRecipeEntry
         * @param {ModelsTradeskillRecipeEntry} tradeskillRecipeEntry TradeskillRecipeEntry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTradeskillRecipeEntry: async (tradeskillRecipeEntry: ModelsTradeskillRecipeEntry, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tradeskillRecipeEntry' is not null or undefined
            if (tradeskillRecipeEntry === null || tradeskillRecipeEntry === undefined) {
                throw new RequiredError('tradeskillRecipeEntry','Required parameter tradeskillRecipeEntry was null or undefined when calling createTradeskillRecipeEntry.');
            }
            const localVarPath = `/tradeskill_recipe_entry`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof tradeskillRecipeEntry !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(tradeskillRecipeEntry !== undefined ? tradeskillRecipeEntry : {})
                : (tradeskillRecipeEntry || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes TradeskillRecipeEntry
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTradeskillRecipeEntry: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteTradeskillRecipeEntry.');
            }
            const localVarPath = `/tradeskill_recipe_entry/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets TradeskillRecipeEntry
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTradeskillRecipeEntry: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getTradeskillRecipeEntry.');
            }
            const localVarPath = `/tradeskill_recipe_entry/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists TradeskillRecipeEntries
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTradeskillRecipeEntries: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/tradeskill_recipe_entries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates TradeskillRecipeEntry
         * @param {number} id Id
         * @param {ModelsTradeskillRecipeEntry} tradeskillRecipeEntry TradeskillRecipeEntry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTradeskillRecipeEntry: async (id: number, tradeskillRecipeEntry: ModelsTradeskillRecipeEntry, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateTradeskillRecipeEntry.');
            }
            // verify required parameter 'tradeskillRecipeEntry' is not null or undefined
            if (tradeskillRecipeEntry === null || tradeskillRecipeEntry === undefined) {
                throw new RequiredError('tradeskillRecipeEntry','Required parameter tradeskillRecipeEntry was null or undefined when calling updateTradeskillRecipeEntry.');
            }
            const localVarPath = `/tradeskill_recipe_entry/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof tradeskillRecipeEntry !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(tradeskillRecipeEntry !== undefined ? tradeskillRecipeEntry : {})
                : (tradeskillRecipeEntry || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TradeskillRecipeEntryApi - functional programming interface
 * @export
 */
export const TradeskillRecipeEntryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates TradeskillRecipeEntry
         * @param {ModelsTradeskillRecipeEntry} tradeskillRecipeEntry TradeskillRecipeEntry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTradeskillRecipeEntry(tradeskillRecipeEntry: ModelsTradeskillRecipeEntry, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsTradeskillRecipeEntry>>> {
            const localVarAxiosArgs = await TradeskillRecipeEntryApiAxiosParamCreator(configuration).createTradeskillRecipeEntry(tradeskillRecipeEntry, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes TradeskillRecipeEntry
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTradeskillRecipeEntry(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await TradeskillRecipeEntryApiAxiosParamCreator(configuration).deleteTradeskillRecipeEntry(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets TradeskillRecipeEntry
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTradeskillRecipeEntry(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsTradeskillRecipeEntry>>> {
            const localVarAxiosArgs = await TradeskillRecipeEntryApiAxiosParamCreator(configuration).getTradeskillRecipeEntry(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists TradeskillRecipeEntries
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTradeskillRecipeEntries(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsTradeskillRecipeEntry>>> {
            const localVarAxiosArgs = await TradeskillRecipeEntryApiAxiosParamCreator(configuration).listTradeskillRecipeEntries(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates TradeskillRecipeEntry
         * @param {number} id Id
         * @param {ModelsTradeskillRecipeEntry} tradeskillRecipeEntry TradeskillRecipeEntry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTradeskillRecipeEntry(id: number, tradeskillRecipeEntry: ModelsTradeskillRecipeEntry, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsTradeskillRecipeEntry>>> {
            const localVarAxiosArgs = await TradeskillRecipeEntryApiAxiosParamCreator(configuration).updateTradeskillRecipeEntry(id, tradeskillRecipeEntry, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TradeskillRecipeEntryApi - factory interface
 * @export
 */
export const TradeskillRecipeEntryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates TradeskillRecipeEntry
         * @param {ModelsTradeskillRecipeEntry} tradeskillRecipeEntry TradeskillRecipeEntry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTradeskillRecipeEntry(tradeskillRecipeEntry: ModelsTradeskillRecipeEntry, options?: any): AxiosPromise<Array<ModelsTradeskillRecipeEntry>> {
            return TradeskillRecipeEntryApiFp(configuration).createTradeskillRecipeEntry(tradeskillRecipeEntry, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes TradeskillRecipeEntry
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTradeskillRecipeEntry(id: number, options?: any): AxiosPromise<string> {
            return TradeskillRecipeEntryApiFp(configuration).deleteTradeskillRecipeEntry(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets TradeskillRecipeEntry
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTradeskillRecipeEntry(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsTradeskillRecipeEntry>> {
            return TradeskillRecipeEntryApiFp(configuration).getTradeskillRecipeEntry(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists TradeskillRecipeEntries
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTradeskillRecipeEntries(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsTradeskillRecipeEntry>> {
            return TradeskillRecipeEntryApiFp(configuration).listTradeskillRecipeEntries(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates TradeskillRecipeEntry
         * @param {number} id Id
         * @param {ModelsTradeskillRecipeEntry} tradeskillRecipeEntry TradeskillRecipeEntry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTradeskillRecipeEntry(id: number, tradeskillRecipeEntry: ModelsTradeskillRecipeEntry, options?: any): AxiosPromise<Array<ModelsTradeskillRecipeEntry>> {
            return TradeskillRecipeEntryApiFp(configuration).updateTradeskillRecipeEntry(id, tradeskillRecipeEntry, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createTradeskillRecipeEntry operation in TradeskillRecipeEntryApi.
 * @export
 * @interface TradeskillRecipeEntryApiCreateTradeskillRecipeEntryRequest
 */
export interface TradeskillRecipeEntryApiCreateTradeskillRecipeEntryRequest {
    /**
     * TradeskillRecipeEntry
     * @type {ModelsTradeskillRecipeEntry}
     * @memberof TradeskillRecipeEntryApiCreateTradeskillRecipeEntry
     */
    readonly tradeskillRecipeEntry: ModelsTradeskillRecipeEntry
}

/**
 * Request parameters for deleteTradeskillRecipeEntry operation in TradeskillRecipeEntryApi.
 * @export
 * @interface TradeskillRecipeEntryApiDeleteTradeskillRecipeEntryRequest
 */
export interface TradeskillRecipeEntryApiDeleteTradeskillRecipeEntryRequest {
    /**
     * Id
     * @type {number}
     * @memberof TradeskillRecipeEntryApiDeleteTradeskillRecipeEntry
     */
    readonly id: number
}

/**
 * Request parameters for getTradeskillRecipeEntry operation in TradeskillRecipeEntryApi.
 * @export
 * @interface TradeskillRecipeEntryApiGetTradeskillRecipeEntryRequest
 */
export interface TradeskillRecipeEntryApiGetTradeskillRecipeEntryRequest {
    /**
     * Id
     * @type {number}
     * @memberof TradeskillRecipeEntryApiGetTradeskillRecipeEntry
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof TradeskillRecipeEntryApiGetTradeskillRecipeEntry
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof TradeskillRecipeEntryApiGetTradeskillRecipeEntry
     */
    readonly select?: string
}

/**
 * Request parameters for listTradeskillRecipeEntries operation in TradeskillRecipeEntryApi.
 * @export
 * @interface TradeskillRecipeEntryApiListTradeskillRecipeEntriesRequest
 */
export interface TradeskillRecipeEntryApiListTradeskillRecipeEntriesRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof TradeskillRecipeEntryApiListTradeskillRecipeEntries
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof TradeskillRecipeEntryApiListTradeskillRecipeEntries
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof TradeskillRecipeEntryApiListTradeskillRecipeEntries
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof TradeskillRecipeEntryApiListTradeskillRecipeEntries
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof TradeskillRecipeEntryApiListTradeskillRecipeEntries
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof TradeskillRecipeEntryApiListTradeskillRecipeEntries
     */
    readonly select?: string
}

/**
 * Request parameters for updateTradeskillRecipeEntry operation in TradeskillRecipeEntryApi.
 * @export
 * @interface TradeskillRecipeEntryApiUpdateTradeskillRecipeEntryRequest
 */
export interface TradeskillRecipeEntryApiUpdateTradeskillRecipeEntryRequest {
    /**
     * Id
     * @type {number}
     * @memberof TradeskillRecipeEntryApiUpdateTradeskillRecipeEntry
     */
    readonly id: number

    /**
     * TradeskillRecipeEntry
     * @type {ModelsTradeskillRecipeEntry}
     * @memberof TradeskillRecipeEntryApiUpdateTradeskillRecipeEntry
     */
    readonly tradeskillRecipeEntry: ModelsTradeskillRecipeEntry
}

/**
 * TradeskillRecipeEntryApi - object-oriented interface
 * @export
 * @class TradeskillRecipeEntryApi
 * @extends {BaseAPI}
 */
export class TradeskillRecipeEntryApi extends BaseAPI {
    /**
     * 
     * @summary Creates TradeskillRecipeEntry
     * @param {TradeskillRecipeEntryApiCreateTradeskillRecipeEntryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeskillRecipeEntryApi
     */
    public createTradeskillRecipeEntry(requestParameters: TradeskillRecipeEntryApiCreateTradeskillRecipeEntryRequest, options?: any) {
        return TradeskillRecipeEntryApiFp(this.configuration).createTradeskillRecipeEntry(requestParameters.tradeskillRecipeEntry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes TradeskillRecipeEntry
     * @param {TradeskillRecipeEntryApiDeleteTradeskillRecipeEntryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeskillRecipeEntryApi
     */
    public deleteTradeskillRecipeEntry(requestParameters: TradeskillRecipeEntryApiDeleteTradeskillRecipeEntryRequest, options?: any) {
        return TradeskillRecipeEntryApiFp(this.configuration).deleteTradeskillRecipeEntry(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets TradeskillRecipeEntry
     * @param {TradeskillRecipeEntryApiGetTradeskillRecipeEntryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeskillRecipeEntryApi
     */
    public getTradeskillRecipeEntry(requestParameters: TradeskillRecipeEntryApiGetTradeskillRecipeEntryRequest, options?: any) {
        return TradeskillRecipeEntryApiFp(this.configuration).getTradeskillRecipeEntry(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists TradeskillRecipeEntries
     * @param {TradeskillRecipeEntryApiListTradeskillRecipeEntriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeskillRecipeEntryApi
     */
    public listTradeskillRecipeEntries(requestParameters: TradeskillRecipeEntryApiListTradeskillRecipeEntriesRequest = {}, options?: any) {
        return TradeskillRecipeEntryApiFp(this.configuration).listTradeskillRecipeEntries(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates TradeskillRecipeEntry
     * @param {TradeskillRecipeEntryApiUpdateTradeskillRecipeEntryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeskillRecipeEntryApi
     */
    public updateTradeskillRecipeEntry(requestParameters: TradeskillRecipeEntryApiUpdateTradeskillRecipeEntryRequest, options?: any) {
        return TradeskillRecipeEntryApiFp(this.configuration).updateTradeskillRecipeEntry(requestParameters.id, requestParameters.tradeskillRecipeEntry, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TrapApi - axios parameter creator
 * @export
 */
export const TrapApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Trap
         * @param {ModelsTrap} trap Trap
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrap: async (trap: ModelsTrap, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'trap' is not null or undefined
            if (trap === null || trap === undefined) {
                throw new RequiredError('trap','Required parameter trap was null or undefined when calling createTrap.');
            }
            const localVarPath = `/trap`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof trap !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(trap !== undefined ? trap : {})
                : (trap || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes Trap
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTrap: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteTrap.');
            }
            const localVarPath = `/trap/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Trap
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrap: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getTrap.');
            }
            const localVarPath = `/trap/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists Traps
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTraps: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/traps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates Trap
         * @param {number} id Id
         * @param {ModelsTrap} trap Trap
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTrap: async (id: number, trap: ModelsTrap, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateTrap.');
            }
            // verify required parameter 'trap' is not null or undefined
            if (trap === null || trap === undefined) {
                throw new RequiredError('trap','Required parameter trap was null or undefined when calling updateTrap.');
            }
            const localVarPath = `/trap/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof trap !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(trap !== undefined ? trap : {})
                : (trap || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TrapApi - functional programming interface
 * @export
 */
export const TrapApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Trap
         * @param {ModelsTrap} trap Trap
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTrap(trap: ModelsTrap, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsTrap>>> {
            const localVarAxiosArgs = await TrapApiAxiosParamCreator(configuration).createTrap(trap, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes Trap
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTrap(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await TrapApiAxiosParamCreator(configuration).deleteTrap(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Trap
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrap(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsTrap>>> {
            const localVarAxiosArgs = await TrapApiAxiosParamCreator(configuration).getTrap(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists Traps
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTraps(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsTrap>>> {
            const localVarAxiosArgs = await TrapApiAxiosParamCreator(configuration).listTraps(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates Trap
         * @param {number} id Id
         * @param {ModelsTrap} trap Trap
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTrap(id: number, trap: ModelsTrap, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsTrap>>> {
            const localVarAxiosArgs = await TrapApiAxiosParamCreator(configuration).updateTrap(id, trap, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TrapApi - factory interface
 * @export
 */
export const TrapApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates Trap
         * @param {ModelsTrap} trap Trap
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrap(trap: ModelsTrap, options?: any): AxiosPromise<Array<ModelsTrap>> {
            return TrapApiFp(configuration).createTrap(trap, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes Trap
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTrap(id: number, options?: any): AxiosPromise<string> {
            return TrapApiFp(configuration).deleteTrap(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Trap
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrap(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsTrap>> {
            return TrapApiFp(configuration).getTrap(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists Traps
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTraps(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsTrap>> {
            return TrapApiFp(configuration).listTraps(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates Trap
         * @param {number} id Id
         * @param {ModelsTrap} trap Trap
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTrap(id: number, trap: ModelsTrap, options?: any): AxiosPromise<Array<ModelsTrap>> {
            return TrapApiFp(configuration).updateTrap(id, trap, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createTrap operation in TrapApi.
 * @export
 * @interface TrapApiCreateTrapRequest
 */
export interface TrapApiCreateTrapRequest {
    /**
     * Trap
     * @type {ModelsTrap}
     * @memberof TrapApiCreateTrap
     */
    readonly trap: ModelsTrap
}

/**
 * Request parameters for deleteTrap operation in TrapApi.
 * @export
 * @interface TrapApiDeleteTrapRequest
 */
export interface TrapApiDeleteTrapRequest {
    /**
     * Id
     * @type {number}
     * @memberof TrapApiDeleteTrap
     */
    readonly id: number
}

/**
 * Request parameters for getTrap operation in TrapApi.
 * @export
 * @interface TrapApiGetTrapRequest
 */
export interface TrapApiGetTrapRequest {
    /**
     * Id
     * @type {number}
     * @memberof TrapApiGetTrap
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof TrapApiGetTrap
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof TrapApiGetTrap
     */
    readonly select?: string
}

/**
 * Request parameters for listTraps operation in TrapApi.
 * @export
 * @interface TrapApiListTrapsRequest
 */
export interface TrapApiListTrapsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof TrapApiListTraps
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof TrapApiListTraps
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof TrapApiListTraps
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof TrapApiListTraps
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof TrapApiListTraps
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof TrapApiListTraps
     */
    readonly select?: string
}

/**
 * Request parameters for updateTrap operation in TrapApi.
 * @export
 * @interface TrapApiUpdateTrapRequest
 */
export interface TrapApiUpdateTrapRequest {
    /**
     * Id
     * @type {number}
     * @memberof TrapApiUpdateTrap
     */
    readonly id: number

    /**
     * Trap
     * @type {ModelsTrap}
     * @memberof TrapApiUpdateTrap
     */
    readonly trap: ModelsTrap
}

/**
 * TrapApi - object-oriented interface
 * @export
 * @class TrapApi
 * @extends {BaseAPI}
 */
export class TrapApi extends BaseAPI {
    /**
     * 
     * @summary Creates Trap
     * @param {TrapApiCreateTrapRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrapApi
     */
    public createTrap(requestParameters: TrapApiCreateTrapRequest, options?: any) {
        return TrapApiFp(this.configuration).createTrap(requestParameters.trap, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes Trap
     * @param {TrapApiDeleteTrapRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrapApi
     */
    public deleteTrap(requestParameters: TrapApiDeleteTrapRequest, options?: any) {
        return TrapApiFp(this.configuration).deleteTrap(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Trap
     * @param {TrapApiGetTrapRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrapApi
     */
    public getTrap(requestParameters: TrapApiGetTrapRequest, options?: any) {
        return TrapApiFp(this.configuration).getTrap(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists Traps
     * @param {TrapApiListTrapsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrapApi
     */
    public listTraps(requestParameters: TrapApiListTrapsRequest = {}, options?: any) {
        return TrapApiFp(this.configuration).listTraps(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates Trap
     * @param {TrapApiUpdateTrapRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrapApi
     */
    public updateTrap(requestParameters: TrapApiUpdateTrapRequest, options?: any) {
        return TrapApiFp(this.configuration).updateTrap(requestParameters.id, requestParameters.trap, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TributeApi - axios parameter creator
 * @export
 */
export const TributeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Tribute
         * @param {ModelsTribute} tribute Tribute
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTribute: async (tribute: ModelsTribute, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tribute' is not null or undefined
            if (tribute === null || tribute === undefined) {
                throw new RequiredError('tribute','Required parameter tribute was null or undefined when calling createTribute.');
            }
            const localVarPath = `/tribute`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof tribute !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(tribute !== undefined ? tribute : {})
                : (tribute || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes Tribute
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTribute: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteTribute.');
            }
            const localVarPath = `/tribute/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Tribute
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTribute: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getTribute.');
            }
            const localVarPath = `/tribute/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists Tributes
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTributes: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/tributes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates Tribute
         * @param {number} id Id
         * @param {ModelsTribute} tribute Tribute
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTribute: async (id: number, tribute: ModelsTribute, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateTribute.');
            }
            // verify required parameter 'tribute' is not null or undefined
            if (tribute === null || tribute === undefined) {
                throw new RequiredError('tribute','Required parameter tribute was null or undefined when calling updateTribute.');
            }
            const localVarPath = `/tribute/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof tribute !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(tribute !== undefined ? tribute : {})
                : (tribute || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TributeApi - functional programming interface
 * @export
 */
export const TributeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Tribute
         * @param {ModelsTribute} tribute Tribute
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTribute(tribute: ModelsTribute, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsTribute>>> {
            const localVarAxiosArgs = await TributeApiAxiosParamCreator(configuration).createTribute(tribute, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes Tribute
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTribute(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await TributeApiAxiosParamCreator(configuration).deleteTribute(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Tribute
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTribute(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsTribute>>> {
            const localVarAxiosArgs = await TributeApiAxiosParamCreator(configuration).getTribute(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists Tributes
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTributes(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsTribute>>> {
            const localVarAxiosArgs = await TributeApiAxiosParamCreator(configuration).listTributes(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates Tribute
         * @param {number} id Id
         * @param {ModelsTribute} tribute Tribute
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTribute(id: number, tribute: ModelsTribute, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsTribute>>> {
            const localVarAxiosArgs = await TributeApiAxiosParamCreator(configuration).updateTribute(id, tribute, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TributeApi - factory interface
 * @export
 */
export const TributeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates Tribute
         * @param {ModelsTribute} tribute Tribute
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTribute(tribute: ModelsTribute, options?: any): AxiosPromise<Array<ModelsTribute>> {
            return TributeApiFp(configuration).createTribute(tribute, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes Tribute
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTribute(id: number, options?: any): AxiosPromise<string> {
            return TributeApiFp(configuration).deleteTribute(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Tribute
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTribute(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsTribute>> {
            return TributeApiFp(configuration).getTribute(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists Tributes
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTributes(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsTribute>> {
            return TributeApiFp(configuration).listTributes(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates Tribute
         * @param {number} id Id
         * @param {ModelsTribute} tribute Tribute
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTribute(id: number, tribute: ModelsTribute, options?: any): AxiosPromise<Array<ModelsTribute>> {
            return TributeApiFp(configuration).updateTribute(id, tribute, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createTribute operation in TributeApi.
 * @export
 * @interface TributeApiCreateTributeRequest
 */
export interface TributeApiCreateTributeRequest {
    /**
     * Tribute
     * @type {ModelsTribute}
     * @memberof TributeApiCreateTribute
     */
    readonly tribute: ModelsTribute
}

/**
 * Request parameters for deleteTribute operation in TributeApi.
 * @export
 * @interface TributeApiDeleteTributeRequest
 */
export interface TributeApiDeleteTributeRequest {
    /**
     * Id
     * @type {number}
     * @memberof TributeApiDeleteTribute
     */
    readonly id: number
}

/**
 * Request parameters for getTribute operation in TributeApi.
 * @export
 * @interface TributeApiGetTributeRequest
 */
export interface TributeApiGetTributeRequest {
    /**
     * Id
     * @type {number}
     * @memberof TributeApiGetTribute
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof TributeApiGetTribute
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof TributeApiGetTribute
     */
    readonly select?: string
}

/**
 * Request parameters for listTributes operation in TributeApi.
 * @export
 * @interface TributeApiListTributesRequest
 */
export interface TributeApiListTributesRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof TributeApiListTributes
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof TributeApiListTributes
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof TributeApiListTributes
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof TributeApiListTributes
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof TributeApiListTributes
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof TributeApiListTributes
     */
    readonly select?: string
}

/**
 * Request parameters for updateTribute operation in TributeApi.
 * @export
 * @interface TributeApiUpdateTributeRequest
 */
export interface TributeApiUpdateTributeRequest {
    /**
     * Id
     * @type {number}
     * @memberof TributeApiUpdateTribute
     */
    readonly id: number

    /**
     * Tribute
     * @type {ModelsTribute}
     * @memberof TributeApiUpdateTribute
     */
    readonly tribute: ModelsTribute
}

/**
 * TributeApi - object-oriented interface
 * @export
 * @class TributeApi
 * @extends {BaseAPI}
 */
export class TributeApi extends BaseAPI {
    /**
     * 
     * @summary Creates Tribute
     * @param {TributeApiCreateTributeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TributeApi
     */
    public createTribute(requestParameters: TributeApiCreateTributeRequest, options?: any) {
        return TributeApiFp(this.configuration).createTribute(requestParameters.tribute, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes Tribute
     * @param {TributeApiDeleteTributeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TributeApi
     */
    public deleteTribute(requestParameters: TributeApiDeleteTributeRequest, options?: any) {
        return TributeApiFp(this.configuration).deleteTribute(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Tribute
     * @param {TributeApiGetTributeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TributeApi
     */
    public getTribute(requestParameters: TributeApiGetTributeRequest, options?: any) {
        return TributeApiFp(this.configuration).getTribute(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists Tributes
     * @param {TributeApiListTributesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TributeApi
     */
    public listTributes(requestParameters: TributeApiListTributesRequest = {}, options?: any) {
        return TributeApiFp(this.configuration).listTributes(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates Tribute
     * @param {TributeApiUpdateTributeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TributeApi
     */
    public updateTribute(requestParameters: TributeApiUpdateTributeRequest, options?: any) {
        return TributeApiFp(this.configuration).updateTribute(requestParameters.id, requestParameters.tribute, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ZoneApi - axios parameter creator
 * @export
 */
export const ZoneApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Zone
         * @param {ModelsZone} zone Zone
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createZone: async (zone: ModelsZone, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'zone' is not null or undefined
            if (zone === null || zone === undefined) {
                throw new RequiredError('zone','Required parameter zone was null or undefined when calling createZone.');
            }
            const localVarPath = `/zone`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof zone !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(zone !== undefined ? zone : {})
                : (zone || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes Zone
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteZone: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteZone.');
            }
            const localVarPath = `/zone/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Zone
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getZone: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getZone.');
            }
            const localVarPath = `/zone/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists Zones
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listZones: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/zones`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates Zone
         * @param {number} id Id
         * @param {ModelsZone} zone Zone
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateZone: async (id: number, zone: ModelsZone, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateZone.');
            }
            // verify required parameter 'zone' is not null or undefined
            if (zone === null || zone === undefined) {
                throw new RequiredError('zone','Required parameter zone was null or undefined when calling updateZone.');
            }
            const localVarPath = `/zone/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof zone !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(zone !== undefined ? zone : {})
                : (zone || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ZoneApi - functional programming interface
 * @export
 */
export const ZoneApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates Zone
         * @param {ModelsZone} zone Zone
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createZone(zone: ModelsZone, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsZone>>> {
            const localVarAxiosArgs = await ZoneApiAxiosParamCreator(configuration).createZone(zone, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes Zone
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteZone(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await ZoneApiAxiosParamCreator(configuration).deleteZone(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Zone
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getZone(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsZone>>> {
            const localVarAxiosArgs = await ZoneApiAxiosParamCreator(configuration).getZone(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists Zones
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listZones(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsZone>>> {
            const localVarAxiosArgs = await ZoneApiAxiosParamCreator(configuration).listZones(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates Zone
         * @param {number} id Id
         * @param {ModelsZone} zone Zone
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateZone(id: number, zone: ModelsZone, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsZone>>> {
            const localVarAxiosArgs = await ZoneApiAxiosParamCreator(configuration).updateZone(id, zone, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ZoneApi - factory interface
 * @export
 */
export const ZoneApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates Zone
         * @param {ModelsZone} zone Zone
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createZone(zone: ModelsZone, options?: any): AxiosPromise<Array<ModelsZone>> {
            return ZoneApiFp(configuration).createZone(zone, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes Zone
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteZone(id: number, options?: any): AxiosPromise<string> {
            return ZoneApiFp(configuration).deleteZone(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Zone
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getZone(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsZone>> {
            return ZoneApiFp(configuration).getZone(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists Zones
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listZones(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsZone>> {
            return ZoneApiFp(configuration).listZones(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates Zone
         * @param {number} id Id
         * @param {ModelsZone} zone Zone
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateZone(id: number, zone: ModelsZone, options?: any): AxiosPromise<Array<ModelsZone>> {
            return ZoneApiFp(configuration).updateZone(id, zone, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createZone operation in ZoneApi.
 * @export
 * @interface ZoneApiCreateZoneRequest
 */
export interface ZoneApiCreateZoneRequest {
    /**
     * Zone
     * @type {ModelsZone}
     * @memberof ZoneApiCreateZone
     */
    readonly zone: ModelsZone
}

/**
 * Request parameters for deleteZone operation in ZoneApi.
 * @export
 * @interface ZoneApiDeleteZoneRequest
 */
export interface ZoneApiDeleteZoneRequest {
    /**
     * Id
     * @type {number}
     * @memberof ZoneApiDeleteZone
     */
    readonly id: number
}

/**
 * Request parameters for getZone operation in ZoneApi.
 * @export
 * @interface ZoneApiGetZoneRequest
 */
export interface ZoneApiGetZoneRequest {
    /**
     * Id
     * @type {number}
     * @memberof ZoneApiGetZone
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof ZoneApiGetZone
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof ZoneApiGetZone
     */
    readonly select?: string
}

/**
 * Request parameters for listZones operation in ZoneApi.
 * @export
 * @interface ZoneApiListZonesRequest
 */
export interface ZoneApiListZonesRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof ZoneApiListZones
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof ZoneApiListZones
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof ZoneApiListZones
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof ZoneApiListZones
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof ZoneApiListZones
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof ZoneApiListZones
     */
    readonly select?: string
}

/**
 * Request parameters for updateZone operation in ZoneApi.
 * @export
 * @interface ZoneApiUpdateZoneRequest
 */
export interface ZoneApiUpdateZoneRequest {
    /**
     * Id
     * @type {number}
     * @memberof ZoneApiUpdateZone
     */
    readonly id: number

    /**
     * Zone
     * @type {ModelsZone}
     * @memberof ZoneApiUpdateZone
     */
    readonly zone: ModelsZone
}

/**
 * ZoneApi - object-oriented interface
 * @export
 * @class ZoneApi
 * @extends {BaseAPI}
 */
export class ZoneApi extends BaseAPI {
    /**
     * 
     * @summary Creates Zone
     * @param {ZoneApiCreateZoneRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneApi
     */
    public createZone(requestParameters: ZoneApiCreateZoneRequest, options?: any) {
        return ZoneApiFp(this.configuration).createZone(requestParameters.zone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes Zone
     * @param {ZoneApiDeleteZoneRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneApi
     */
    public deleteZone(requestParameters: ZoneApiDeleteZoneRequest, options?: any) {
        return ZoneApiFp(this.configuration).deleteZone(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Zone
     * @param {ZoneApiGetZoneRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneApi
     */
    public getZone(requestParameters: ZoneApiGetZoneRequest, options?: any) {
        return ZoneApiFp(this.configuration).getZone(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists Zones
     * @param {ZoneApiListZonesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneApi
     */
    public listZones(requestParameters: ZoneApiListZonesRequest = {}, options?: any) {
        return ZoneApiFp(this.configuration).listZones(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates Zone
     * @param {ZoneApiUpdateZoneRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneApi
     */
    public updateZone(requestParameters: ZoneApiUpdateZoneRequest, options?: any) {
        return ZoneApiFp(this.configuration).updateZone(requestParameters.id, requestParameters.zone, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ZoneFlagApi - axios parameter creator
 * @export
 */
export const ZoneFlagApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates ZoneFlag
         * @param {ModelsZoneFlag} zoneFlag ZoneFlag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createZoneFlag: async (zoneFlag: ModelsZoneFlag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneFlag' is not null or undefined
            if (zoneFlag === null || zoneFlag === undefined) {
                throw new RequiredError('zoneFlag','Required parameter zoneFlag was null or undefined when calling createZoneFlag.');
            }
            const localVarPath = `/zone_flag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof zoneFlag !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(zoneFlag !== undefined ? zoneFlag : {})
                : (zoneFlag || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes ZoneFlag
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteZoneFlag: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteZoneFlag.');
            }
            const localVarPath = `/zone_flag/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets ZoneFlag
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getZoneFlag: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getZoneFlag.');
            }
            const localVarPath = `/zone_flag/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists ZoneFlags
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listZoneFlags: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/zone_flags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates ZoneFlag
         * @param {number} id Id
         * @param {ModelsZoneFlag} zoneFlag ZoneFlag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateZoneFlag: async (id: number, zoneFlag: ModelsZoneFlag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateZoneFlag.');
            }
            // verify required parameter 'zoneFlag' is not null or undefined
            if (zoneFlag === null || zoneFlag === undefined) {
                throw new RequiredError('zoneFlag','Required parameter zoneFlag was null or undefined when calling updateZoneFlag.');
            }
            const localVarPath = `/zone_flag/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof zoneFlag !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(zoneFlag !== undefined ? zoneFlag : {})
                : (zoneFlag || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ZoneFlagApi - functional programming interface
 * @export
 */
export const ZoneFlagApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates ZoneFlag
         * @param {ModelsZoneFlag} zoneFlag ZoneFlag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createZoneFlag(zoneFlag: ModelsZoneFlag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsZoneFlag>>> {
            const localVarAxiosArgs = await ZoneFlagApiAxiosParamCreator(configuration).createZoneFlag(zoneFlag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes ZoneFlag
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteZoneFlag(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await ZoneFlagApiAxiosParamCreator(configuration).deleteZoneFlag(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets ZoneFlag
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getZoneFlag(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsZoneFlag>>> {
            const localVarAxiosArgs = await ZoneFlagApiAxiosParamCreator(configuration).getZoneFlag(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists ZoneFlags
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listZoneFlags(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsZoneFlag>>> {
            const localVarAxiosArgs = await ZoneFlagApiAxiosParamCreator(configuration).listZoneFlags(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates ZoneFlag
         * @param {number} id Id
         * @param {ModelsZoneFlag} zoneFlag ZoneFlag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateZoneFlag(id: number, zoneFlag: ModelsZoneFlag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsZoneFlag>>> {
            const localVarAxiosArgs = await ZoneFlagApiAxiosParamCreator(configuration).updateZoneFlag(id, zoneFlag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ZoneFlagApi - factory interface
 * @export
 */
export const ZoneFlagApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates ZoneFlag
         * @param {ModelsZoneFlag} zoneFlag ZoneFlag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createZoneFlag(zoneFlag: ModelsZoneFlag, options?: any): AxiosPromise<Array<ModelsZoneFlag>> {
            return ZoneFlagApiFp(configuration).createZoneFlag(zoneFlag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes ZoneFlag
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteZoneFlag(id: number, options?: any): AxiosPromise<string> {
            return ZoneFlagApiFp(configuration).deleteZoneFlag(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets ZoneFlag
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getZoneFlag(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsZoneFlag>> {
            return ZoneFlagApiFp(configuration).getZoneFlag(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists ZoneFlags
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listZoneFlags(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsZoneFlag>> {
            return ZoneFlagApiFp(configuration).listZoneFlags(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates ZoneFlag
         * @param {number} id Id
         * @param {ModelsZoneFlag} zoneFlag ZoneFlag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateZoneFlag(id: number, zoneFlag: ModelsZoneFlag, options?: any): AxiosPromise<Array<ModelsZoneFlag>> {
            return ZoneFlagApiFp(configuration).updateZoneFlag(id, zoneFlag, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createZoneFlag operation in ZoneFlagApi.
 * @export
 * @interface ZoneFlagApiCreateZoneFlagRequest
 */
export interface ZoneFlagApiCreateZoneFlagRequest {
    /**
     * ZoneFlag
     * @type {ModelsZoneFlag}
     * @memberof ZoneFlagApiCreateZoneFlag
     */
    readonly zoneFlag: ModelsZoneFlag
}

/**
 * Request parameters for deleteZoneFlag operation in ZoneFlagApi.
 * @export
 * @interface ZoneFlagApiDeleteZoneFlagRequest
 */
export interface ZoneFlagApiDeleteZoneFlagRequest {
    /**
     * Id
     * @type {number}
     * @memberof ZoneFlagApiDeleteZoneFlag
     */
    readonly id: number
}

/**
 * Request parameters for getZoneFlag operation in ZoneFlagApi.
 * @export
 * @interface ZoneFlagApiGetZoneFlagRequest
 */
export interface ZoneFlagApiGetZoneFlagRequest {
    /**
     * Id
     * @type {number}
     * @memberof ZoneFlagApiGetZoneFlag
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof ZoneFlagApiGetZoneFlag
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof ZoneFlagApiGetZoneFlag
     */
    readonly select?: string
}

/**
 * Request parameters for listZoneFlags operation in ZoneFlagApi.
 * @export
 * @interface ZoneFlagApiListZoneFlagsRequest
 */
export interface ZoneFlagApiListZoneFlagsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof ZoneFlagApiListZoneFlags
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof ZoneFlagApiListZoneFlags
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof ZoneFlagApiListZoneFlags
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof ZoneFlagApiListZoneFlags
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof ZoneFlagApiListZoneFlags
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof ZoneFlagApiListZoneFlags
     */
    readonly select?: string
}

/**
 * Request parameters for updateZoneFlag operation in ZoneFlagApi.
 * @export
 * @interface ZoneFlagApiUpdateZoneFlagRequest
 */
export interface ZoneFlagApiUpdateZoneFlagRequest {
    /**
     * Id
     * @type {number}
     * @memberof ZoneFlagApiUpdateZoneFlag
     */
    readonly id: number

    /**
     * ZoneFlag
     * @type {ModelsZoneFlag}
     * @memberof ZoneFlagApiUpdateZoneFlag
     */
    readonly zoneFlag: ModelsZoneFlag
}

/**
 * ZoneFlagApi - object-oriented interface
 * @export
 * @class ZoneFlagApi
 * @extends {BaseAPI}
 */
export class ZoneFlagApi extends BaseAPI {
    /**
     * 
     * @summary Creates ZoneFlag
     * @param {ZoneFlagApiCreateZoneFlagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneFlagApi
     */
    public createZoneFlag(requestParameters: ZoneFlagApiCreateZoneFlagRequest, options?: any) {
        return ZoneFlagApiFp(this.configuration).createZoneFlag(requestParameters.zoneFlag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes ZoneFlag
     * @param {ZoneFlagApiDeleteZoneFlagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneFlagApi
     */
    public deleteZoneFlag(requestParameters: ZoneFlagApiDeleteZoneFlagRequest, options?: any) {
        return ZoneFlagApiFp(this.configuration).deleteZoneFlag(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets ZoneFlag
     * @param {ZoneFlagApiGetZoneFlagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneFlagApi
     */
    public getZoneFlag(requestParameters: ZoneFlagApiGetZoneFlagRequest, options?: any) {
        return ZoneFlagApiFp(this.configuration).getZoneFlag(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists ZoneFlags
     * @param {ZoneFlagApiListZoneFlagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneFlagApi
     */
    public listZoneFlags(requestParameters: ZoneFlagApiListZoneFlagsRequest = {}, options?: any) {
        return ZoneFlagApiFp(this.configuration).listZoneFlags(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates ZoneFlag
     * @param {ZoneFlagApiUpdateZoneFlagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneFlagApi
     */
    public updateZoneFlag(requestParameters: ZoneFlagApiUpdateZoneFlagRequest, options?: any) {
        return ZoneFlagApiFp(this.configuration).updateZoneFlag(requestParameters.id, requestParameters.zoneFlag, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ZonePointApi - axios parameter creator
 * @export
 */
export const ZonePointApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates ZonePoint
         * @param {ModelsZonePoint} zonePoint ZonePoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createZonePoint: async (zonePoint: ModelsZonePoint, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'zonePoint' is not null or undefined
            if (zonePoint === null || zonePoint === undefined) {
                throw new RequiredError('zonePoint','Required parameter zonePoint was null or undefined when calling createZonePoint.');
            }
            const localVarPath = `/zone_point`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof zonePoint !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(zonePoint !== undefined ? zonePoint : {})
                : (zonePoint || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes ZonePoint
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteZonePoint: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteZonePoint.');
            }
            const localVarPath = `/zone_point/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets ZonePoint
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getZonePoint: async (id: number, includes?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getZonePoint.');
            }
            const localVarPath = `/zone_point/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists ZonePoints
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listZonePoints: async (includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/zone_points`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates ZonePoint
         * @param {number} id Id
         * @param {ModelsZonePoint} zonePoint ZonePoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateZonePoint: async (id: number, zonePoint: ModelsZonePoint, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateZonePoint.');
            }
            // verify required parameter 'zonePoint' is not null or undefined
            if (zonePoint === null || zonePoint === undefined) {
                throw new RequiredError('zonePoint','Required parameter zonePoint was null or undefined when calling updateZonePoint.');
            }
            const localVarPath = `/zone_point/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof zonePoint !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(zonePoint !== undefined ? zonePoint : {})
                : (zonePoint || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ZonePointApi - functional programming interface
 * @export
 */
export const ZonePointApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates ZonePoint
         * @param {ModelsZonePoint} zonePoint ZonePoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createZonePoint(zonePoint: ModelsZonePoint, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsZonePoint>>> {
            const localVarAxiosArgs = await ZonePointApiAxiosParamCreator(configuration).createZonePoint(zonePoint, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes ZonePoint
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteZonePoint(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await ZonePointApiAxiosParamCreator(configuration).deleteZonePoint(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets ZonePoint
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getZonePoint(id: number, includes?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsZonePoint>>> {
            const localVarAxiosArgs = await ZonePointApiAxiosParamCreator(configuration).getZonePoint(id, includes, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Lists ZonePoints
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listZonePoints(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsZonePoint>>> {
            const localVarAxiosArgs = await ZonePointApiAxiosParamCreator(configuration).listZonePoints(includes, where, limit, orderBy, orderDirection, select, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates ZonePoint
         * @param {number} id Id
         * @param {ModelsZonePoint} zonePoint ZonePoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateZonePoint(id: number, zonePoint: ModelsZonePoint, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsZonePoint>>> {
            const localVarAxiosArgs = await ZonePointApiAxiosParamCreator(configuration).updateZonePoint(id, zonePoint, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ZonePointApi - factory interface
 * @export
 */
export const ZonePointApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates ZonePoint
         * @param {ModelsZonePoint} zonePoint ZonePoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createZonePoint(zonePoint: ModelsZonePoint, options?: any): AxiosPromise<Array<ModelsZonePoint>> {
            return ZonePointApiFp(configuration).createZonePoint(zonePoint, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes ZonePoint
         * @param {number} id Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteZonePoint(id: number, options?: any): AxiosPromise<string> {
            return ZonePointApiFp(configuration).deleteZonePoint(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets ZonePoint
         * @param {number} id Id
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getZonePoint(id: number, includes?: string, select?: string, options?: any): AxiosPromise<Array<ModelsZonePoint>> {
            return ZonePointApiFp(configuration).getZonePoint(id, includes, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists ZonePoints
         * @param {string} [includes] Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
         * @param {string} [where] Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
         * @param {string} [limit] Rows to limit in response (Default: 10,000)
         * @param {string} [orderBy] Order by [field]
         * @param {string} [orderDirection] Order by field direction
         * @param {string} [select] Column names [.] separated to fetch specific fields in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listZonePoints(includes?: string, where?: string, limit?: string, orderBy?: string, orderDirection?: string, select?: string, options?: any): AxiosPromise<Array<ModelsZonePoint>> {
            return ZonePointApiFp(configuration).listZonePoints(includes, where, limit, orderBy, orderDirection, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates ZonePoint
         * @param {number} id Id
         * @param {ModelsZonePoint} zonePoint ZonePoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateZonePoint(id: number, zonePoint: ModelsZonePoint, options?: any): AxiosPromise<Array<ModelsZonePoint>> {
            return ZonePointApiFp(configuration).updateZonePoint(id, zonePoint, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createZonePoint operation in ZonePointApi.
 * @export
 * @interface ZonePointApiCreateZonePointRequest
 */
export interface ZonePointApiCreateZonePointRequest {
    /**
     * ZonePoint
     * @type {ModelsZonePoint}
     * @memberof ZonePointApiCreateZonePoint
     */
    readonly zonePoint: ModelsZonePoint
}

/**
 * Request parameters for deleteZonePoint operation in ZonePointApi.
 * @export
 * @interface ZonePointApiDeleteZonePointRequest
 */
export interface ZonePointApiDeleteZonePointRequest {
    /**
     * Id
     * @type {number}
     * @memberof ZonePointApiDeleteZonePoint
     */
    readonly id: number
}

/**
 * Request parameters for getZonePoint operation in ZonePointApi.
 * @export
 * @interface ZonePointApiGetZonePointRequest
 */
export interface ZonePointApiGetZonePointRequest {
    /**
     * Id
     * @type {number}
     * @memberof ZonePointApiGetZonePoint
     */
    readonly id: number

    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof ZonePointApiGetZonePoint
     */
    readonly includes?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof ZonePointApiGetZonePoint
     */
    readonly select?: string
}

/**
 * Request parameters for listZonePoints operation in ZonePointApi.
 * @export
 * @interface ZonePointApiListZonePointsRequest
 */
export interface ZonePointApiListZonePointsRequest {
    /**
     * Relationships [all] for all [number] for depth of relationships to load or [.] separated relationship names 
     * @type {string}
     * @memberof ZonePointApiListZonePoints
     */
    readonly includes?: string

    /**
     * Filter on specific fields. Multiple conditions [.] separated Example: col_like_value.col2__val2
     * @type {string}
     * @memberof ZonePointApiListZonePoints
     */
    readonly where?: string

    /**
     * Rows to limit in response (Default: 10,000)
     * @type {string}
     * @memberof ZonePointApiListZonePoints
     */
    readonly limit?: string

    /**
     * Order by [field]
     * @type {string}
     * @memberof ZonePointApiListZonePoints
     */
    readonly orderBy?: string

    /**
     * Order by field direction
     * @type {string}
     * @memberof ZonePointApiListZonePoints
     */
    readonly orderDirection?: string

    /**
     * Column names [.] separated to fetch specific fields in response
     * @type {string}
     * @memberof ZonePointApiListZonePoints
     */
    readonly select?: string
}

/**
 * Request parameters for updateZonePoint operation in ZonePointApi.
 * @export
 * @interface ZonePointApiUpdateZonePointRequest
 */
export interface ZonePointApiUpdateZonePointRequest {
    /**
     * Id
     * @type {number}
     * @memberof ZonePointApiUpdateZonePoint
     */
    readonly id: number

    /**
     * ZonePoint
     * @type {ModelsZonePoint}
     * @memberof ZonePointApiUpdateZonePoint
     */
    readonly zonePoint: ModelsZonePoint
}

/**
 * ZonePointApi - object-oriented interface
 * @export
 * @class ZonePointApi
 * @extends {BaseAPI}
 */
export class ZonePointApi extends BaseAPI {
    /**
     * 
     * @summary Creates ZonePoint
     * @param {ZonePointApiCreateZonePointRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZonePointApi
     */
    public createZonePoint(requestParameters: ZonePointApiCreateZonePointRequest, options?: any) {
        return ZonePointApiFp(this.configuration).createZonePoint(requestParameters.zonePoint, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes ZonePoint
     * @param {ZonePointApiDeleteZonePointRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZonePointApi
     */
    public deleteZonePoint(requestParameters: ZonePointApiDeleteZonePointRequest, options?: any) {
        return ZonePointApiFp(this.configuration).deleteZonePoint(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets ZonePoint
     * @param {ZonePointApiGetZonePointRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZonePointApi
     */
    public getZonePoint(requestParameters: ZonePointApiGetZonePointRequest, options?: any) {
        return ZonePointApiFp(this.configuration).getZonePoint(requestParameters.id, requestParameters.includes, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists ZonePoints
     * @param {ZonePointApiListZonePointsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZonePointApi
     */
    public listZonePoints(requestParameters: ZonePointApiListZonePointsRequest = {}, options?: any) {
        return ZonePointApiFp(this.configuration).listZonePoints(requestParameters.includes, requestParameters.where, requestParameters.limit, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates ZonePoint
     * @param {ZonePointApiUpdateZonePointRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZonePointApi
     */
    public updateZonePoint(requestParameters: ZonePointApiUpdateZonePointRequest, options?: any) {
        return ZonePointApiFp(this.configuration).updateZonePoint(requestParameters.id, requestParameters.zonePoint, options).then((request) => request(this.axios, this.basePath));
    }
}


